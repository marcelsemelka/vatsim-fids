<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VATSIM FIDS</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-root: #0f1115;
      --bg-gradient: radial-gradient(circle at 50% 0%, #1e293b 0%, #0f1115 60%);
      --glass-surface: rgba(30, 41, 59, 0.65);
      --glass-border: rgba(255, 255, 255, 0.08);
      --glass-highlight: rgba(255, 255, 255, 0.03);
      --primary: #3b82f6; --primary-dim: rgba(59, 130, 246, 0.15);
      --text-main: #f1f5f9; --text-muted: #94a3b8;
      --good: #10b981; --good-bg: rgba(16, 185, 129, 0.15);
      --warn: #f59e0b; --warn-bg: rgba(245, 158, 11, 0.15);
      --bad: #ef4444;  --bad-bg: rgba(239, 68, 68, 0.15);
      --info: #0ea5e9; --info-bg: rgba(14, 165, 233, 0.15);
      --font-ui: 'Inter', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
    }

    * { box-sizing: border-box; }
    body { margin: 0; background-color: var(--bg-root); background-image: var(--bg-gradient); background-attachment: fixed; color: var(--text-main); font-family: var(--font-ui); padding-bottom: 60px; min-height: 100vh; -webkit-font-smoothing: antialiased; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.25); }

    header { position: sticky; top: 0; z-index: 50; background: rgba(15, 17, 21, 0.85); border-bottom: 1px solid var(--glass-border); backdrop-filter: blur(16px); box-shadow: 0 4px 20px rgba(0,0,0,0.2); }
    .wrap { max-width: 1600px; margin: 0 auto; padding: 12px 20px; }
    .topbar { display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 10px; }
    @media (max-width: 900px) {
       .topbar { display: flex; flex-direction: column; gap: 16px; }
    }
    .brand { display: flex; flex-direction: column; }
    .brand h1 { margin: 0; font-size: 20px; font-weight: 700; letter-spacing: -0.02em; background: linear-gradient(90deg, #fff, #94a3b8); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    .brand .sub { font-size: 11px; color: var(--text-muted); font-family: var(--font-mono); text-transform: uppercase; letter-spacing: 0.05em; margin-top: 2px; }


    .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; justify-content: flex-end; }

    /* App Fullscreen (Visual Stretch) */
    body.app-full { overflow: hidden; }
    body.app-full header { position: fixed; width: 100%; top: 0; }
    body.app-full main { padding-top: 80px; }
    body.app-full .wrap { max-width: 100% !important; padding: 0 10px !important; }
    body.app-full main .wrap { height: calc(100vh - 140px); }
    body.app-full .grid { height: 100%; gap: 10px; }
    body.app-full .board { min-height: 0; flex: 1; }
    body.app-full footer { position: fixed; bottom: 0; width: 100%; }


    /* New Tabs UI in Header */
    .airportTabs { display: flex; background: rgba(0,0,0,0.3); border: 1px solid var(--glass-border); border-radius: 8px; padding: 2px; gap: 2px; }
    .airportTab { border: none; background: transparent; color: var(--text-muted); padding: 6px 12px; font-size: 13px; font-weight: 700; border-radius: 6px; cursor: pointer; transition: all 0.2s; font-family: var(--font-mono); text-transform: uppercase; }
    .airportTab:hover { background: rgba(255,255,255,0.05); color: #fff; }
    .airportTab.active { background: var(--primary-dim); color: var(--primary); box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.2); }
    .airportTab:disabled { opacity: 0.3; cursor: default; background: transparent; box-shadow: none; color: var(--text-muted); }

    label { font-size: 11px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; }
    input, select, button { background: rgba(0,0,0,0.3); color: var(--text-main); border: 1px solid var(--glass-border); border-radius: 8px; padding: 8px 12px; font-size: 13px; outline: none; font-family: var(--font-ui); transition: all 0.2s ease; }
    input:focus, select:focus { border-color: var(--primary); box-shadow: 0 0 0 2px var(--primary-dim); background: rgba(0,0,0,0.5); }
    input { font-family: var(--font-mono); text-transform: uppercase; font-weight: 600; letter-spacing: 0.05em; width: 80px; text-align: center; }
    button { cursor: pointer; font-weight: 600; background: rgba(255,255,255,0.03); }
    button:hover { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.2); }
    button:active { transform: translateY(1px); }

    .pill { font-family: var(--font-mono); font-size: 11px; padding: 6px 12px; border-radius: 6px; border: 1px solid var(--glass-border); background: rgba(0,0,0,0.2); color: var(--text-muted); display: inline-flex; gap: 8px; align-items: center; white-space: nowrap; }
    .pill.clockPill { background: rgba(14, 165, 233, 0.08); border-color: rgba(14, 165, 233, 0.2); color: #bae6fd; }
    #utcClock { font-weight: 700; color: #fff; letter-spacing: 0.05em; font-size: 1.25em; }
    .dot { width: 6px; height: 6px; border-radius: 50%; background: var(--text-muted); box-shadow: 0 0 5px rgba(255,255,255,0.1); }
    .dot.good { background: var(--good); box-shadow: 0 0 6px var(--good); }
    .dot.warn { background: var(--warn); box-shadow: 0 0 6px var(--warn); }
    .dot.bad { background: var(--bad); box-shadow: 0 0 6px var(--bad); }
    .dot.info { background: var(--info); box-shadow: 0 0 6px var(--info); }

    main .wrap { padding-top: 24px; padding-bottom: 40px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
    @media (max-width: 1100px) { .grid { grid-template-columns: 1fr; } }

    .board { background: var(--glass-surface); backdrop-filter: blur(12px); border: 1px solid var(--glass-border); border-radius: 16px; overflow: hidden; box-shadow: 0 20px 40px rgba(0,0,0,0.3); display: flex; flex-direction: column; min-height: 500px; }
    .boardHeader { display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--glass-border); background: rgba(255,255,255,0.02); }
    .boardHeader h2 { margin: 0; font-size: 14px; letter-spacing: 0.1em; text-transform: uppercase; font-weight: 700; color: var(--text-main); display: flex; align-items: center; gap: 8px; }
    .boardHeader h2::before { content:''; display:block; width:4px; height:16px; background:var(--primary); border-radius:2px; }
    .boardHeader .mini { display: flex; gap: 8px; align-items: center; }

    .hint { font-size: 11px; color: var(--text-muted); font-weight: 500; }

    table { width: 100%; border-collapse: collapse; font-family: var(--font-mono); font-size: 12px; table-layout: fixed; }

    thead th {
      text-align: left; color: var(--text-muted); font-weight: 600; font-size: 11px; text-transform: uppercase; letter-spacing: 0.05em;
      padding: 12px 16px; border-bottom: 1px solid var(--glass-border); background: rgba(15, 17, 21, 0.95); position: sticky; top: 0; z-index: 10; backdrop-filter: blur(10px);
    }

    tbody tr { transition: background 0.15s, transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1); will-change: transform, opacity; border-bottom: 1px solid rgba(255,255,255,0.03); }
    tbody tr:last-child { border-bottom: none; }
    tbody tr:hover { background: var(--glass-highlight); }

    tbody td {
      padding: 10px 16px; vertical-align: middle; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-main);
    }

    .cell-route { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: help; }
    .cell-route .muted { opacity: 0.6; font-size: 11px; }

    tbody tr.removing { opacity: 0; transform: scale(0.98) translateY(-10px); pointer-events: none; }
    tbody tr.adding { opacity: 0; transform: translateY(10px); }
    tbody tr.finishedRow,
    tbody tr.groundRow { opacity: 0.5; filter: grayscale(0.6); }
    tbody tr.finishedRow:hover,
    tbody tr.groundRow:hover { opacity: 0.8; }

    /* Arrivals: subtle separator above the landed block */
    tbody tr.landedDivider {
      border-top: 3px solid rgba(255,255,255,0.10);
    }

    .right { text-align: right; }
    .center { text-align: center; }
    .muted { color: var(--text-muted); }

    .badge { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 99px; font-size: 11px; font-weight: 600; letter-spacing: 0.02em; border: 1px solid transparent; transition: all 0.3s ease; }
    .badge .sDot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; opacity: 0.8; }
    .badge.good { background: var(--good-bg); color: var(--good); border-color: rgba(16, 185, 129, 0.2); }
    .badge.warn { background: var(--warn-bg); color: var(--warn); border-color: rgba(245, 158, 11, 0.2); }
    .badge.bad  { background: var(--bad-bg); color: var(--bad); border-color: rgba(239, 68, 68, 0.2); }
    .badge.info { background: var(--info-bg); color: var(--info); border-color: rgba(14, 165, 233, 0.2); }
    .badge.blink { animation: pulseGlow 1.5s infinite; }
    @keyframes pulseGlow { 0% { box-shadow: 0 0 0 0 rgba(255,255,255,0.1); } 70% { box-shadow: 0 0 0 6px rgba(255,255,255,0); } 100% { box-shadow: 0 0 0 0 rgba(255,255,255,0); } }

    .xpPill { display: inline-flex; align-items: center; gap: 6px; padding: 3px 8px; border-radius: 6px; font-size: 11px; font-weight: 600; border: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.2); cursor: help; user-select: none; transition: 0.2s; }
    .xpPill:hover { background: rgba(255,255,255,0.05); border-color: rgba(255,255,255,0.2); }
    .xpPill .xDot { width: 6px; height: 6px; border-radius: 50%; }
    .xpPill.good .xDot { background: var(--good); box-shadow: 0 0 5px var(--good); }
    .xpPill.warn .xDot { background: var(--warn); box-shadow: 0 0 5px var(--warn); }
    .xpPill.bad  .xDot { background: var(--bad);  box-shadow: 0 0 5px var(--bad); }
    .xpPill.info .xDot { background: var(--info); box-shadow: 0 0 5px var(--info); }
    .xpPill.missing { opacity: 0.5; background: rgba(255,255,255,0.02); border-color: transparent; cursor: default; }
    .xpPill.missing .xDot { background: var(--text-muted); }
    .xpPill.loading { opacity: 0.6; cursor: wait; }
    .xpPill .spinner { width: 10px; height: 10px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.1); border-top-color: #fff; animation: spin 0.8s linear infinite; }
    @keyframes spin { to{ transform: rotate(360deg); } }

    .dayPlus { margin-left: 4px; font-size: 10px; color: var(--text-muted); font-family: var(--font-mono); }

    /* Time cell: show current time type (STD/ETD/ETA/ALDT/AIBT) in top-left */
    td.timeCell {
      position: relative;
      padding-top: 18px; /* make room for the small label */
    }
        td.timeCell.hasSub { padding-bottom: 16px; } /* room for the optional sub line */
    td.timeCell .timeKind {
      position: absolute;
      top: 4px;
      left: 6px;
      font-size: 9px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
      opacity: 0.75;
      pointer-events: none;
      user-select: none;
    }
    td.timeCell .timeKind.blink { animation: blinkSoft 1.3s infinite; }
    td.timeCell .timeVal { display: block; }
    td.timeCell .timeVal.blink { animation: blinkSoft 1.3s infinite; }
    td.timeCell .timeSub{
      position: absolute;
      bottom: 3px;
      left: 6px;
      font-size: 9px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
      opacity: 0.70;
      pointer-events: none;
      user-select: none;
      white-space: nowrap;
    }
    td.timeCell .timeSub .subKind{ margin-right: 6px; opacity: 0.85; }
    @keyframes blinkSoft { 0%,100% { opacity: 0.25; } 50% { opacity: 0.95; } }


    .tooltip { position: fixed; z-index: 100; pointer-events: none; background: rgba(15, 23, 42, 0.95); border: 1px solid rgba(255,255,255,0.1); padding: 12px; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); font-family: var(--font-mono); font-size: 14px; line-height: 1.5; color: #e2e8f0; opacity: 0; transform: translate(-50%, -115%) scale(0.95); transition: opacity 0.15s, transform 0.15s; white-space: pre; backdrop-filter: blur(8px); }
    .tooltip.show { opacity: 1; transform: translate(-50%, -115%) scale(1); }
    /* Tooltip South modifier (Compacter layout for Tabs) */
    .tooltip.south { transform: translate(-50%, 24px) scale(0.95); padding: 4px 8px; line-height: 2.5; white-space:normal;}
    .tooltip.south.show { transform: translate(-50%, 24px) scale(1); }

    .modal.pilotModal{
      width: min(680px, 100%);
    }
    .modalBody.pilotBody{
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 18px 20px;
      grid-template-columns: none;
    }
    @media (max-width: 800px){
      .modalBody.pilotBody{ padding: 16px; }
    }
    /* Hide Pilot History completely (UI + no longer needed visually) */
    .pilotHistoryCard{
      display: none !important;
    }

    .modalOverlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); backdrop-filter: blur(5px); display: none; align-items: center; justify-content: center; z-index: 200; padding: 20px; animation: fadeIn 0.2s ease-out; }
    @keyframes fadeIn { from{opacity:0;} to{opacity:1;} }
    .modalOverlay.show { display: flex; }
    .modal { width: min(800px, 100%); background: #1e293b; border: 1px solid rgba(255,255,255,0.1); border-radius: 16px; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5); overflow: hidden; display: flex; flex-direction: column; }
    .modalHead { padding: 16px 24px; background: rgba(0,0,0,0.2); border-bottom: 1px solid rgba(255,255,255,0.05); display: flex; justify-content: space-between; align-items: center; }
    .modalHead h3 { margin: 0; font-size: 16px; color: #fff; letter-spacing: 0.05em; text-transform: uppercase; }
    .modalHead .close { background: transparent; border: none; font-size: 20px; padding: 4px; color: var(--text-muted); }
    .modalHead .close:hover { color: #fff; background: rgba(255,255,255,0.1); }
    .modalBody { padding: 24px; display: grid; grid-template-columns: 1.2fr 0.8fr; gap: 24px; overflow-y: auto; max-height: 80vh; scrollbar-gutter: stable; }
    @media (max-width: 800px) { .modalBody { grid-template-columns: 1fr; } }
    .card { background: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.05); border-radius: 12px; padding: 16px; }
    .card h4 { margin: 0 0 16px 0; font-size: 11px; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 8px; }
    .kv { display: grid; grid-template-columns: 140px 1fr; gap: 8px; font-family: var(--font-mono); font-size: 13px; }
    .kv .k { color: var(--text-muted); }
    .kv .v { color: #fff; overflow-wrap: anywhere; }
    .list { margin: 0; padding-left: 20px; font-family: var(--font-mono); font-size: 12px; color: var(--text-muted); line-height: 1.6; }
    .list li { margin-bottom: 6px; }
    .linkRow { margin-top: 16px; display: flex; gap: 10px; }
    .aBtn { display: inline-flex; align-items: center; padding: 8px 16px; border-radius: 6px; background: var(--primary-dim); color: var(--primary); text-decoration: none; font-size: 12px; font-weight: 600; border: 1px solid rgba(59, 130, 246, 0.2); transition: 0.2s; }
    .aBtn:hover { background: var(--primary); color: #fff; }

    .formGrid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .field { display: flex; flex-direction: column; gap: 6px; }
    .field input[type="text"], .field input[type="number"], .field select { width: 100%; text-align: left; }
    .fieldRow { display: flex; flex-wrap: wrap; gap: 12px; font-size: 13px; color: var(--text-muted); align-items: center; }
    .btnRow { display: flex; justify-content: flex-end; gap: 10px; margin-top: 24px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.05); }
    .btnGhost { background: transparent; border: 1px solid transparent; color: var(--text-muted); }
    .btnGhost:hover { color: #fff; background: rgba(255,255,255,0.05); }
    .btnPrimary { background: var(--primary); color: #fff; border-color: transparent; }
    .btnPrimary:hover { background: #2563eb; }
    .btnDanger { color: var(--bad); background: rgba(239, 68, 68, 0.1); border-color: transparent; }
    .btnDanger:hover { background: var(--bad); color: #fff; }

    /* Config Tabs + Column Layout UI */
    .tabs { display:flex; gap:8px; padding: 0 2px 14px; margin-bottom: 14px; border-bottom: 1px solid rgba(255,255,255,0.07); flex-wrap:wrap; }
    .tabBtn { padding: 8px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03); color: var(--text-muted); font-weight: 700; font-size: 12px; cursor: pointer; }
    .tabBtn:hover { color: #fff; border-color: rgba(255,255,255,0.18); background: rgba(255,255,255,0.06); }
    .tabBtn.active { color: #fff; background: rgba(59,130,246,0.18); border-color: rgba(59,130,246,0.35); }
    .tabPanel { display:none; }
    .tabPanel.active { display:block; }

    /* Config Modal: fixed/stable height (no jumping on tab switch) */
    .modal.cfgModal{
      width: min(700px, 100%);
      height: min(760px, 86vh);
    }
    .modalBody.cfgBody{
      display:block;
      flex: 1 1 auto;
      min-height: 0;        /* critical for flex + overflow scrolling */
      max-height: none;     /* modal controls height now */
      overflow-y: auto;
      scrollbar-gutter: stable;
      overscroll-behavior: contain;
    }

    /* Cache UI */
    .cacheBar{
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.10);
      overflow: hidden;
      margin: 12px 0 14px;
    }
    .cacheBarFill{
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(59,130,246,0.9), rgba(16,185,129,0.9));
      transition: width 0.25s ease;
    }
    .cacheList{ display:flex; flex-direction:column; gap:8px; margin-top: 10px; }
    .cacheRow{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(0,0,0,0.16);
      font-family: var(--font-mono);
      font-size: 12px;
    }
    .cacheRow .k{ flex: 1; min-width: 0; color:#e2e8f0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .cacheRow .v{ flex: 0 0 auto; color: var(--text-muted); }

    .colHelp { font-size: 12px; color: var(--text-muted); margin-bottom: 10px; }
    .colList { display:flex; flex-direction:column; gap:8px; }
    .colItem { display:flex; align-items:center; gap:10px; padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.08); background: rgba(0,0,0,0.16); }
    .colItem .name { flex:1; font-family: var(--font-mono); font-size: 12px; color:#e2e8f0; }
    .colItem .miniBtns { display:flex; gap:6px; }
    .colItem .miniBtns button { padding: 6px 10px; border-radius: 10px; font-family: var(--font-mono); }

    footer.legendBar { position: fixed; bottom: 0; left: 0; right: 0; z-index: 60; background: rgba(15, 17, 21, 0.9); backdrop-filter: blur(12px); border-top: 1px solid var(--glass-border); font-family: var(--font-mono); font-size: 11px; }
    .legendInner { max-width: 1600px; margin: 0 auto; padding: 10px 20px; display: flex; flex-wrap: wrap; gap: 16px; align-items: center; color: var(--text-muted); }
    .legendTitle { font-weight: 700; color: #fff; text-transform: uppercase; letter-spacing: 0.05em; }
    .legendNote { opacity: 0.7; margin-right: auto; }

    /* Status pills in footer */
    .statusGroup { display: flex; gap: 12px; margin-left: auto; align-items: center; }
    .statusGroup .pill { padding: 4px 10px; font-size: 10px; height: 24px; background: rgba(255,255,255,0.03); border-color: rgba(255,255,255,0.1); }

  </style>
</head>
<body>

<header>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <h1 id="brandTitle">VATSIM FIDS</h1>
        <div class="sub" id="brandSub">Local Board · V0.8a</div>
      </div>

        <div class="airportTabs" id="airportTabs"></div>
      <div class="controls">
        <span class="pill clockPill" id="utcPill" title="Uhrzeit in UTC">
          <span class="dot info"></span>
          <span>UTC</span>
          <span id="utcClock">--:--:--</span>
        </span>

        <div style="height:24px; border-left:1px solid var(--glass-border); margin:0 8px;"></div>

                <button id="fullscreenBtn" title="Anwendung strecken">⛶</button>
        <button id="configBtn" title="Einstellungen">⚙</button>
        <button id="refreshBtn" title="Sofort neu laden">↻</button>
      </div>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="wrap">
    <div class="grid">
      <section class="board">
        <div class="boardHeader">
          <h2 id="depTitle">Departures</h2>
          <div class="mini">
            <span class="hint" id="depSortHint">Sort:</span>
            <select id="depSort"></select>
            <button id="depDir" title="Sortierreihenfolge umkehren">▲</button>
          </div>
        </div>
        <table id="depTable">
          <thead><tr id="depHeadRow"></tr></thead>
          <tbody id="depBody"></tbody>
        </table>
      </section>

      <section class="board">
        <div class="boardHeader">
          <h2 id="arrTitle">Arrivals</h2>
          <div class="mini">
            <span class="hint" id="arrSortHint">Sort:</span>
            <select id="arrSort"></select>
            <button id="arrDir" title="Sortierreihenfolge umkehren">▲</button>
          </div>
        </div>
        <table id="arrTable">
          <thead><tr id="arrHeadRow"></tr></thead>
          <tbody id="arrBody"></tbody>
        </table>
      </section>
    </div>
  </div>
</main>

<div id="tooltip" class="tooltip" aria-hidden="true"></div>

<div id="pilotModalOverlay" class="modalOverlay" role="dialog" aria-modal="true">
  <div class="modal pilotModal">
    <div class="modalHead">
      <div>
        <h3 id="pilotModalTitle">Pilot Analyse</h3>
        <div class="tiny" id="pilotModalSubtitle" style="color:var(--text-muted); font-size:12px; margin-top:4px;">—</div>
      </div>
      <button class="close" id="pilotModalClose">✕</button>
    </div>

    <div class="modalBody pilotBody">
      <div class="card">
        <h4 id="pilotCardFlightData">Flight Data</h4>
        <div class="kv" id="flightKv"></div>
      </div>

      <div class="card">
        <h4 id="pilotCardStats">Pilot Stats & Heuristic</h4>
        <div class="kv" id="xpKv"></div>
        <div style="margin-top:16px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.1);">
          <h4 id="pilotCardBreakdown" style="margin-bottom:8px; border:none;">XP Breakdown</h4>
          <ul class="list" id="xpList"></ul>
        </div>
        <div class="linkRow" id="xpLinks"></div>
      </div>

      <!-- kept for backward-compat (JS hooks), but fully hidden via .pilotHistoryCard -->
      <div class="card pilotHistoryCard" style="height:fit-content;" aria-hidden="true">
        <h4 id="pilotCardHistory">History (On Demand)</h4>
        <div class="tiny" id="historyNote" style="color:var(--text-muted); font-size:11px; margin-bottom:12px;">
          Daten werden live von der VATSIM API geladen um das Ratenlimit zu schonen.
        </div>
        <div class="kv" id="historyKv"></div>
      </div>
    </div>
  </div>
</div>

<div id="configModalOverlay" class="modalOverlay" role="dialog" aria-modal="true">
  <div class="modal cfgModal">
    <div class="modalHead">
      <h3 id="cfgModalTitle">Einstellungen</h3>
      <button class="close" id="configClose">✕</button>
    </div>

    <div class="modalBody cfgBody">
      <div class="tabs" role="tablist" aria-label="Config Tabs">
        <button class="tabBtn active" type="button" data-tab="general" id="cfgTabGeneral">Allgemein</button>
        <button class="tabBtn" type="button" data-tab="display" id="cfgTabDisplay">Anzeige</button>
        <button class="tabBtn" type="button" data-tab="xp" id="cfgTabXp">XP Score</button>
                <button class="tabBtn" type="button" data-tab="cache" id="cfgTabCache">Cache</button>
      </div>

      <div class="tabPanel active" data-tab="general">
        <div class="card">
          <h4 id="cfgGeneralTitle">Allgemeine Konfiguration</h4>
          <div class="formGrid">
            <div class="field">
              <label id="cfgAirportLabel">Airports (Tabs)</label>
              <div style="display:flex; gap:8px;">
                <input id="cfgAirport1" type="text" maxlength="4" placeholder="1" />
                <input id="cfgAirport2" type="text" maxlength="4" placeholder="2" />
                <input id="cfgAirport3" type="text" maxlength="4" placeholder="3" />
              </div>
              <div class="tiny" style="margin-top:4px; color:var(--text-muted);">
                 Maximal 3 Flughäfen gleichzeitig überwachen.
              </div>
            </div>

            <div class="field">
              <label for="cfgInterval" id="cfgIntervalLabel">Refresh Rate (Sek.)</label>
              <input id="cfgInterval" type="number" min="15" max="120" step="5" />
            </div>

            <div class="field">
              <label for="cfgLanguage" id="cfgLanguageLabel">Sprache</label>
              <select id="cfgLanguage">
                <option value="de">Deutsch</option>
                <option value="en">English</option>
              </select>
            </div>

          </div>
        </div>
      </div>

      <div class="tabPanel" data-tab="display">
        <div class="card">
          <h4 id="cfgDisplayTitle">Anzeige</h4>

                 <div class="field" style="margin: 6px 0 14px 0;">
            <label id="cfgFilterLabel">Filter & Darstellung</label>
            <div class="fieldRow" style="padding:8px 0;">
              <label style="display:flex; gap:8px; cursor:pointer;"><input id="cfgPrefiles" type="checkbox" /> <span id="cfgPrefilesText">Prefiles anzeigen</span></label>
              <label style="display:flex; gap:8px; cursor:pointer;"><input id="cfgHideArrLanded" type="checkbox" /> <span id="cfgHideArrText">Arr: Gelandete ausblenden</span></label>
              <label style="display:flex; gap:8px; cursor:pointer;"><input id="cfgHideDepFinished" type="checkbox" /> <span id="cfgHideDepText">Dep. Gelandete ausblenden</span></label>
            </div>
          </div>
 <div class="colHelp" id="cfgDisplayHelp">Spalten ein-/ausblenden und Reihenfolge anpassen (wirkt nach „Speichern“).</div>
          <div style="display:grid; grid-template-columns: 1fr 1fr; gap:16px;">
            <div>
              <div class="colHelp" style="margin:0 0 8px 0; font-weight:700; letter-spacing:.08em; text-transform:uppercase;" id="cfgDisplayDepTitle">Departures Board</div>
              <div class="colList" id="cfgDepCols"></div>
            </div>
            <div>
              <div class="colHelp" style="margin:0 0 8px 0; font-weight:700; letter-spacing:.08em; text-transform:uppercase;" id="cfgDisplayArrTitle">Arrivals Board</div>
              <div class="colList" id="cfgArrCols"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="tabPanel" data-tab="xp">
        <div class="card">
                   <div class="field" style="grid-column:1/-1; margin: 6px 0 14px 0;">
            <label id="cfgAgeBonusLabel">Registration/Age-Bonus</label>
            <div class="fieldRow" style="padding:8px 0;">
              <label style="display:flex; gap:8px; cursor:pointer;">
                <input id="cfgAgeBonus" type="checkbox" />
                <span id="cfgAgeBonusText">Registration/Age-Bonus aktivieren (zusätzlicher API Abruf)</span>
              </label>
            </div>
            <div class="tiny" id="cfgAgeBonusHint" style="color:var(--text-muted); font-size:11px;"></div>
          </div>
<h4 id="cfgXpTitle">XP Score (0-100)</h4>
          <div class="formGrid" style="grid-template-columns: 1fr 1fr 1fr 1fr;">
            <div class="field"><label id="cfgT1Label">T1 (Neu)</label><input id="cfgT1" type="number" /></div>
            <div class="field"><label id="cfgT2Label">T2 (Start)</label><input id="cfgT2" type="number" /></div>
            <div class="field"><label id="cfgT3Label">T3 (Fortg.)</label><input id="cfgT3" type="number" /></div>
            <div class="field"><label id="cfgT4Label">T4 (Erf.)</label><input id="cfgT4" type="number" /></div>
          </div>
        </div>
      </div>

      <div class="tabPanel" data-tab="cache">
        <div class="card">
          <h4 id="cfgCacheTitle">Cache Status</h4>
          <div class="kv" id="cfgCacheKv"></div>
          <div class="cacheBar" aria-hidden="true"><div class="cacheBarFill" id="cfgCacheBarFill"></div></div>
          <div class="colHelp" id="cfgCacheBreakdownTitle" style="margin: 0 0 8px 0;">Größte Cache-Blöcke</div>
          <div class="cacheList" id="cfgCacheBreakdown"></div>

          <div class="btnRow" style="justify-content: space-between;">
            <div class="hint" id="cfgCacheHint">—</div>
            <div style="display:flex; gap:10px; align-items:center;">
              <button id="cfgCacheRefresh" class="btnGhost" type="button">Aktualisieren</button>
              <button id="cfgResetCache" class="btnDanger" type="button">Cache Reset</button>
            </div>
          </div>
        </div>
      </div>

      <div class="btnRow">
        <button id="cfgDefaults" class="btnGhost" type="button">Standard</button>
        <button id="cfgCancel" class="btnGhost" type="button">Abbrechen</button>
        <button id="cfgSave" class="btnPrimary" type="button">Speichern</button>
      </div>
    </div>
  </div>
</div>

<footer class="legendBar" aria-hidden="true">
  <div class="legendInner">
     <div id="legendContent" style="display:contents"></div>
     <div class="statusGroup">
        <span class="pill" id="feedPill" title="Status vom VATSIM-Datafeed">
          <span class="dot" id="feedDot"></span>
          <span id="feedText">Feed: —</span>
          <span class="muted" id="feedAge">—</span>
        </span>
        <span class="pill" id="apiPill" title="Core API Queue / Rate Limit">
          <span class="dot" id="apiDot"></span>
          <span id="apiText">API Q: —</span>
          <span class="muted" id="apiExtra">—</span>
        </span>
     </div>
  </div>
</footer>

<script>
(() => {
  /********************
   * Endpoints / Daten
   ********************/
  const DB_CONFIG = {
    enabled: true, // HIER AKTIVIEREN/DEAKTIVIEREN
    apiUrl: "vFIDS_api.php"
  };
  const VATSIM_DATA_URL = "https://data.vatsim.net/v3/vatsim-data.json";
  const CORE_API_BASE = "https://api.vatsim.net/v2";
  const CORS_PROXY = "https://vfids.marcelsemelka.workers.dev/?url=";
  // Fallback-Proxy (hilft gegen sporadische 504 vom Worker/Upstream)
  const OVERPASS_PROXIES = [
    CORS_PROXY,
    "https://corsproxy.io/?url="
  ];
  const AIRPORTS_URL = "https://cdn.jsdelivr.net/npm/airport-data@1.0.1/airports.json";

  /********************
   * i18n
   ********************/
  const I18N = {
    de: {
      brand_sub: "V0.8a",
      airport_label: "Airports (Tabs)",
      cfg_title: "Einstellungen",
      refresh_title: "Sofort neu laden",
      config_title: "Einstellungen",
      dep_title: "Abflüge",
      arr_title: "Ankünfte",
      sort_hint: "Sort:",
      sort_status: "Status (Smart)",
      sort_time_std: "STD/ETA (Zeit)",
      sort_time_eta: "ETA (Heur.)",
      sort_callsign: "Callsign",
      sort_dest: "Destination",
      sort_orig: "Origin",
      sort_xp: "Pilot XP",
      th_time_std: "STD/ETA",
      th_time_eta: "ETA",
      th_to: "Nach",
      th_from: "Von",
      th_callsign: "Callsign",
      th_type_route: "Typ / Route",
      th_alt_gs: "Alt/GS",
      th_status: "Status",
      th_xp: "XP",
      utc_title: "Uhrzeit in UTC",
      feed_title: "Status vom VATSIM-Datafeed",
      api_title: "Core API Queue / Rate Limit",
      dep_dir_title: "Sortierreihenfolge umkehren",
      arr_dir_title: "Sortierreihenfolge umkehren",
      btn_cache_reset: "Cache Reset",
      btn_defaults: "Standard",
      btn_cancel: "Abbrechen",
      btn_save: "Speichern",
      cfg_tab_general: "Allgemein",
      cfg_tab_display: "Anzeige",
          cfg_tab_xp: "XP Score",
          cfg_tab_cache: "Cache",
      cfg_general_title: "Allgemeine Konfiguration",
      cfg_airport: "Airport (ICAO)",
      cfg_interval: "Refresh Rate (Sek.)",
      cfg_language: "Sprache",
      cfg_xp_hydrate: "Max XP Hydrate / Cycle",
      cfg_filter: "Filter & Darstellung",
      cfg_prefiles: "Prefiles anzeigen",
      cfg_hide_arr: "Ankünfte: Gelandete ausblenden",
      cfg_hide_dep: "Abflüge: Gelandete ausblenden",
      cfg_display_title: "Anzeige",
      cfg_display_help: "Spalten ein-/ausblenden und Reihenfolge anpassen (wirkt nach „Speichern“).",
      cfg_display_dep: "Departures Board",
      cfg_display_arr: "Arrivals Board",
      cfg_cache_title: "Cache Status",
      cfg_cache_quota: "Max. Speicher (Browser)",
      cfg_cache_usage_total: "Belegt (gesamt)",
      cfg_cache_usage_app: "Belegt (VATSIM FIDS)",
      cfg_cache_member_entries: "Member-Cache Einträge",
      cfg_cache_breakdown: "Größte Cache-Blöcke",
      cfg_cache_refresh: "Aktualisieren",
      cfg_cache_hint_pct: "{pct}% des Speicherlimits belegt (VATSIM FIDS Cache).",
      cfg_cache_hint_noquota: "Browser-Quota nicht verfügbar. Anzeige basiert auf LocalStorage.",
      cfg_xp_title: "XP Score (0-100)",
      cfg_age_bonus_label: "Registration/Age-Bonus",
      cfg_age_bonus_text: "Registration/Age-Bonus aktivieren (zusätzlicher API Abruf)",
      cfg_age_bonus_hint: "Wenn aus, wird das Registrierungsdatum nicht via API geladen (schont Rate Limit).",
      cfg_t1: "T1 (Neu)",
      cfg_t2: "T2 (Start)",
      cfg_t3: "T3 (Fortg.)",
      cfg_t4: "T4 (Erf.)",
      pilot_modal_title: "Pilot Analyse",
      pilot_card_flight: "Flight Data",
      pilot_card_stats: "Pilot Stats & Heuristic",
      pilot_card_breakdown: "XP Breakdown",
      pilot_card_history: "History (On Demand)",
      history_note: "Daten werden live von der VATSIM API geladen um das Ratenlimit zu schonen.",
      kv_callsign: "Callsign",
      kv_cid: "CID",
      kv_name: "Name",
      kv_route: "Route",
      kv_type: "Type",
      kv_std: "STD (deptime)",
      kv_eet: "EET",
      kv_eta: "ETA (heur.)",
      kv_status: "Status",
      kv_last_updated: "Last Updated",
      kv_experience: "Experience",
      kv_registered: "Registriert",
      kv_pilot_hours: "Pilot hours",
      kv_atc_hours: "ATC hours",
      kv_atc_weighted: "ATC weighted",
      kv_region_div: "Region/Division",
      kv_sessions_ret: "Sessions (returned)",
      kv_sessions_count: "Sessions (count)",
      kv_last_end: "Letzte beendete Session",
      kv_note: "Hinweis",
      history_unavailable: "Nicht verfügbar (404/Hidden).",
      history_error: "Konnte nicht geladen werden (Rate Limit / API Fehler).",
      history_note_kv: "History zeigt vergangene Sessions; aktuelle Session steht im Live-Feed.",
      xp_na: "N/A",
      xp_loading: "Pilot-Experience lädt…",
      xp_missing_tip: "Daten nicht verfügbar (404/Hidden).",
      xp_missing_reasons_1: "Daten nicht verfügbar (API 404/Hidden).",
      xp_missing_reasons_2: "Erneuter Versuch in einigen Minuten.",
      xp_reason_pilot: "Pilot-Zeit: {h} (Faktor {f}).",
      xp_reason_atc: "ATC-Zeit: {h} (Bonusfaktor {f}).",
      xp_reason_reg: "Registriert seit: {d}.",
          xp_reason_reg_disabled: "Registrierungs-/Age-Bonus deaktiviert.",
      xp_reason_reg_missing: "Registrierungsdatum nicht verfügbar.",
      tooltip_header: "CID: {cid} · Score: {score} · {label}",
      tooltip_reg: "Reg: {d}",
          tooltip_reg_off: "Reg: aus",
      tooltip_hours: "Pilot: {p} · ATC: {a}",
      legend_title: "Pilot XP",
      legend_note_age_on: "Heuristik: Reg.-Datum + Pilot/ATC-Stunden (ATC & Ratings höher gewichtet).",
      legend_note_age_off: "Heuristik: Pilot/ATC-Stunden (ATC & Ratings höher gewichtet).",
      confirm_cache_reset: "Lokalen Member-Cache wirklich löschen?",
      xp_index_title: "Airport Pilot XP Index ({board})\nMittelwert der geladenen XP Scores der angezeigten Flüge.\nLoaded: {loaded}/{total}",
      status_gate: "AM GATE / TAXI",
      status_departing: "ABFLUG",
      status_climb: "STEIGFLUG",
      status_cruise: "EN ROUTE",
      status_descent: "SINKFLUG",
      status_approach: "ANFLUG",
      status_final: "FINAL",
      status_goaround: "DURCHSTART",
      status_deparea: "ABFLUGBEREICH",
      status_prefile: "PREFILE",
      status_landed: "GELANDET",
      status_landed_dest: "GELANDET (ZIEL)",
      status_diverted_at: "AUSGEWICHEN @ {icao}",
      status_on_ground_at: "AM BODEN @ {icao}",
      status_on_ground_unknown: "AM BODEN (UNBEKANNT)",
          status_gate_named: "AM GATE {gate}",
          status_landed_gate: "GELANDET (GATE {gate})",
          status_taxi: "TAXI",
      status_gate_plain: "AM GATE",
      status_gate_named_at: "AM GATE {gate} @{icao}",
          status_gate_plain_at: "AM GATE @{icao}",
          status_takeoff: "TAKEOFF",
          status_lineup: "LINEUP",
          status_lineup_rwy: "LINEUP RWY {rwy}",
          status_local: "LOCAL",

    },
    en: {
      brand_sub: "V0.8a",
      airport_label: "Airports (Tabs)",
      cfg_title: "Settings",
      refresh_title: "Refresh now",
      config_title: "Settings",
      dep_title: "Departures",
      arr_title: "Arrivals",
      sort_hint: "Sort:",
      sort_status: "Status (Smart)",
      sort_time_std: "STD/ETA (Time)",
      sort_time_eta: "ETA (Heur.)",
      sort_callsign: "Callsign",
      sort_dest: "Destination",
      sort_orig: "Origin",
      sort_xp: "Pilot XP",
      th_time_std: "STD/ETA",
      th_time_eta: "ETA",
      th_to: "To",
      th_from: "From",
      th_callsign: "Callsign",
      th_type_route: "Type / Route",
      th_alt_gs: "Alt/GS",
      th_status: "Status",
      th_xp: "XP",
      utc_title: "Time in UTC",
      feed_title: "VATSIM datafeed status",
      api_title: "Core API Queue / Rate Limit",
      dep_dir_title: "Toggle sort direction",
      arr_dir_title: "Toggle sort direction",
      btn_cache_reset: "Cache Reset",
      btn_defaults: "Defaults",
      btn_cancel: "Cancel",
      btn_save: "Save",
      cfg_tab_general: "General",
      cfg_tab_display: "Display",
      cfg_tab_xp: "XP Score",
          cfg_tab_cache: "Cache",
      cfg_general_title: "General Configuration",
      cfg_airport: "Airport (ICAO)",
      cfg_interval: "Refresh rate (sec.)",
      cfg_language: "Language",
      cfg_xp_hydrate: "Max XP hydrate / cycle",
      cfg_filter: "Filters & View",
      cfg_prefiles: "Show prefiles",
      cfg_hide_arr: "Arrivals: Hide landed",
      cfg_hide_dep: "Departures: Hide landed",
      cfg_display_title: "Display",
      cfg_display_help: "Toggle columns and adjust order (applies after “Save”).",
      cfg_display_dep: "Departures Board",
      cfg_display_arr: "Arrivals Board",
      cfg_cache_title: "Cache Status",
      cfg_cache_quota: "Max storage (browser)",
      cfg_cache_usage_total: "Used (total)",
      cfg_cache_usage_app: "Used (VATSIM FIDS)",
      cfg_cache_member_entries: "Member cache entries",
      cfg_cache_breakdown: "Largest cache blocks",
      cfg_cache_refresh: "Refresh",
      cfg_cache_hint_pct: "{pct}% of storage limit used (VATSIM FIDS cache).",
      cfg_cache_hint_noquota: "Browser quota not available. Display based on localStorage.",
      cfg_xp_title: "XP Score (0-100)",
      cfg_age_bonus_label: "Registration/Age bonus",
      cfg_age_bonus_text: "Enable registration/age bonus (extra API fetch)",
      cfg_age_bonus_hint: "When off, registration date is not fetched from the API (preserves rate limits).",
      cfg_t1: "T1 (New)",
      cfg_t2: "T2 (Starter)",
      cfg_t3: "T3 (Advanced)",
      cfg_t4: "T4 (Experienced)",
      pilot_modal_title: "Pilot Analysis",
      pilot_card_flight: "Flight Data",
      pilot_card_stats: "Pilot Stats & Heuristic",
      pilot_card_breakdown: "XP Breakdown",
      pilot_card_history: "History (On Demand)",
      history_note: "Data is fetched live from the VATSIM API to preserve rate limits.",
      kv_callsign: "Callsign",
      kv_cid: "CID",
      kv_name: "Name",
      kv_route: "Route",
      kv_type: "Type",
      kv_std: "STD (deptime)",
      kv_eet: "EET",
      kv_eta: "ETA (heur.)",
      kv_status: "Status",
      kv_last_updated: "Last Updated",
      kv_experience: "Experience",
      kv_registered: "Registered",
      kv_pilot_hours: "Pilot hours",
      kv_atc_hours: "ATC hours",
      kv_atc_weighted: "ATC weighted",
      kv_region_div: "Region/Division",
      kv_sessions_ret: "Sessions (returned)",
      kv_sessions_count: "Sessions (count)",
      kv_last_end: "Last finished session",
      kv_note: "Note",
      history_unavailable: "Unavailable (404/Hidden).",
      history_error: "Could not load (rate limit / API error).",
      history_note_kv: "History shows past sessions; current session is in the live feed.",
      xp_na: "N/A",
      xp_loading: "Loading pilot experience…",
      xp_missing_tip: "Data not available (404/Hidden).",
      xp_missing_reasons_1: "Data not available (API 404/Hidden).",
      xp_missing_reasons_2: "Will retry in a few minutes.",
      xp_reason_pilot: "Pilot time: {h} (factor {f}).",
      xp_reason_atc: "ATC time: {h} (bonus factor {f}).",
      xp_reason_reg: "Registered since: {d}.",
          xp_reason_reg_disabled: "Registration/age bonus disabled.",
      xp_reason_reg_missing: "Registration date not available.",
      tooltip_header: "CID: {cid} · Score: {score} · {label}",
      tooltip_reg: "Reg: {d}",
          tooltip_reg_off: "Reg: off",
      tooltip_hours: "Pilot: {p} · ATC: {a}",
      legend_title: "Pilot XP",
      legend_note_age_on: "Heuristic: reg date + pilot/ATC hours (ATC & ratings weighted higher).",
      legend_note_age_off: "Heuristic: pilot/ATC hours (ATC & ratings weighted higher).",
      confirm_cache_reset: "Delete local member cache?",
      xp_index_title: "Airport Pilot XP Index ({board})\nAverage of loaded XP scores of the visible flights.\nLoaded: {loaded}/{total}",
      status_gate: "AT GATE / TAXI",
      status_departing: "DEPARTING",
      status_climb: "CLIMB",
      status_cruise: "EN ROUTE",
      status_descent: "DESCENT",
      status_approach: "APPROACH",
      status_final: "FINAL",
      status_goaround: "GO-AROUND",
      status_deparea: "DEPARTURE AREA",
      status_prefile: "PREFILE",
      status_landed: "LANDED",
      status_landed_dest: "LANDED (DEST)",
      status_diverted_at: "DIVERTED @ {icao}",
      status_on_ground_at: "ON GROUND @ {icao}",
      status_on_ground_unknown: "ON GROUND (UNKNOWN)",
          status_gate_named: "AT GATE {gate}",
      status_landed_gate: "LANDED (GATE {gate})",
          status_taxi: "TAXI",
      status_gate_plain: "AT GATE",
      status_gate_named_at: "AT GATE {gate} @{icao}",
          status_gate_plain_at: "AT GATE @{icao}",
          status_takeoff: "TAKEOFF",
          status_lineup: "LINEUP",
          status_lineup_rwy: "LINEUP RWY {rwy}",
          status_local: "LOCAL",
    }
  };

  function lang(){ return (settings?.language === "en") ? "en" : "de"; }
  function t(key, vars){
    const d = I18N[lang()] || I18N.de;
    let s = (d[key] ?? I18N.de[key] ?? key);
    if(vars){
      for(const [k,v] of Object.entries(vars)){
        const vv = (v === true || v === false) ? "" : v;
        s = s.split(`{${k}}`).join(String(vv));
      }
    }
    return s;
  }

  /********************
   * Persistenz
   ********************/
  const SETTINGS_KEY = "vatsimFids_settings_v4";
  const MEMBER_CACHE_KEY = "vatsimFids_memberCache_v2";
  const API_LAST_REQ_KEY = "vatsimFids_apiLastReqMs_v1";
  const OVERPASS_LAST_REQ_KEY = "vatsimFids_overpassLastReqMs_v1";
  const MEMBER_404_TTL_MS = 5 * 60 * 1000;

const GATE_CACHE_KEY = "vatsimFids_gateCache_v1";
const GATE_CACHE_TTL_MS = 7 * 24 * 3600 * 1000; // 7 Tage

const GATE_FLIGHT_CACHE_KEY = "vatsimFids_gateFlightCache_v1";
const GATE_FLIGHT_TTL_MS = 6 * 60 * 60 * 1000; // 6h: reicht für Reload/kurze Sessions

// Taxiway Cache (optional / size-guarded)
const TAXIWAY_CACHE_KEY = "vatsimFids_taxiwayCache_v1";
const TAXIWAY_CACHE_TTL_MS = 7 * 24 * 3600 * 1000; // 7 Tage
const TAXIWAY_MAX_CACHE_CHARS = 2_500_000; // ~1.2MB guard for localStorage
const HOTZONE_CACHE_KEY = "vatsimFids_hotZoneCache_v1"; // New HotZones
const HOTZONE_CACHE_TTL_MS = 7 * 24 * 3600 * 1000;
const TAXI_TIMES_CACHE_KEY = "vatsimFids_taxiTimes_v1"; // Historical Taxi Times
const TAXI_TIMES_TTL_MS = 6 * 60 * 60 * 1000; // 6 Hours retention
const ETD_PERSIST_KEY = "vatsimFids_etdCache_v1"; // Live ETD snapshots
const ETD_PERSIST_TTL_MS = 3 * 60 * 60 * 1000; // Keep for 3h (survives reload)
const FLIGHT_STATE_KEY = "vatsimFids_flightState_v1"; // Taxi/Lineup/Takeoff Memory
const FLIGHT_STATE_TTL_MS = 30 * 60 * 1000; // Keep short term state (30m)

// Runway (Threshold) Cache + ETD / Queue model
const RUNWAY_CACHE_KEY = "vatsimFids_runwayCache_v1";
const RUNWAY_CACHE_TTL_MS = 7 * 24 * 3600 * 1000; // 7 Tage

// ETD parameters (new runway-threshold based model)
const ETD_TAXI_SPEED_AVG_KTS = 17;        // ~8.75 m/s (15-20kts typical taxi)
const ETD_TAXI_SPEED_MIN_KTS = 6;         // ignore very low crawl
const ETD_TAXI_SPEED_MAX_KTS = 30;        // ignore very high on-ground anomalies
const ETD_LINEUP_BUFFER_SEC = 60;         // baseline buffer (dynamic tuning below)
const ETD_TAKEOFF_ROLL_SEC  = 25;         // takeoff roll after line-up (very rough)
const ETD_MIN_AHEAD_SEC     = 20;         // allow near-term takeoffs (prevents forced +1..2min)

// Intersection / runway-axis heuristics
const ETD_INTERSECTION_LATERAL_MAX_M = 220;   // close to runway axis -> intersection plausible
const ETD_AXIS_PATH_MAX_LATERAL_M    = 450;   // enable axis-distance approx within this offset
const ETD_ENTRY_CLUSTER_M            = 150;   // cluster "entry points" along runway axis
const ETD_ENTRY_MODE_CONFIRM_MS      = 10 * 1000;
const ETD_ENTRY_MODE_STICKY_MS       = 2 * 60 * 1000;

// Fast detection: aircraft rolling onto / on runway via intersection (fixes ETD showing minutes while already on RWY)
const ETD_ON_RUNWAY_AXIS_M       = 40;   // ~runway half-width (very close to centerline)
const ETD_ON_RUNWAY_AXIS_STRICT_M = 26;  // stricter "on-runway surface" check (reduces false positives on parallel taxiways)
const ETD_ON_RUNWAY_ALIGN_DEG    = 35;   // track/heading must align with runway axis (looser -> earlier detection)
const ETD_ON_RUNWAY_GS_MIN_KTS   = 8;    // "rolling" threshold for on-runway roll
const ETD_ON_RUNWAY_MERGE_GAIN_M = 12;   // lateral shrink vs prev sample => likely turning onto runway (earlier)

// Runway target selection hysteresis
const RUNWAY_TARGET_CONFIRM_MS = 8 * 1000;
const RUNWAY_TARGET_STICKY_MS  = 2 * 60 * 1000;
const RUNWAY_APPROACH_MIN_GAIN_M = 6;     // distance must shrink by >= 6m vs previous sample
const RUNWAY_TARGET_MAX_CONSIDER_M = 9000; // ignore endpoints extremely far away

// Departure queue detection near threshold
const DEP_QUEUE_STOP_GS_KTS = 1.5;        // “standing” for queue purposes
const DEP_QUEUE_MIN_AIRCRAFT = 2;
const DEP_QUEUE_MAX_DIST_M = 2600;        // allow intersections, but exclude far apron/gates
const DEP_QUEUE_PER_ACFT_SEC = 75;        // add ~1:15 per aircraft ahead (rough)

const OVERPASS_API = "https://overpass-api.de/api/interpreter";

// OSM Query / Matching
const OSM_GATE_QUERY_RADIUS_M = 6500;      // um Airport-Referenzpunkt
const GATE_MATCH_RADIUS_M = 40;            // max Distanz Gate <-> Flugposition

// Stationary / Taxi-Erkennung
const STATIONARY_WINDOW_MS = 60 * 1000;    // Sliding window
const STATIONARY_MIN_MS = 25 * 1000;       // "steht" erst nach mind. 25s
const STATIONARY_MAX_MOVE_M = 18;          // innerhalb Window max. 18m Bewegung
const STATIONARY_MAX_GS_KTS = 4;           // und GS <= 4kts
const TAXI_HIDE_GS_KTS = 8;                // sofort als "rolling" werten

// Schnellere Bewegungserkennung (Pushback/Taxi)
const RECENT_MOVE_WINDOW_MS = 12 * 1000;
const RECENT_MOVE_MAX_M = 12;

// Taxiway-based Taxi Status (Overpass aeroway=taxiway) + Fallback/Hysteresis
const TAXIWAY_QUERY_RADIUS_M = OSM_GATE_QUERY_RADIUS_M; // same airport-ref radius
const TAXIWAY_MATCH_RADIUS_M = 22;        // "strict" on-taxiway match
const TAXIWAY_FALLBACK_RADIUS_M = 55;     // tolerate scenery offset / coarse geometry
const TAXIWAY_CONFIRM_MS = 15 * 1000;     // needs time on/near taxiway while moving
const TAXI_MOVING_FALLBACK_CONFIRM_MS = 35 * 1000; // moving-on-ground w/o taxiway match
const TAXI_STICKY_MS = 90 * 1000;         // once taxi, keep for short misses
const TAXIWAY_MIN_MOVING_KTS = 3.5;       // moving threshold (below this considered stopped)
const HOTZONE_DIST_M = 70;                 // Max distance to LineupSegment to be considered "inside"

// Departures: keep TAXI stable for rolling + stop-and-go until takeoff
// - any "rolling" GS should show TAXI (even if gate label still sticky)
// - once taxiing started, latch TAXI for long queues / hold-short stops
// - release latch only if parked/stationary at a gate for a while
const DEP_TAXI_ROLLING_GS_KTS = 3.5;       // start showing TAXI on any meaningful ground roll
const DEP_TAXI_LATCH_MS = 15 * 60 * 1000;  // keep TAXI through long queues (20 min after last movement)
const DEP_TAXI_GATE_RESET_MS = 90 * 1000;  // if stationary at a gate for 90s -> treat as "at gate"

// Optional Takeoff/T/O Roll status (derived from taxi history)
const TAKEOFF_TAXI_MIN_MS = 45 * 1000;         // must have been taxiing for a while
const TAKEOFF_FROM_TAXI_GRACE_MS = 2 * 60 * 1000; // last taxi seen window
const TAKEOFF_GS_KTS = 55;                     // fast ground roll / lift-off hint
const TAKEOFF_MAX_AGL_FT = 1400;               // still close to ground shortly after lift-off

// Keep TAKEOFF visible briefly to avoid TAXI -> DEPARTING skip due to noisy samples.
const TAKEOFF_HOLD_MS = 55 * 1000;
const TAKEOFF_MEM_TTL_MS = 20 * 60 * 1000;

// Lineup detection (runway centerline + aligned + slow/stopped)
const LINEUP_ON_AXIS_M   = 32;          // slightly stricter to avoid parallel-taxiway false positives
const LINEUP_GS_MAX_KTS  = 24;          // reduce false LINEUP while still taxiing fast on near-parallel segments
const LINEUP_HOLD_MS     = 60 * 1000;   // don't keep lineup too long (avoids showing it late)
const LINEUP_MEM_TTL_MS  = 20 * 60 * 1000;

// Local (dep==arr==focus) handling: prevent "LANDED" immediately when parked at the same airport.
const LOCAL_FLIGHT_TTL_MS = 6 * 60 * 60 * 1000;

// Smoothing / Hysterese Gate-Label
const GATE_CONFIRM_MS = 15 * 1000;         // Kandidat muss 20s stabil sein
const GATE_STICKY_MS = 2 * 60 * 1000;      // einmal erkannt bleibt 2min sticky
const GATE_LOST_GRACE_MS = 60 * 1000;      // kurzzeitig "kein Kandidat" -> Gate behalten
const GATE_JITTER_GRACE_MS = 20 * 1000;    // kurzzeitig minimal bewegt -> Gate behalten

  const BOARD_COL_KEYS = ["time","callsign","ap","typeRoute","altgs","status","xp"];

  /********************
   * MySQL Database Sync
   ********************/
  async function dbSave(key, value) {
    if (!DB_CONFIG.enabled) return;
    try {
      const r = await fetch(`${DB_CONFIG.apiUrl}?action=set`, {
        method: 'POST',
        body: JSON.stringify({ key, value })
      });
      return r.ok;
    } catch (e) {
      console.error("DB Save failed", e);
      return false;
    }
  }

  async function dbLoad(key) {
    if (!DB_CONFIG.enabled) return null;
    try {
      const r = await fetch(`${DB_CONFIG.apiUrl}?action=get&key=${encodeURIComponent(key)}`);
      return await r.json();
    } catch (e) { return null; }
  }

  // Helper um LocalStorage sauber zu halten, wenn DB aktiv ist
  function pruneLocalIfDbActive(key) {
    if (DB_CONFIG.enabled) {
        try { localStorage.removeItem(key); } catch(e){}
    }
  }

  const DEFAULTS = {
    airports: ["EDDB"], // Default: just one airport
    activeTab: "EDDB",
    feedIntervalMs: 15000,
    showPrefiles: false,
    hideArrivalsLanded: false,
    hideDeparturesFinished: false,
    depSort: { by:"status", dir: 1 },
    arrSort: { by:"status", dir: 1 },
    memberTtlStatsMs: 5 * 24 * 3600 * 1000,
    memberTtlDetailsMs: 30 * 24 * 3600 * 1000,
    xpThresholds: { t1:20, t2:45, t3:65, t4:85 },
        xpAgeBonusEnabled: false, // Registration/Age-Bonus (DEFAULT: OFF)
    language: "de",
    boardLayout: {
      dep: { order: [...BOARD_COL_KEYS], visible: { time:true, callsign:true, ap:true, typeRoute:true, altgs:true, status:true, xp:true } },
      arr: { order: [...BOARD_COL_KEYS], visible: { time:true, callsign:true, ap:true, typeRoute:true, altgs:true, status:true, xp:true } }
    }
  };

  function clampInt(x, lo, hi){
    const n = Number(x);
    if(!isFinite(n)) return lo;
    return Math.max(lo, Math.min(hi, Math.round(n)));
  }

  function normalizeLayout(input, boardType){
    const def = structuredClone(DEFAULTS.boardLayout[boardType]);
    const src = (input && typeof input === "object") ? input : {};
    const visible = { ...def.visible, ...(src.visible || {}) };

    let order = Array.isArray(src.order) ? src.order.map(String) : def.order.slice();
    const seen = new Set();
    order = order.filter(k => BOARD_COL_KEYS.includes(k) && !seen.has(k) && (seen.add(k), true));
    for(const k of def.order){ if(!seen.has(k)) order.push(k); }
    return { order, visible };
  }

  function loadSettings(){
    try{
      const raw = localStorage.getItem(SETTINGS_KEY);
      if(!raw) return structuredClone(DEFAULTS);
      const s = JSON.parse(raw);
      // Migration from old single airport string to array
      if(s.airportInput && !s.airports){
         s.airports = [s.airportInput];
         delete s.airportInput;
      }
      const merged = { ...structuredClone(DEFAULTS), ...s };
      // Ensure airports is array
      if(!Array.isArray(merged.airports) || merged.airports.length === 0) merged.airports = [...DEFAULTS.airports];
      // Ensure activeTab is valid string
      if(typeof merged.activeTab !== "string") merged.activeTab = merged.airports[0];
      merged.depSort = { ...DEFAULTS.depSort, ...(s.depSort||{}) };
      merged.arrSort = { ...DEFAULTS.arrSort, ...(s.arrSort||{}) };
      merged.xpThresholds = { ...DEFAULTS.xpThresholds, ...(s.xpThresholds||{}) };
      merged.xpAgeBonusEnabled = !!s.xpAgeBonusEnabled;
          merged.language = (s.language === "en") ? "en" : "de";
      merged.boardLayout = {
        dep: normalizeLayout(s.boardLayout?.dep, "dep"),
        arr: normalizeLayout(s.boardLayout?.arr, "arr")
      };
      return merged;
    }catch{
      return structuredClone(DEFAULTS);
    }
  }
  function saveSettings(){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); }

  async function loadMemberCache(){
    let local = {};
    try { local = JSON.parse(localStorage.getItem(MEMBER_CACHE_KEY) || "{}"); } catch(e){}

    if (DB_CONFIG.enabled) {
      const remote = await dbLoad(MEMBER_CACHE_KEY);
      if (remote) {
        pruneLocalIfDbActive(MEMBER_CACHE_KEY); // Clean local if we have remote
        // Merge: Remote (Shared) gewinnt bei neuerem Timestamp
        return { ...local, ...remote };
      }
    }
    return local;
  }
  // Helper: Aggressive Pruning bei Quota-Limit
  function handleQuotaError(e, cacheObj, cacheKey) {
    if (e && (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {
      console.warn(`Quota exceeded saving ${cacheKey}. Pruning old data...`);

      // 1. Notfall-Bereinigung: Lösche große, wiederherstellbare Geometrie-Caches um Platz zu schaffen
      try { localStorage.removeItem(TAXIWAY_CACHE_KEY); } catch(e){}
      try { localStorage.removeItem(RUNWAY_CACHE_KEY); } catch(e){}

      // 2. Aggressives Trimmen des aktuellen Caches (älteste 40% löschen)
      if (cacheObj) {
        const entries = Object.entries(cacheObj);
        // Sortiere nach Zeitstempel (alt zuerst). Annahme: Objekte haben .t oder .ts
        entries.sort((a,b) => ((a[1].t || a[1].ts || 0) - (b[1].t || b[1].ts || 0)));
        const cutCount = Math.ceil(entries.length * 0.4);
        for(let i=0; i < cutCount; i++) {
           delete cacheObj[entries[i][0]];
        }
        return true; // Retry empfohlen
      }
    }
    return false;
  }
  function saveMemberCache(){
    const entries = Object.entries(memberCache);
    // Soft Limit (Normalbetrieb)
    if(entries.length > 900){
      entries.sort((a,b) => (a[1].t || 0) - (b[1].t || 0));
      for(let i=0;i<entries.length-900;i++) delete memberCache[entries[i][0]];
    }

    try {
      if (DB_CONFIG.enabled) {
         // Fire & Forget DB save, then clean local
         dbSave(MEMBER_CACHE_KEY, memberCache).then(ok => { if(ok) pruneLocalIfDbActive(MEMBER_CACHE_KEY); });
      } else {
         localStorage.setItem(MEMBER_CACHE_KEY, JSON.stringify(memberCache));
      }
    } catch(e) {
      // Bei Fehler: Aggressiv bereinigen und retry
      if(handleQuotaError(e, memberCache, MEMBER_CACHE_KEY)) {
         try { if(!DB_CONFIG.enabled) localStorage.setItem(MEMBER_CACHE_KEY, JSON.stringify(memberCache)); } catch(e2){}
      }
    }
  }

  let settings = loadSettings();
  let memberCache = {}; // Initial leer, wird in boot() geladen

  /********************
   * UI Hooks
   ********************/
  const brandSubEl = document.getElementById("brandSub");
  const airportInputLabelEl = document.getElementById("airportInputLabel");
  const utcPill = document.getElementById("utcPill");
  const feedPill = document.getElementById("feedPill");
  const apiPill = document.getElementById("apiPill");

  const airportTabsContainer = document.getElementById("airportTabs");
  const refreshBtn = document.getElementById("refreshBtn");
  const fullscreenBtn = document.getElementById("fullscreenBtn");
  const configBtn = document.getElementById("configBtn");
  const utcClockEl = document.getElementById("utcClock");

  const feedDot = document.getElementById("feedDot");
  const feedText = document.getElementById("feedText");
  const feedAge = document.getElementById("feedAge");

  const apiDot = document.getElementById("apiDot");
  const apiText = document.getElementById("apiText");
  const apiExtra = document.getElementById("apiExtra");

  const depTitleEl = document.getElementById("depTitle");
  const arrTitleEl = document.getElementById("arrTitle");
  const depSortHintEl = document.getElementById("depSortHint");
  const arrSortHintEl = document.getElementById("arrSortHint");

  const depHeadRow = document.getElementById("depHeadRow");
  const arrHeadRow = document.getElementById("arrHeadRow");

  const depBody = document.getElementById("depBody");
  const arrBody = document.getElementById("arrBody");
  const depSortEl = document.getElementById("depSort");
  const depDirBtn = document.getElementById("depDir");
  const arrSortEl = document.getElementById("arrSort");
  const arrDirBtn = document.getElementById("arrDir");

  const tooltip = document.getElementById("tooltip");
  const legendContent = document.getElementById("legendContent");

  // Pilot Modal
  const pilotModalOverlay = document.getElementById("pilotModalOverlay");
  const pilotModalClose = document.getElementById("pilotModalClose");
  const pilotModalTitle = document.getElementById("pilotModalTitle");
  const pilotModalSubtitle = document.getElementById("pilotModalSubtitle");
  const flightKv = document.getElementById("flightKv");
  const xpKv = document.getElementById("xpKv");
  const xpList = document.getElementById("xpList");
  const xpLinks = document.getElementById("xpLinks");
  const historyKv = document.getElementById("historyKv");

  const pilotCardFlightData = document.getElementById("pilotCardFlightData");
  const pilotCardStats = document.getElementById("pilotCardStats");
  const pilotCardBreakdown = document.getElementById("pilotCardBreakdown");
  const pilotCardHistory = document.getElementById("pilotCardHistory");
  const historyNote = document.getElementById("historyNote");

  // Config Modal
  const configModalOverlay = document.getElementById("configModalOverlay");
  const configClose = document.getElementById("configClose");
  const cfgAirport1 = document.getElementById("cfgAirport1");
  const cfgAirport2 = document.getElementById("cfgAirport2");
  const cfgAirport3 = document.getElementById("cfgAirport3");
  const cfgInterval = document.getElementById("cfgInterval");
  const cfgLanguage = document.getElementById("cfgLanguage");
  const cfgPrefiles = document.getElementById("cfgPrefiles");
  const cfgHideArrLanded = document.getElementById("cfgHideArrLanded");
  const cfgHideDepFinished = document.getElementById("cfgHideDepFinished");
  const cfgT1 = document.getElementById("cfgT1");
  const cfgT2 = document.getElementById("cfgT2");
  const cfgT3 = document.getElementById("cfgT3");
  const cfgT4 = document.getElementById("cfgT4");
  const cfgDefaults = document.getElementById("cfgDefaults");
  const cfgCancel = document.getElementById("cfgCancel");
  const cfgSave = document.getElementById("cfgSave");
  const cfgResetCache = document.getElementById("cfgResetCache");
  const cfgTabCache = document.getElementById("cfgTabCache");
  const cfgCacheTitle = document.getElementById("cfgCacheTitle");
  const cfgCacheKv = document.getElementById("cfgCacheKv");
  const cfgCacheBarFill = document.getElementById("cfgCacheBarFill");
  const cfgCacheBreakdownTitle = document.getElementById("cfgCacheBreakdownTitle");
  const cfgCacheBreakdown = document.getElementById("cfgCacheBreakdown");
  const cfgCacheRefresh = document.getElementById("cfgCacheRefresh");
  const cfgCacheHint = document.getElementById("cfgCacheHint");

  const cfgModalTitle = document.getElementById("cfgModalTitle");
  const cfgTabGeneral = document.getElementById("cfgTabGeneral");
  const cfgTabDisplay = document.getElementById("cfgTabDisplay");
  const cfgTabXp = document.getElementById("cfgTabXp");
  const cfgGeneralTitle = document.getElementById("cfgGeneralTitle");
  const cfgAirportLabel = document.getElementById("cfgAirportLabel");
  const cfgIntervalLabel = document.getElementById("cfgIntervalLabel");
  const cfgLanguageLabel = document.getElementById("cfgLanguageLabel");
  const cfgFilterLabel = document.getElementById("cfgFilterLabel");
  const cfgPrefilesText = document.getElementById("cfgPrefilesText");
  const cfgHideArrText = document.getElementById("cfgHideArrText");
  const cfgHideDepText = document.getElementById("cfgHideDepText");
  const cfgDisplayTitle = document.getElementById("cfgDisplayTitle");
  const cfgDisplayHelp = document.getElementById("cfgDisplayHelp");
  const cfgDisplayDepTitle = document.getElementById("cfgDisplayDepTitle");
  const cfgDisplayArrTitle = document.getElementById("cfgDisplayArrTitle");
  const cfgXpTitle = document.getElementById("cfgXpTitle");
  const cfgT1Label = document.getElementById("cfgT1Label");
  const cfgT2Label = document.getElementById("cfgT2Label");
  const cfgT3Label = document.getElementById("cfgT3Label");
  const cfgT4Label = document.getElementById("cfgT4Label");
  const cfgAgeBonus = document.getElementById("cfgAgeBonus");
  const cfgAgeBonusLabel = document.getElementById("cfgAgeBonusLabel");
  const cfgAgeBonusText = document.getElementById("cfgAgeBonusText");
  const cfgAgeBonusHint = document.getElementById("cfgAgeBonusHint");

  const cfgDepCols = document.getElementById("cfgDepCols");
  const cfgArrCols = document.getElementById("cfgArrCols");

  /********************
   * Config Modal Tabs
   ********************/
  function setActiveCfgTab(tab){
    for(const b of configModalOverlay.querySelectorAll(".tabBtn")){
      b.classList.toggle("active", b.dataset.tab === tab);
    }
    for(const p of configModalOverlay.querySelectorAll(".tabPanel")){
      p.classList.toggle("active", p.dataset.tab === tab);
    }
    if(tab === "cache"){
      // async, but safe to call without await
      updateCacheStatus();
    }
  }
  configModalOverlay.addEventListener("click", (e) => {
    const btn = e.target.closest(".tabBtn");
    if(btn) setActiveCfgTab(btn.dataset.tab);
  });

  /********************
   * Cache Status UI
   ********************/
  function fmtBytes(bytes){
    if(bytes == null || !isFinite(bytes)) return "—";
    let b = Math.max(0, Number(bytes));
    const u = ["B","KB","MB","GB"];
    let i = 0;
    while(b >= 1024 && i < u.length-1){ b /= 1024; i++; }
    const d = (i === 0) ? 0 : (b < 10 ? 2 : (b < 100 ? 1 : 0));
    return `${b.toFixed(d)} ${u[i]}`;
  }
  function estimateAppLocalStorageBytes(prefix="vatsimFids_"){
    let total = 0;
    const items = [];
    for(let i=0; i<localStorage.length; i++){
      const k = localStorage.key(i);
      if(!k) continue;
      if(prefix && !k.startsWith(prefix)) continue;
      const v = localStorage.getItem(k) || "";
      // Approximation: UTF-16 chars -> ~2 bytes per char
      const bytes = (k.length + v.length) * 2;
      total += bytes;
      items.push({ key:k, bytes });
    }
    items.sort((a,b) => b.bytes - a.bytes);
    return { total, items };
  }
  function renderKv(el, pairs){
    el.innerHTML = "";
    for(const [k,v] of pairs){
      const dk = document.createElement("div");
      dk.className = "k";
      dk.textContent = k;
      const dv = document.createElement("div");
      dv.className = "v";
      dv.textContent = v;
      el.appendChild(dk);
      el.appendChild(dv);
    }
  }
  async function updateCacheStatus(){
    if(!cfgCacheKv || !cfgCacheBarFill || !cfgCacheBreakdown) return;

    const app = estimateAppLocalStorageBytes("vatsimFids_");
    let quota = null, usage = null;
    if(navigator.storage && navigator.storage.estimate){
      try{
        const est = await navigator.storage.estimate();
        quota = est?.quota ?? null;
        usage = est?.usage ?? null;
      }catch{}
    }

    renderKv(cfgCacheKv, [
      [t("cfg_cache_quota"), quota != null ? fmtBytes(quota) : "—"],
      [t("cfg_cache_usage_total"), usage != null ? fmtBytes(usage) : "—"],
      [t("cfg_cache_usage_app"), fmtBytes(app.total)],
      [t("cfg_cache_member_entries"), String(Object.keys(memberCache || {}).length)]
    ]);

    // Add DB Status line if enabled
    if(DB_CONFIG.enabled){
         renderKv(cfgCacheKv, [["Remote Database", "Connected & Active"]]);
    }

    const denom = (quota != null && isFinite(quota) && quota > 0) ? quota : (5 * 1024 * 1024);
    const pct = denom > 0 ? Math.min(100, (app.total / denom) * 100) : 0;
    cfgCacheBarFill.style.width = `${pct.toFixed(1)}%`;

    if(cfgCacheHint){
      cfgCacheHint.textContent = (quota != null && isFinite(quota))
        ? t("cfg_cache_hint_pct", { pct: pct.toFixed(1) })
        : t("cfg_cache_hint_noquota");
    }

    if(cfgCacheBreakdownTitle) cfgCacheBreakdownTitle.textContent = t("cfg_cache_breakdown");

    cfgCacheBreakdown.innerHTML = "";
    const top = app.items.slice(0, 8);
    if(top.length === 0){
      const r = document.createElement("div");
      r.className = "cacheRow";
      r.innerHTML = `<span class="k">—</span><span class="v">${escapeHtml(fmtBytes(0))}</span>`;
      cfgCacheBreakdown.appendChild(r);
      return;
    }
    for(const it of top){
      const row = document.createElement("div");
      row.className = "cacheRow";
      const k = document.createElement("span");
      k.className = "k";
      k.textContent = it.key;
      const v = document.createElement("span");
      v.className = "v";
      v.textContent = fmtBytes(it.bytes);
      row.appendChild(k);
      row.appendChild(v);
      cfgCacheBreakdown.appendChild(row);
    }
  }

  // Manual refresh + passive refresh after potential cache reset
  if(cfgCacheRefresh){
    cfgCacheRefresh.addEventListener("click", () => updateCacheStatus());
  }
  if(cfgResetCache){
    // Nur LocalStorage Reset, niemals DB
    cfgResetCache.addEventListener("click", () => {
      if(confirm("Nur den lokalen Browser-Cache leeren? (Datenbank bleibt erhalten)")){
          localStorage.clear(); // Leert alles von dieser Domain im LS
          // Reload um Status sauber zu haben
          location.reload();
      }
    }, true);
  }

  /********************
   * Sort options build (i18n)
   ********************/
  function rebuildSortOptions(){
    const depVal = depSortEl.value || settings.depSort.by;
    const arrVal = arrSortEl.value || settings.arrSort.by;

    depSortEl.innerHTML = "";
    [
      ["status", t("sort_status")],
      ["time", t("sort_time_std")],
      ["callsign", t("sort_callsign")],
      ["dest", t("sort_dest")],
      ["xp", t("sort_xp")]
    ].forEach(([v,txt]) => {
      const o = document.createElement("option");
      o.value = v; o.textContent = txt;
      depSortEl.appendChild(o);
    });

    arrSortEl.innerHTML = "";
    [
      ["status", t("sort_status")],
      ["time", t("sort_time_eta")],
      ["callsign", t("sort_callsign")],
      ["orig", t("sort_orig")],
      ["xp", t("sort_xp")]
    ].forEach(([v,txt]) => {
      const o = document.createElement("option");
      o.value = v; o.textContent = txt;
      arrSortEl.appendChild(o);
    });

    depSortEl.value = depVal || "status";
    arrSortEl.value = arrVal || "status";
  }

  /********************
   * Board Columns (header + rendering)
   ********************/
  const COL_META = {
    time: { width:"90px", thClass:"center", tdClass:"center" },
    callsign: { width:"90px" },
    ap: { width:"70px" },
    typeRoute: { width:null, tdClass:"cell-route" },
    altgs: { width:"125px", thClass:"right", tdClass:"right" },
    status: { width:"170px" },
    xp: { width:"110px" }
  };

  function colHeaderLabel(key, boardType){
    if(key === "time") return (boardType === "dep") ? t("th_time_std") : t("th_time_eta");
    if(key === "ap") return (boardType === "dep") ? t("th_to") : t("th_from");
    if(key === "callsign") return t("th_callsign");
    if(key === "typeRoute") return t("th_type_route");
    if(key === "altgs") return t("th_alt_gs");
    if(key === "status") return t("th_status");
    if(key === "xp") return t("th_xp");
    return key;
  }

  function buildBoardHeaders(){
    buildHeaderFor("dep", depHeadRow);
    buildHeaderFor("arr", arrHeadRow);
  }

  function buildHeaderFor(boardType, rowEl){
    rowEl.innerHTML = "";
    const layout = settings.boardLayout[boardType];
    for(const key of layout.order){
      if(!layout.visible[key]) continue;
      const th = document.createElement("th");
      const meta = COL_META[key] || {};
      th.textContent = colHeaderLabel(key, boardType);
      if(meta.width) th.style.width = meta.width;
      if(meta.thClass) th.className = meta.thClass;
      rowEl.appendChild(th);
    }
  }

  /********************
   * Apply language to static UI
   ********************/
  function applyLanguage(){
    document.documentElement.lang = lang();
    brandSubEl.textContent = t("brand_sub");
    refreshBtn.title = t("refresh_title");
    configBtn.title = t("cfg_title");

    depTitleEl.textContent = `${t("dep_title")} (0)`;
    arrTitleEl.textContent = `${t("arr_title")} (0)`;
    depSortHintEl.textContent = t("sort_hint");
    arrSortHintEl.textContent = t("sort_hint");
    depDirBtn.title = t("dep_dir_title");
    arrDirBtn.title = t("arr_dir_title");

    utcPill.title = t("utc_title");
    feedPill.title = t("feed_title");
    apiPill.title = t("api_title");

    // Config texts
    cfgModalTitle.textContent = t("config_title");
    cfgTabGeneral.textContent = t("cfg_tab_general");
    cfgTabDisplay.textContent = t("cfg_tab_display");
    cfgTabXp.textContent = t("cfg_tab_xp");
        if(cfgTabCache) cfgTabCache.textContent = t("cfg_tab_cache");
    cfgGeneralTitle.textContent = t("cfg_general_title");
    if(document.getElementById("cfgAirportLabel"))
       document.getElementById("cfgAirportLabel").textContent = t("airport_label");
    cfgIntervalLabel.textContent = t("cfg_interval");
    cfgLanguageLabel.textContent = t("cfg_language");
    cfgFilterLabel.textContent = t("cfg_filter");
    cfgPrefilesText.textContent = t("cfg_prefiles");
    cfgHideArrText.textContent = t("cfg_hide_arr");
    cfgHideDepText.textContent = t("cfg_hide_dep");
    cfgDisplayTitle.textContent = t("cfg_display_title");
    cfgDisplayHelp.textContent = t("cfg_display_help");
    cfgDisplayDepTitle.textContent = t("cfg_display_dep");
    cfgDisplayArrTitle.textContent = t("cfg_display_arr");
    cfgXpTitle.textContent = t("cfg_xp_title");
    cfgAgeBonusLabel.textContent = t("cfg_age_bonus_label");
    cfgAgeBonusText.textContent = t("cfg_age_bonus_text");
    cfgAgeBonusHint.textContent = t("cfg_age_bonus_hint");
    cfgT1Label.textContent = t("cfg_t1");
    cfgT2Label.textContent = t("cfg_t2");
    cfgT3Label.textContent = t("cfg_t3");
    cfgT4Label.textContent = t("cfg_t4");

    if(cfgCacheTitle) cfgCacheTitle.textContent = t("cfg_cache_title");
    if(cfgCacheRefresh) cfgCacheRefresh.textContent = t("cfg_cache_refresh");
    if(cfgCacheBreakdownTitle) cfgCacheBreakdownTitle.textContent = t("cfg_cache_breakdown");

    cfgResetCache.textContent = t("btn_cache_reset");
    cfgDefaults.textContent = t("btn_defaults");
    cfgCancel.textContent = t("btn_cancel");
    cfgSave.textContent = t("btn_save");

    // Pilot modal headers
    pilotModalTitle.textContent = t("pilot_modal_title");
    pilotCardFlightData.textContent = t("pilot_card_flight");
    pilotCardStats.textContent = t("pilot_card_stats");
    pilotCardBreakdown.textContent = t("pilot_card_breakdown");
    pilotCardHistory.textContent = t("pilot_card_history");
    historyNote.textContent = t("history_note");

    rebuildSortOptions();
    buildBoardHeaders();
    rebuildLegend();
    scheduleAirportXpIndexUpdate();

    // Recompute XP labels/tooltips for already loaded flights
    for(const f of [...lastDeps, ...lastArrs]){
      if(f.details || f.stats){
        f.exp = computeExperience(f.details ?? null, f.stats ?? null);
        depBoard.updateXpById(f.id);
        arrBoard.updateXpById(f.id);
      }
    }
  }

  /********************
   * Airport Index
   ********************/
  const airportIndex = {
    ready:false,
    byIcao: new Map(),
    byIata: new Map(),
    grid: new Map()
  };
  function gridKey(lat, lon){ return `${Math.floor(lat)},${Math.floor(lon)}`; }
  function gridAdd(ap){
    const key = gridKey(ap.latitude, ap.longitude);
    if(!airportIndex.grid.has(key)) airportIndex.grid.set(key, []);
    airportIndex.grid.get(key).push(ap);
  }
  function normalizeCode(s){ return (s||"").trim().toUpperCase(); }

  async function ensureAirportIndex(){
    if(airportIndex.ready) return true;
    try{
      const res = await fetch(AIRPORTS_URL, { cache:"force-cache" });
      if(!res.ok) throw new Error(`airports.json HTTP ${res.status}`);
      const data = await res.json();
      for(const a of data){
        if(!a || !a.icao || !a.latitude || !a.longitude) continue;
        const icao = normalizeCode(a.icao);
        const iata = normalizeCode(a.iata);
        const ap = {
          icao,
          iata: iata || "",
          latitude: Number(a.latitude),
          longitude: Number(a.longitude),
          elevation: Number(a.altitude || 0) // feet
        };
        airportIndex.byIcao.set(icao, ap);
        if(iata && !airportIndex.byIata.has(iata)) airportIndex.byIata.set(iata, icao);
        gridAdd(ap);
      }
      airportIndex.ready = true;
      return true;
    }catch(err){
      console.warn("Airport DB load failed:", err);
      const ap1 = { icao:"EDDB", iata:"BER", latitude:52.3667, longitude:13.5033, elevation:157 };
      airportIndex.byIcao.set("EDDB", ap1);
      airportIndex.byIata.set("BER", "EDDB");
      gridAdd(ap1);

      const ap2 = { icao:"LOWI", iata:"INN", latitude:47.2603, longitude:11.3440, elevation:1906 };
      airportIndex.byIcao.set("LOWI", ap2);
      airportIndex.byIata.set("INN", "LOWI");
      gridAdd(ap2);

      airportIndex.ready = true;
      return false;
    }
  }
  function resolveAirportToIcao(code){
    const c = normalizeCode(code);
    if(c.length === 3) return airportIndex.byIata.get(c) || c;
    return c;
  }
  function getAirport(icaoOrIata){
    const icao = resolveAirportToIcao(icaoOrIata);
    return airportIndex.byIcao.get(icao) || null;
  }
  function haversineNm(lat1, lon1, lat2, lon2){
    const R_km = 6371;
    const toRad = d => d * Math.PI / 180;
    const dLat = toRad(lat2-lat1);
    const dLon = toRad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return (R_km * c) * 0.5399568;
  }

  function haversineMeters(lat1, lon1, lat2, lon2){
  const R = 6371000;
  const toRad = d => d * Math.PI / 180;
  const dLat = toRad(lat2-lat1);
  const dLon = toRad(lon2-lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}


  function findNearestAirport(lat, lon, maxNm=10){
    const latB = Math.floor(lat);
    const lonB = Math.floor(lon);
    let best = null, bestD = Infinity;
    const maxR = 4;
    for(let r=0;r<=maxR;r++){
      for(let dy=-r; dy<=r; dy++){
        for(let dx=-r; dx<=r; dx++){
          if(Math.abs(dx)!==r && Math.abs(dy)!==r) continue;
          const key = `${latB+dy},${lonB+dx}`;
          const bucket = airportIndex.grid.get(key);
          if(!bucket) continue;
          for(const ap of bucket){
            const d = haversineNm(lat, lon, ap.latitude, ap.longitude);
            if(d < bestD){ bestD = d; best = ap; }
          }
        }
      }
      if(best && bestD <= maxNm) break;
    }
    if(best && bestD <= maxNm) return { ap: best, nm: bestD };
    return null;
  }

const gatePrefetchAttempt = new Map(); // icao -> lastAttemptMs

function prefetchGateIndexesForArrOrigins(arrList){
  const focus = currentAirportIcao;
  const now = Date.now();

  const need = [];
  const seen = new Set();

  for(const f of arrList){
    // Local flights (DEP==ARR==focus) are not real inbound origins; skip prefetch noise
    const fp = f?.fp || f?.flight_plan || null;
    const dep = normalizeCode(fp?.departure || f?.dep || "");
    const arr = normalizeCode(fp?.arrival   || f?.arr || "");
    if(dep && arr && dep === focus && arr === focus) continue;
    if(f.status?.phase !== "GATE") continue;     // Arrivals: GATE = am Origin am Boden
    const icao = normalizeCode(f.dep || "");
    if(!icao || icao === focus) continue;
    if(seen.has(icao)) continue;
    seen.add(icao);

    if(gateIndexByIcao.has(icao)) continue;

    need.push(icao);
    if(need.length >= 1) break; // pro Refresh max 1 (Overpass entlasten)
  }

  for(const icao of need){
    const last = gatePrefetchAttempt.get(icao) || 0;
    if(now - last < 5*60*1000) continue; // pro Airport max alle 5min
    gatePrefetchAttempt.set(icao, now);
    ensureGateIndexForIcao(icao).catch(()=>{});
  }
}


  /********************
 * OSM Gate/Stand Resolver (Overpass + Cache + Smoothing)
 ********************/
const gateIndexByIcao = new Map();   // icao -> { ts, gates, grid }
const gateLoadPromises = new Map();  // icao -> Promise
const gateMem = new Map();           // cid -> state

async function loadGateCache(){
  let local = {};
  try { local = JSON.parse(localStorage.getItem(GATE_CACHE_KEY) || "{}"); } catch(e){}
  if (DB_CONFIG.enabled) {
    const remote = await dbLoad(GATE_CACHE_KEY);
    if (remote) {
        pruneLocalIfDbActive(GATE_CACHE_KEY);
        return { ...local, ...remote };
    }
  }
  return local;
}
function saveGateCache(obj){
  if (DB_CONFIG.enabled) {
     dbSave(GATE_CACHE_KEY, obj).then(ok => { if(ok) pruneLocalIfDbActive(GATE_CACHE_KEY); });
  } else {
     localStorage.setItem(GATE_CACHE_KEY, JSON.stringify(obj));
  }
}

async function loadGateFlightCache(){
  if (DB_CONFIG.enabled) {
    const remote = await dbLoad(GATE_FLIGHT_CACHE_KEY);
    if (remote) {
        pruneLocalIfDbActive(GATE_FLIGHT_CACHE_KEY);
        return remote;
    }
  }
  try { return JSON.parse(localStorage.getItem(GATE_FLIGHT_CACHE_KEY) || "{}"); } catch(e){ return {}; }
}
function saveGateFlightCache(obj){
try {
    // Drosselung: Nur alle 10 Sekunden in DB schreiben, um SQL-Server zu schonen
    if (DB_CONFIG.enabled && (!window._lastDbGateSave || Date.now() - window._lastDbGateSave > 10000)) {
       dbSave(GATE_FLIGHT_CACHE_KEY, obj).then(ok => { if(ok) pruneLocalIfDbActive(GATE_FLIGHT_CACHE_KEY); });
       window._lastDbGateSave = Date.now();
    } else if (!DB_CONFIG.enabled) {
       localStorage.setItem(GATE_FLIGHT_CACHE_KEY, JSON.stringify(obj));
    }
  } catch(e) {
    if(handleQuotaError(e, obj, GATE_FLIGHT_CACHE_KEY)) {
       try { localStorage.setItem(GATE_FLIGHT_CACHE_KEY, JSON.stringify(obj)); } catch(e2){}
    }
  }
}

let gateFlightCache = {}; // Wird in boot() geladen

function pruneGateFlightCache(){
  const now = Date.now();
  let changed = false;
  for(const [cid, e] of Object.entries(gateFlightCache)){
    if(!e?.ts || (now - e.ts) > GATE_FLIGHT_TTL_MS){
      delete gateFlightCache[cid];
      changed = true;
    }
  }
  if(changed) saveGateFlightCache(gateFlightCache);
}

function getGateFlightCacheHit(cid, icao, lat, lon, gsKts){
  const e = gateFlightCache[String(cid)];
  if(!e) return null;
  if(normalizeCode(e.icao) !== normalizeCode(icao)) return null;
  if(!e.ts || (Date.now() - e.ts) > GATE_FLIGHT_TTL_MS) return null;

  if(!isFinite(lat) || !isFinite(lon) || !isFinite(gsKts)) return null;

  const d = haversineMeters(lat, lon, Number(e.lat), Number(e.lon));
  if(!isFinite(d) || d > 12) return null;                 // Position praktisch identisch
  if(Math.abs(gsKts - Number(e.gs || 0)) > 2.5) return null; // GS praktisch identisch

  return e;
}

function persistGateFlightCache(cid, icao, gate, lat, lon, gsKts){
  if(!gate || !icao) return;
  cid = String(cid);
  icao = normalizeCode(icao);

  const now = Date.now();
  const mem = gateMem.get(cid);
  if(mem){
    // Throttle um LocalStorage nicht zu spammen
    if(mem._persistAt && (now - mem._persistAt) < 15000) return;
    mem._persistAt = now;
  }

  gateFlightCache[cid] = {
    icao,
    gateId: gate.id || null,
    gateLabel: gate.label || null,
    lat, lon,
    gs: Math.round(gsKts * 10) / 10,
    ts: now
  };

  // Simple size cap
  const keys = Object.keys(gateFlightCache);
  if(keys.length > 900){
    keys.sort((a,b) => (gateFlightCache[a]?.ts||0) - (gateFlightCache[b]?.ts||0));
    for(let i=0;i<keys.length-900;i++) delete gateFlightCache[keys[i]];
  }

  saveGateFlightCache(gateFlightCache);
}

function seedGateMemFromFlightCache(cid, icao, lat, lon, gsKts, idx){
  cid = String(cid);
  icao = normalizeCode(icao);

  const hit = getGateFlightCacheHit(cid, icao, lat, lon, gsKts);
  if(!hit) return;

  let m = gateMem.get(cid);
  if(m?.stable) return;

  let gateObj = null;
  if(idx?.gates && hit.gateId){
    gateObj = idx.gates.find(g => g.id === hit.gateId) || null;
  }
  if(!gateObj && hit.gateLabel){
    gateObj = {
      id: hit.gateId || `cached:${icao}:${hit.gateLabel}`,
      label: hit.gateLabel,
      lat, lon,
      kind: "cached"
    };
  }
  if(!gateObj) return;

  const now = Date.now();
  if(!m){
    m = {
      samples: [],
      stable: null,
      stableSeenAt: 0,
      pending: null,
      pendingSince: 0,
      lastSeen: 0,
      wasStationaryAt: 0,
      _persistAt: 0
    };
    gateMem.set(cid, m);
  }

  // “Sofort anzeigen” beim Reload: Stationary-Fenster synthetisch füttern (nur wenn Pos/GS matchen)
  m.stable = gateObj;
  m.stableSeenAt = now;
  m.wasStationaryAt = now;
  m.samples = [
    { lat: Number(hit.lat), lon: Number(hit.lon), t: now - STATIONARY_MIN_MS - 50 },
    { lat, lon, t: now }
  ];
}


const GATE_CELL_DEG = 0.002; // ~220m (grob)
function gateCellKey(lat, lon){
  return `${Math.floor(lat / GATE_CELL_DEG)},${Math.floor(lon / GATE_CELL_DEG)}`;
}
function buildGateGrid(gates){
  const grid = new Map();
  for(const g of gates){
    const k = gateCellKey(g.lat, g.lon);
    if(!grid.has(k)) grid.set(k, []);
    grid.get(k).push(g);
  }
  return grid;
}

function normalizeGateLabel(tags){
  if(!tags) return null;
  let label =
    tags.ref ||
    tags.local_ref ||
    tags["ref:gate"] ||
    tags["gate:ref"] ||
    tags.gate ||
    tags["ref:stand"] ||
    tags.stand ||
    tags.name ||
    null;

  if(!label) return null;
  label = String(label).trim();
  if(!label) return null;

  // Optional: Terminal vorn dran (wenn label nur Zahl ist)
  const term = tags.terminal ? String(tags.terminal).trim() : "";
  if(term && /^[0-9]+[A-Z]?$/.test(label) && !label.startsWith(term)) label = `${term}${label}`;

  return label;
}

async function fetchOverpassGatesForAirport(icao){
  const ap = getAirport(icao);
  if(!ap) return [];
  const q = `
[out:json][timeout:25];
(
  node["aeroway"="parking_position"](around:${OSM_GATE_QUERY_RADIUS_M},${ap.latitude},${ap.longitude});
  node["aeroway"="gate"](around:${OSM_GATE_QUERY_RADIUS_M},${ap.latitude},${ap.longitude});
  node["aeroway"="stand"](around:${OSM_GATE_QUERY_RADIUS_M},${ap.latitude},${ap.longitude});
  way["aeroway"="parking_position"](around:${OSM_GATE_QUERY_RADIUS_M},${ap.latitude},${ap.longitude});
  way["aeroway"="gate"](around:${OSM_GATE_QUERY_RADIUS_M},${ap.latitude},${ap.longitude});
  way["aeroway"="stand"](around:${OSM_GATE_QUERY_RADIUS_M},${ap.latitude},${ap.longitude});
);
out center tags;
`.trim();

  const url = `${OVERPASS_API}?data=${encodeURIComponent(q)}`;
  const finalUrl = CORS_PROXY + encodeURIComponent(url);

  const res = await fetch(finalUrl, { cache: "no-store" });
  if(!res.ok) throw new Error(`Overpass HTTP ${res.status}`);
  const data = await res.json();

  const gates = [];
  for(const el of (data.elements || [])){
    const tags = el.tags || null;
    const label = normalizeGateLabel(tags);
    if(!label) continue;

    const lat = (typeof el.lat === "number") ? el.lat : (el.center?.lat);
    const lon = (typeof el.lon === "number") ? el.lon : (el.center?.lon);
    if(!isFinite(lat) || !isFinite(lon)) continue;

    gates.push({
      id: `${el.type}:${el.id}`,
      lat, lon,
      label,
      kind: tags?.aeroway || "unknown"
    });
  }

  // Duplikate (gleiches Label extrem nah) reduzieren
  gates.sort((a,b) => a.label.localeCompare(b.label, "en", { sensitivity:"base" }));
  const dedup = [];
  for(const g of gates){
    const prev = dedup[dedup.length-1];
    if(prev && prev.label === g.label){
      const d = haversineMeters(prev.lat, prev.lon, g.lat, g.lon);
      if(d < 8) continue;
    }
    dedup.push(g);
  }
  return dedup;
}

function ensureGateIndexForIcao(icao){
  icao = normalizeCode(icao);
  if(gateIndexByIcao.has(icao)){
    const cur = gateIndexByIcao.get(icao);
    if(cur && (Date.now() - cur.ts) < GATE_CACHE_TTL_MS) return Promise.resolve(cur);
  }
  if(gateLoadPromises.has(icao)) return gateLoadPromises.get(icao);

  const p = (async () => {
    const cache = await loadGateCache();
    const cached = cache[icao];
    if(cached && cached.ts && (Date.now() - cached.ts) < GATE_CACHE_TTL_MS && Array.isArray(cached.gates)){
      const idx = { ts: cached.ts, gates: cached.gates, grid: buildGateGrid(cached.gates) };
      gateIndexByIcao.set(icao, idx);
      return idx;
    }

    const gates = await fetchOverpassGatesForAirport(icao);
    const idx = { ts: Date.now(), gates, grid: buildGateGrid(gates) };
    gateIndexByIcao.set(icao, idx);

    cache[icao] = { ts: idx.ts, gates: idx.gates };
    saveGateCache(cache);

    return idx;
  })().finally(() => {
    gateLoadPromises.delete(icao);
  });

  gateLoadPromises.set(icao, p);
  return p;
}

function findNearestGate(idx, lat, lon, maxM){
  if(!idx || !idx.grid) return null;
  const cx = Math.floor(lat / GATE_CELL_DEG);
  const cy = Math.floor(lon / GATE_CELL_DEG);

  let best = null;
  let bestD = Infinity;

  for(let dx=-1; dx<=1; dx++){
    for(let dy=-1; dy<=1; dy++){
      const k = `${cx+dx},${cy+dy}`;
      const bucket = idx.grid.get(k);
      if(!bucket) continue;
      for(const g of bucket){
        const d = haversineMeters(lat, lon, g.lat, g.lon);
        if(d < bestD){
          bestD = d;
          best = g;
        }
      }
    }
  }

  if(best && bestD <= maxM) return { gate: best, distM: bestD };
  return null;
}

function pruneGateMem(){
  const now = Date.now();
  const ttl = 30 * 60 * 1000;
  for(const [cid, m] of gateMem.entries()){
    if(!m?.lastSeen || (now - m.lastSeen) > ttl) gateMem.delete(cid);
  }
  pruneGateFlightCache();

}

function updateStationaryState(cid, lat, lon, gsKts){
  const now = Date.now();
  let m = gateMem.get(cid);
  if(!m){
    m = {
      samples: [],
      stable: null,
      stableSeenAt: 0,
      pending: null,
      pendingSince: 0,
      lastSeen: 0,
      wasStationaryAt: 0
    };
    gateMem.set(cid, m);
  }

  m.lastSeen = now;

  // Default flags
  let taxiSure = false;
  let uncertain = false;

  if(!isFinite(lat) || !isFinite(lon)){
    m.samples = [];
    uncertain = true;
    return { mem: m, isStationary: false, moveM: null, taxiSure, uncertain };
  }

  // sofort "rolling" wenn GS hoch
  if(gsKts > TAXI_HIDE_GS_KTS){
    taxiSure = true;
    m.samples = [{ lat, lon, t: now }];
    return { mem: m, isStationary: false, moveM: null, taxiSure, uncertain:false };
  }

  m.samples.push({ lat, lon, t: now });
  while(m.samples.length && (now - m.samples[0].t) > STATIONARY_WINDOW_MS) m.samples.shift();

  const first = m.samples[0];
  const last  = m.samples[m.samples.length - 1];
  const dt    = last.t - first.t;

  // Recent-move check (Pushback/Taxi schneller erkennen)
  let recentMoveM = null;
  for(let i=m.samples.length-1; i>=0; i--){
    if(now - m.samples[i].t >= RECENT_MOVE_WINDOW_MS){
      recentMoveM = haversineMeters(m.samples[i].lat, m.samples[i].lon, last.lat, last.lon);
      break;
    }
  }
  if(recentMoveM != null && recentMoveM > RECENT_MOVE_MAX_M){
    taxiSure = true;
    return { mem: m, isStationary: false, moveM: recentMoveM, taxiSure, uncertain:false };
  }

  if(dt < STATIONARY_MIN_MS){
    uncertain = true; // noch nicht genug Daten für "Gate sicher"
    return { mem: m, isStationary: false, moveM: null, taxiSure:false, uncertain };
  }

  const moveM = haversineMeters(first.lat, first.lon, last.lat, last.lon);
  const isStationary = (moveM <= STATIONARY_MAX_MOVE_M) && (gsKts <= STATIONARY_MAX_GS_KTS);

  if(isStationary){
    m.wasStationaryAt = now;
    return { mem: m, isStationary: true, moveM, taxiSure:false, uncertain:false };
  }

  // Nicht stationär, aber auch nicht "Taxi sicher" => unklar -> Fallback
  uncertain = true;
  return { mem: m, isStationary: false, moveM, taxiSure:false, uncertain };
}


function resolveGateForCid(cid, lat, lon, gsKts, idx, cacheIcao){
  cid = String(cid);
  const now = Date.now();

  // WICHTIG: Cache-Seed auch ohne idx (damit Arrivals@Origin sofort Gate zeigen können)
  if(cacheIcao && isFinite(lat) && isFinite(lon) && isFinite(gsKts)){
    seedGateMemFromFlightCache(cid, cacheIcao, lat, lon, gsKts, idx || null);
  }

  const { mem, isStationary, taxiSure, uncertain } = updateStationaryState(cid, lat, lon, gsKts);

  let out = null;

  // Bei "Taxi sicher" KEIN Gate ausgeben (Status soll "Taxi" werden)
  if(taxiSure){
    out = null;
  }
  else if(!isStationary){
    // Jitter-Grace: wenn gerade erst “stationary”, Gate kurz halten
    if(mem.stable && (now - mem.wasStationaryAt) < GATE_JITTER_GRACE_MS && gsKts <= (STATIONARY_MAX_GS_KTS + 2)){
      out = mem.stable;
    }else{
      out = null;
    }
  }else{
    // Stationär
    if(!idx){
      // FIX: Wenn kein idx geladen ist, aber wir bereits ein stabiles Gate haben (z.B. aus Cache), zeige es trotzdem.
      if(mem.stable){
        mem.stableSeenAt = now;
        out = mem.stable;
      }else{
        out = null;
      }
    }else{
      const hit = findNearestGate(idx, lat, lon, GATE_MATCH_RADIUS_M);
      const cand = hit ? hit.gate : null;

      if(!cand){
        if(mem.stable && (now - mem.stableSeenAt) < GATE_LOST_GRACE_MS) out = mem.stable;
        else out = null;
      }else if(mem.stable && mem.stable.id === cand.id){
        mem.stableSeenAt = now;
        mem.pending = null;
        mem.pendingSince = 0;
        out = mem.stable;
      }else{
        if(mem.pending && mem.pending.id === cand.id){
          if((now - mem.pendingSince) >= GATE_CONFIRM_MS){
            mem.stable = cand;
            mem.stableSeenAt = now;
            mem.pending = null;
            mem.pendingSince = 0;
            out = mem.stable;
          }
        }else{
          mem.pending = cand;
          mem.pendingSince = now;
        }

        if(!out){
          if(mem.stable && (now - mem.stableSeenAt) < GATE_STICKY_MS) out = mem.stable;
          else out = null;
        }
      }
    }
  }

  // Persist nur wenn wirklich stationär
  if(out && cacheIcao && isStationary && isFinite(lat) && isFinite(lon) && isFinite(gsKts) && gsKts <= (STATIONARY_MAX_GS_KTS + 2)){
    persistGateFlightCache(cid, cacheIcao, out, lat, lon, gsKts);
  }

  return { gate: out, ground: { isStationary, taxiSure, uncertain } };
}

  /********************
   * OSM Taxiway Resolver (Overpass + Cache + Hysteresis)
   * - Checks aeroway=taxiway / taxiway_link near airport reference point
   * - Returns nearest distance to taxiway centerline (polyline segments)
   * - Adds per-CID hysteresis to show reliable TAXI status even with scenery offset
   ********************/
  const taxiwayIndexByIcao = new Map();   // icao -> { ts, segs, grid }
  const taxiwayLoadPromises = new Map();  // icao -> Promise
  const taxiMem = new Map();              // cid -> hysteresis state

  const TAXI_CELL_DEG = 0.004; // ~400m (rough) grid cell for segment buckets
  function taxiCellKey(lat, lon){
    return `${Math.floor(lat / TAXI_CELL_DEG)},${Math.floor(lon / TAXI_CELL_DEG)}`;
  }

  async function loadTaxiwayCache(){
    if (DB_CONFIG.enabled) {
        const remote = await dbLoad(TAXIWAY_CACHE_KEY);
        if (remote) {
            pruneLocalIfDbActive(TAXIWAY_CACHE_KEY);
            return remote;
        }
    }
    try{ return JSON.parse(localStorage.getItem(TAXIWAY_CACHE_KEY) || "{}"); } catch{ return {}; }
  }

  function saveTaxiwayCache(obj){
    if (DB_CONFIG.enabled) {
       dbSave(TAXIWAY_CACHE_KEY, obj).then(ok => { if(ok) pruneLocalIfDbActive(TAXIWAY_CACHE_KEY); });
    } else {
       try{ localStorage.setItem(TAXIWAY_CACHE_KEY, JSON.stringify(obj)); }catch(e){ console.warn("Skipping Taxiway Cache Save (Quota)"); }
    }
  }

  function llToXYm(lat, lon, refLat, refLon){
    const R = 6371000;
    const rad = Math.PI / 180;
    const x = (lon - refLon) * rad * R * Math.cos(refLat * rad);
    const y = (lat - refLat) * rad * R;
    return { x, y };
  }
  function distPointToSegMeters(lat, lon, seg){
    // Project around point to keep numbers small (good enough at airport scale)
    const a = llToXYm(seg.lat1, seg.lon1, lat, lon);
    const b = llToXYm(seg.lat2, seg.lon2, lat, lon);
    // point is (0,0)
    const vx = b.x - a.x, vy = b.y - a.y;
    const wx = -a.x,      wy = -a.y;
    const vv = vx*vx + vy*vy;
    if(vv < 1e-9) return Math.hypot(a.x, a.y);
    let t = (wx*vx + wy*vy) / vv;
    t = Math.max(0, Math.min(1, t));
    const px = a.x + t*vx;
    const py = a.y + t*vy;
    return Math.hypot(px, py);
  }

  function packTaxiSegs(segs){
    const flat = new Array(segs.length * 4);
    let i = 0;
    for(const s of segs){
      flat[i++] = s.lat1; flat[i++] = s.lon1; flat[i++] = s.lat2; flat[i++] = s.lon2;
    }
    return flat;
  }
  function unpackTaxiSegs(flat){
    const segs = [];
    if(!Array.isArray(flat)) return segs;
    for(let i=0; i+3<flat.length; i+=4){
      const lat1 = Number(flat[i]), lon1 = Number(flat[i+1]), lat2 = Number(flat[i+2]), lon2 = Number(flat[i+3]);
      if(!isFinite(lat1) || !isFinite(lon1) || !isFinite(lat2) || !isFinite(lon2)) continue;
      segs.push({ lat1, lon1, lat2, lon2 });
    }
    return segs;
  }

  function buildTaxiwayGrid(segs){
    const grid = new Map();
    for(const s of segs){
      const minLat = Math.min(s.lat1, s.lat2), maxLat = Math.max(s.lat1, s.lat2);
      const minLon = Math.min(s.lon1, s.lon2), maxLon = Math.max(s.lon1, s.lon2);
      const cx0 = Math.floor(minLat / TAXI_CELL_DEG);
      const cx1 = Math.floor(maxLat / TAXI_CELL_DEG);
      const cy0 = Math.floor(minLon / TAXI_CELL_DEG);
      const cy1 = Math.floor(maxLon / TAXI_CELL_DEG);
      for(let cx=cx0; cx<=cx1; cx++){
        for(let cy=cy0; cy<=cy1; cy++){
          const k = `${cx},${cy}`;
          if(!grid.has(k)) grid.set(k, []);
          grid.get(k).push(s);
        }
      }
    }
    return grid;
  }

  function simplifyGeometryPoints(geom, minStepM=15){
    // geom: [{lat,lon}, ...]
    if(!Array.isArray(geom) || geom.length < 2) return [];
    const out = [];
    let last = geom[0];
    out.push({ lat:last.lat, lon:last.lon });
    for(let i=1; i<geom.length; i++){
      const p = geom[i];
      if(!p || !isFinite(p.lat) || !isFinite(p.lon)) continue;
      const d = haversineMeters(last.lat, last.lon, p.lat, p.lon);
      if(d >= minStepM){
        out.push({ lat:p.lat, lon:p.lon });
        last = p;
      }
    }
    const tail = geom[geom.length-1];
    if(tail && isFinite(tail.lat) && isFinite(tail.lon)){
      const prev = out[out.length-1];
      if(!prev || haversineMeters(prev.lat, prev.lon, tail.lat, tail.lon) > 1){
        out.push({ lat:tail.lat, lon:tail.lon });
      }
    }
    return out;
  }

  async function fetchOverpassTaxiwaysForAirport(icao){
    const ap = getAirport(icao);
    if(!ap) return [];
    const q = `
[out:json][timeout:25];
(
  way["aeroway"~"^(taxiway|taxiway_link)$"](around:${TAXIWAY_QUERY_RADIUS_M},${ap.latitude},${ap.longitude});
);
out geom;
`.trim();


    const data = await fetchOverpassJson(q, { kind:"taxiways", icao });

    const segs = [];
    for(const el of (data.elements || [])){
      if(el.type !== "way") continue;
      const geom = simplifyGeometryPoints(el.geometry || [], 15);
      if(geom.length < 2) continue;
      for(let i=1; i<geom.length; i++){
        const a = geom[i-1], b = geom[i];
        if(!a || !b) continue;
        segs.push({ lat1:a.lat, lon1:a.lon, lat2:b.lat, lon2:b.lon });
      }
    }

    // Guardrail: avoid pathological sizes
    if(segs.length > 25000){
      // Light decimation: keep every 2nd segment (still usable for proximity)
      const slim = [];
      for(let i=0;i<segs.length;i+=2) slim.push(segs[i]);
      return slim;
    }
    return segs;
  }

  function ensureTaxiwayIndexForIcao(icao){
    icao = normalizeCode(icao);
    if(taxiwayIndexByIcao.has(icao)){
      const cur = taxiwayIndexByIcao.get(icao);
      if(cur && (Date.now() - cur.ts) < TAXIWAY_CACHE_TTL_MS) return Promise.resolve(cur);
    }
    if(taxiwayLoadPromises.has(icao)) return taxiwayLoadPromises.get(icao);

    const p = (async () => {
      const cache = await loadTaxiwayCache();
      const cached = cache[icao];
      if(cached && cached.ts && (Date.now() - cached.ts) < TAXIWAY_CACHE_TTL_MS && Array.isArray(cached.segs)){
        const segs = unpackTaxiSegs(cached.segs);
        const idx = { ts: cached.ts, segs, grid: buildTaxiwayGrid(segs) };
        taxiwayIndexByIcao.set(icao, idx);
        return idx;
      }

    // NEW: stale cache fallback
    if(cached && Array.isArray(cached.segs)){
      const segs = unpackTaxiSegs(cached.segs);
      const staleIdx = { ts: cached.ts || 0, segs, grid: buildTaxiwayGrid(segs), __stale:true };
      taxiwayIndexByIcao.set(icao, staleIdx);
      setTimeout(() => {
        if(taxiwayLoadPromises.has(icao)) return;
        ensureTaxiwayIndexForIcao(icao).catch(()=>{});
      }, 25_000);
      return staleIdx;
    }

      let segs = [];
      try{
        segs = await fetchOverpassTaxiwaysForAirport(icao);
      }catch(err){
        if(err?.__softFail || err?.__overpassTransient || isOverpassTransientStatus(err?.status)) return { ts: Date.now(), segs: [], grid: buildTaxiwayGrid([]), __softFail:true };
        throw err;
      }
      const idx = { ts: Date.now(), segs, grid: buildTaxiwayGrid(segs) };
      taxiwayIndexByIcao.set(icao, idx);

      // Attempt cache save with size guard
      try{
        const entry = { ts: idx.ts, segs: packTaxiSegs(segs) };
        const s = JSON.stringify(entry);
        if(s.length <= TAXIWAY_MAX_CACHE_CHARS){
          cache[icao] = entry;
          saveTaxiwayCache(cache);
        }
      }catch{}

      return idx;
    })().finally(() => {
      taxiwayLoadPromises.delete(icao);
    });

    taxiwayLoadPromises.set(icao, p);
    return p;
  }

  function nearestTaxiwayDistanceM(idx, lat, lon, maxM){
    if(!idx || !idx.grid) return null;
    const cx = Math.floor(lat / TAXI_CELL_DEG);
    const cy = Math.floor(lon / TAXI_CELL_DEG);
    let best = Infinity;

    for(let dx=-1; dx<=1; dx++){
      for(let dy=-1; dy<=1; dy++){
        const k = `${cx+dx},${cy+dy}`;
        const bucket = idx.grid.get(k);
        if(!bucket) continue;
        for(const seg of bucket){
          const d = distPointToSegMeters(lat, lon, seg);
          if(d < best){
            best = d;
            if(maxM != null && best <= maxM) return best;
          }
        }
      }
    }
    if(!isFinite(best)) return null;
    if(maxM != null && best > maxM) return null;
    return best;
  }

  function pruneTaxiMem(){
    const now = Date.now();
    const ttl = 30 * 60 * 1000;
    for(const [cid, m] of taxiMem.entries()){
      if(!m?.lastSeen || (now - m.lastSeen) > ttl) taxiMem.delete(cid);
    }
  }

  function resolveTaxiStatusForCid(cid, lat, lon, gsKts, { onGround, isStationary, taxiSure }, taxiIdx, taxiIcao){
    cid = String(cid);
    const now = Date.now();
    let m = taxiMem.get(cid);
    if(!m){
      m = {
        lastT: 0,
        lastSeen: 0,
        hitMs: 0,
        movingMs: 0,
        taxiStickyUntil: 0,
        taxiSince: 0,
        lastTaxiTs: 0,
        // taxi confirmation / confidence (used to prevent overly optimistic early ETDs during pushback)
        taxiConfirmedAt: 0,
        taxiConfirmed: false,
        taxiConfidence: 0,
        // smoothed ground track speed (kts) to avoid overly optimistic ETD from instantaneous GS
        lastLat: null,
        lastLon: null,
        speedEma: 0,
        // departure-specific latching helpers (used in dep board)
        lastMoveTs: 0,
        depTaxiUntil: 0,
        gateHoldSince: 0
      };
      taxiMem.set(cid, m);
      flagStateDirty();
    }

    m.lastSeen = now;
    const dt = (m.lastT && now > m.lastT) ? Math.min(60_000, now - m.lastT) : 0;
    m.lastT = now;

    // Track-speed on ground (from position deltas), robust against GS spikes.
    if(isFinite(lat) && isFinite(lon) && dt >= 1500){
      if(isFinite(m.lastLat) && isFinite(m.lastLon)){
        const dtH = dt / 3600000;
        const distNm = haversineNm(lat, lon, Number(m.lastLat), Number(m.lastLon));
        const spd = (isFinite(distNm) && dtH > 0) ? (distNm / dtH) : null;
        if(isFinite(spd) && spd >= 0.5 && spd <= 40){
          const a = 0.30;
          m.speedEma = m.speedEma ? (m.speedEma * (1-a) + spd * a) : spd;
        }
      }
      m.lastLat = lat;
      m.lastLon = lon;
          flagStateDirty();
    }

    const moving = !!onGround && !isStationary && (taxiSure || (isFinite(gsKts) && gsKts >= TAXIWAY_MIN_MOVING_KTS));

    let distM = null;
    let onTaxiway = false;
    if(moving && taxiIdx && isFinite(lat) && isFinite(lon)){
      distM = nearestTaxiwayDistanceM(taxiIdx, lat, lon, TAXIWAY_FALLBACK_RADIUS_M);
      if(distM != null){
        onTaxiway = distM <= TAXIWAY_FALLBACK_RADIUS_M;
      }
    }

    // Accumulate confirmation time while moving on ground
    if(moving){
      // RECOVERY: If we have a fresh ETD cache for this flight, assume TAXI is active immediately
      // This prevents flights reverting to "GATE" on reload while taxiing.
      if(!m.taxiSince){
         const etdCached = getPersistedEtd(cid);
         if(etdCached && (now - etdCached.t) < 15*60*1000){ // 15 min grace
             m.taxiSince = now - 60000; // fake start to skip confirm
             m.taxiConfirmedAt = now;
         }
      }
      // Record movement for dep-latch + takeoff heuristics (stop-and-go should not reset taxi start)
      m.lastMoveTs = now;
      m.lastTaxiTs = now;
      if(!m.taxiSince) m.taxiSince = now;
      // keep a long latch window for departures (actual usage decided in classifyFlight)
      m.depTaxiUntil = Math.max(m.depTaxiUntil || 0, now + DEP_TAXI_LATCH_MS);

      m.movingMs += dt;
      if(onTaxiway){
        m.hitMs += dt;
        // slight decay of moving time keeps it from getting "stuck" forever
        m.movingMs = Math.min(m.movingMs, 5 * 60 * 1000);
      }else{
        // taxiway miss: decay hit time slowly, keep moving time (fallback)
        m.hitMs = Math.max(0, m.hitMs - dt * 0.6);
      }
    }else{
      // Not moving or not on ground: decay quickly
      m.hitMs = Math.max(0, m.hitMs - dt * 1.2);
      m.movingMs = Math.max(0, m.movingMs - dt * 1.2);
      // When stationary on ground, do NOT wipe speedEma immediately (helps ETD remain stable during hold-short stops).
      if(!onGround){
        m.speedEma = 0;
      }
      // IMPORTANT: do NOT reset taxiSince on short stops (hold-short / queue).
      // Reset only when leaving the ground (airborne / no longer surface-tracked).
      if(!onGround){
        m.taxiSince = 0;
        m.lastTaxiTs = 0;
        m.taxiStickyUntil = 0;
        m.depTaxiUntil = 0;
        m.gateHoldSince = 0;
        flagStateDirty();
      }
    }

    const taxiCandidate = moving && (
      (m.hitMs >= TAXIWAY_CONFIRM_MS) ||
      (m.movingMs >= TAXI_MOVING_FALLBACK_CONFIRM_MS)
    );

    if(taxiCandidate){
      if(!m.taxiSince) m.taxiSince = now;
      m.lastTaxiTs = now;
      m.taxiStickyUntil = now + TAXI_STICKY_MS;
          flagStateDirty(); // New/Updated Taxi Stateow;
    }

    const taxiSticky = (m.taxiStickyUntil && m.taxiStickyUntil > now);
    const taxiActive = taxiCandidate || (taxiSticky && onGround && !isStationary);

    // Persist confidence for ETD heuristics / debugging (0..1)
    m.taxiConfirmed = !!taxiActive;
    m.taxiConfidence = clamp01(Math.max(
      (m.hitMs / Math.max(1, TAXIWAY_CONFIRM_MS)),
      (m.movingMs / Math.max(1, TAXI_MOVING_FALLBACK_CONFIRM_MS))
    ));

    return { taxiActive, onTaxiway, distM, moving, mem: m, icao: taxiIcao || null };
  }

  /********************
   * Hot Zone (Lineup Segment) Pre-Calculation
   * Holding Point -> Taxiway -> Runway Intersection
   ********************/
  const hotZoneIndexByIcao = new Map();
  const hotZoneLoadPromises = new Map();

  async function loadHotZoneCache(){
    if (DB_CONFIG.enabled) {
        const remote = await dbLoad(HOTZONE_CACHE_KEY);
        if (remote) {
            pruneLocalIfDbActive(HOTZONE_CACHE_KEY);
            return remote;
        }
    }
    try{ return JSON.parse(localStorage.getItem(HOTZONE_CACHE_KEY) || "{}"); } catch{ return {}; }
  }
  function saveHotZoneCache(obj){
    if (DB_CONFIG.enabled) dbSave(HOTZONE_CACHE_KEY, obj).then(ok => { if(ok) pruneLocalIfDbActive(HOTZONE_CACHE_KEY); });
    else try{ localStorage.setItem(HOTZONE_CACHE_KEY, JSON.stringify(obj)); }catch(e){}
  }

  // Find point on segment (p1, p2) closest to p
  function projectPointToSegment(pLat, pLon, lat1, lon1, lat2, lon2) {
    const {x: px, y: py} = llToXYm(pLat, pLon, lat1, lon1);
    const {x: vx, y: vy} = llToXYm(lat2, lon2, lat1, lon1);
    const len2 = vx*vx + vy*vy;
    if (len2 === 0) return { lat: lat1, lon: lon1, t: 0, dist: Math.hypot(px, py) };
    let t = (px*vx + py*vy) / len2;
    t = Math.max(0, Math.min(1, t));
    return {
      lat: lat1 + t * (lat2 - lat1), // approx for small distances
      lon: lon1 + t * (lon2 - lon1),
      t: t,
      dist: Math.hypot(px - t*vx, py - t*vy)
    };
  }

  async function ensureHotZoneIndexForIcao(icao){
    icao = normalizeCode(icao);
    if(hotZoneIndexByIcao.has(icao)) return hotZoneIndexByIcao.get(icao);
    if(hotZoneLoadPromises.has(icao)) return hotZoneLoadPromises.get(icao);

    const p = (async () => {
      // Check Cache
      const cache = await loadHotZoneCache();
      if(cache[icao] && (Date.now() - cache[icao].ts) < HOTZONE_CACHE_TTL_MS){
        const zones = cache[icao].zones;
        hotZoneIndexByIcao.set(icao, zones);
        return zones;
      }

      // Dependency: We need Runways and Taxiways first to calculate intersections
      const [rIdx, tIdx] = await Promise.all([
        ensureRunwayIndexForIcao(icao),
        ensureTaxiwayIndexForIcao(icao)
      ]);

      // Fetch Holding Points (aeroway=holding_position)
      const ap = getAirport(icao);
      if(!ap) return [];
      const q = `[out:json][timeout:25];node["aeroway"="holding_position"](around:6000,${ap.latitude},${ap.longitude});out geom;`;
      let data = { elements: [] };
      try { data = await fetchOverpassJson(q, { kind:"holding", icao }); } catch(e){}

      const zones = [];
      const holdingPoints = data.elements || [];

      // Calculation Logic:
      // 1. For each Holding Point, find nearest Taxiway Segment.
      // 2. Project HP onto Taxiway.
      // 3. From that point, look for the nearest Runway Intersection.
      //    (Simplification: Find nearest point on ANY Runway Axis. If < 150m, assume segment HP->RwyPoint)

      for(const hp of holdingPoints){
        if(!isFinite(hp.lat) || !isFinite(hp.lon)) continue;

        // Find closest Runway Axis Point
        let bestRwy = null, bestDist = Infinity, bestProj = null;

        for(const ep of (rIdx.endpoints || [])){
          // Find opposite endpoint to form axis
          const other = rIdx.endpoints.find(e => e.wayId === ep.wayId && e.epId !== ep.epId);
          if(!other) continue;
          const proj = projectPointToSegment(hp.lat, hp.lon, ep.lat, ep.lon, other.lat, other.lon);

          // Distance from Holding Point to Runway Centerline
          if(proj.dist < bestDist){
            bestDist = proj.dist;
            bestRwy = ep; // Reference endpoint (provides designator/heading)
            bestProj = proj;
          }
        }

        // Valid Hot Zone if Holding Point is reasonably close to a runway (e.g. < 120m)
        if(bestRwy && bestDist < 120){
           // Define Lineup Segment: From Holding Point to Projected Runway Point
           // Store Runway Heading for Alignment Check
           const rwyHdg = bearingDeg(bestRwy.lat, bestRwy.lon, bestProj.lat, bestProj.lon); // Heading of runway axis?? No, bearing between endpoints

           // Get actual runway heading (A -> B)
           const other = rIdx.endpoints.find(e => e.wayId === bestRwy.wayId && e.epId !== bestRwy.epId);
           const axisHdg = other ? bearingDeg(bestRwy.lat, bestRwy.lon, other.lat, other.lon) : 0;

           zones.push({
             hpLat: hp.lat, hpLon: hp.lon,
             intLat: bestProj.lat, intLon: bestProj.lon,
             rwyDes: bestRwy.designator,
             rwyHdg: axisHdg, // Heading of the runway itself
             segLen: bestDist
           });
        }
      }

      hotZoneIndexByIcao.set(icao, zones);

      // Save Cache
      cache[icao] = { ts: Date.now(), zones };
      saveHotZoneCache(cache);

      return zones;
    })();

    hotZoneLoadPromises.set(icao, p);
    return p;
  }

  /********************
   * Taxi Time History Manager
   * Records actual taxi durations (Gate -> Takeoff) to refine ETD predictions.
   ********************/
  const TaxiTimeManager = {
    data: {}, // { icao: { entries: [{ gateLat, gateLon, rwy, dur, ts }, ...] } }
    loaded: false,

    async load() {
      if (this.loaded) return;
      if (DB_CONFIG.enabled) {
          const remote = await dbLoad(TAXI_TIMES_CACHE_KEY);
          if (remote) {
              this.data = remote;
              pruneLocalIfDbActive(TAXI_TIMES_CACHE_KEY);
          }
      }
      try {
        const raw = localStorage.getItem(TAXI_TIMES_CACHE_KEY);
        if (raw && !this.data) this.data = JSON.parse(raw);
      } catch {}
      this.prune();
      this.loaded = true;
    },

    save() {
      this.prune();
      if (DB_CONFIG.enabled) {
          dbSave(TAXI_TIMES_CACHE_KEY, this.data).then(ok => { if(ok) pruneLocalIfDbActive(TAXI_TIMES_CACHE_KEY); });
      } else {
          try { localStorage.setItem(TAXI_TIMES_CACHE_KEY, JSON.stringify(this.data)); } catch(e) {}
      }
    },

    prune() {
      const now = Date.now();
      let changed = false;
      for (const icao in this.data) {
        const entries = this.data[icao].entries || [];
        const fresh = entries.filter(e => (now - e.ts) < TAXI_TIMES_TTL_MS);
        if (fresh.length !== entries.length) {
          this.data[icao].entries = fresh;
          changed = true;
        }
        if (fresh.length === 0) {
          delete this.data[icao];
          changed = true;
        }
      }
      // Guard against total cache bloat
      if(JSON.stringify(this.data).length > 500000) this.data = {};
      return changed;
    },

    record(icao, gateLat, gateLon, rwy, durationMs) {
      if (!icao || !isFinite(gateLat) || !isFinite(gateLon) || !durationMs || durationMs < 60000 || durationMs > 3600000) return;
      this.load();
      icao = normalizeCode(icao);
      if (!this.data[icao]) this.data[icao] = { entries: [] };

      // Add new entry
      this.data[icao].entries.push({
        gateLat: Number(gateLat.toFixed(5)),
        gateLon: Number(gateLon.toFixed(5)),
        rwy: rwy || "UNK",
        dur: Math.round(durationMs),
        ts: Date.now()
      });
      this.save();
    },

    estimate(icao, gateLat, gateLon, rwy) {
      this.load();
      icao = normalizeCode(icao);
      const airportData = this.data[icao];
      if (!airportData || !airportData.entries.length) return null;

      const now = Date.now();
      // 1. Filter by Runway (if known) and Age
      let relevant = airportData.entries.filter(e =>
        (rwy === null || e.rwy === "UNK" || e.rwy === rwy) &&
        (now - e.ts) < TAXI_TIMES_TTL_MS
      );

      if (relevant.length === 0) relevant = airportData.entries; // Fallback to any runway

      // 2. Filter by Gate Proximity (e.g. 300m radius)
      // If we don't have gate coords (e.g. mid-taxi), skip this or use broader avg
      let closeMatches = [];
      if (isFinite(gateLat) && isFinite(gateLon)) {
        closeMatches = relevant.filter(e => haversineMeters(gateLat, gateLon, e.gateLat, e.gateLon) < 300);
      }

      const source = closeMatches.length > 0 ? closeMatches : relevant;
      if (source.length === 0) return null;

      // 3. Calculate Weighted Average (favor recent)
      // Take up to last 5 entries
      source.sort((a, b) => b.ts - a.ts);
      const use = source.slice(0, 5);

      let sum = 0;
      for(const u of use) sum += u.dur;
      return sum / use.length;
    }
  };

  /********************
   * OSM Runway Threshold Resolver (Overpass + Cache + Target/Queue Model)
   *
   * - Fetch aeroway=runway ways with geometry, derive the two endpoints (first/last).
   * - Map endpoints to runway designators (e.g. "07C/25C") via bearing matching.
   * - For taxiing departures: pick the most likely target threshold (approaching + nearest).
   * - Detect departure queues near that threshold and adjust ETD for flights behind in line.
   ********************/
  const runwayIndexByIcao = new Map();     // icao -> { ts, endpoints: [...] }
  const runwayLoadPromises = new Map();    // icao -> Promise
  const runwayTargetMem = new Map();       // cid  -> { stableId, stableSince, pendingId, pendingSince, lastSeen }
  const runwayEntryMem  = new Map();       // cid  -> { stableKey, stableSince, pendingKey, pendingSince, lastSeen }

  /********************
   * Local flight memory (DEP==ARR==focus)
   ********************/
  const localFlightMem = new Map(); // cid -> { airborneSeenAt, lastSeen, returnedAt }
  function pruneLocalFlightMem(){
    const now = Date.now();
    for(const [cid, m] of localFlightMem.entries()){
      if(!m?.lastSeen || (now - m.lastSeen) > LOCAL_FLIGHT_TTL_MS) localFlightMem.delete(cid);
    }
  }
  function updateLocalFlightState(cid, { isLocal=false, airborne=false, onGround=false } = {}){
    cid = String(cid);
    const now = Date.now();
    if(!isLocal){
      // If it stops being local (plan changed), drop state.
      if(localFlightMem.has(cid)) localFlightMem.delete(cid);
      return { hasAirborne:false, returned:false };
    }
    let m = localFlightMem.get(cid);
    if(!m){
      m = { airborneSeenAt: 0, lastSeen: now, returnedAt: 0 };
      localFlightMem.set(cid, m);
    }
    m.lastSeen = now;
    if(airborne) m.airborneSeenAt = now;
    const hasAirborne = !!m.airborneSeenAt;
    // Mark "returned" only after we've seen it airborne at least once.
    if(onGround && hasAirborne && !m.returnedAt) m.returnedAt = now;
    return { hasAirborne, returned: !!m.returnedAt };
  }

  async function loadRunwayCache(){
    if (DB_CONFIG.enabled) {
        const remote = await dbLoad(RUNWAY_CACHE_KEY);
        if (remote) {
            pruneLocalIfDbActive(RUNWAY_CACHE_KEY);
            return remote;
        }
    }
    try { return JSON.parse(localStorage.getItem(RUNWAY_CACHE_KEY) || "{}"); } catch(e){ return {}; }
  }
  function saveRunwayCache(obj){
    if (DB_CONFIG.enabled) dbSave(RUNWAY_CACHE_KEY, obj).then(ok => { if(ok) pruneLocalIfDbActive(RUNWAY_CACHE_KEY); });
    else try { localStorage.setItem(RUNWAY_CACHE_KEY, JSON.stringify(obj)); } catch(e) {}
  }


  function bearingDeg(lat1, lon1, lat2, lon2){
    const toRad = d => d * Math.PI / 180;
    const y = Math.sin(toRad(lon2 - lon1)) * Math.cos(toRad(lat2));
    const x = Math.cos(toRad(lat1))*Math.sin(toRad(lat2)) -
              Math.sin(toRad(lat1))*Math.cos(toRad(lat2))*Math.cos(toRad(lon2 - lon1));
    let brg = Math.atan2(y, x) * 180 / Math.PI;
    brg = (brg + 360) % 360;
    return brg;
  }
  function normDeg360(x){
    const n = Number(x);
    if(!isFinite(n)) return null;
    return ((n % 360) + 360) % 360;
  }
  // Best-effort ground track: prefer derived track from previous position (less noisy than instantaneous heading),
  // fallback to pilot heading when deltas are too small.
  function deriveTrackBearingDeg(cid, lat, lon, pilotHeading){
    try{
      const now = Date.now();
      const prev = prevPilotStates.get(String(cid)) || null;
      const prevOk =
        prev && isFinite(prev.lat) && isFinite(prev.lon) && isFinite(prev.t) &&
        (now - prev.t) < 60*1000;
      if(prevOk){
        const dM = haversineMeters(Number(prev.lat), Number(prev.lon), Number(lat), Number(lon));
        // ignore tiny deltas (jitter)
        if(isFinite(dM) && dM >= 12){
          return bearingDeg(Number(prev.lat), Number(prev.lon), Number(lat), Number(lon));
        }
      }
    }catch{}
    const h = normDeg360(pilotHeading);
    return (h == null) ? null : h;
  }
  function angleDiffDeg(a, b){
    const d = ((a - b + 540) % 360) - 180;
    return Math.abs(d);
  }
  function runwayDesignatorToDeg(des){
    const m = String(des || "").trim().toUpperCase().match(/^(\d{1,2})([LCR])?$/);
    if(!m) return null;
    const n = Number(m[1]);
    if(!isFinite(n) || n < 1 || n > 36) return null;
    const deg = (n === 36) ? 0 : (n * 10);
    return deg;
  }

  // Normalize + validate runway designators for display (prevents leaking internal IDs like "RW:509962199:A")
  function isValidRunwayDesignator(des){
    const s = String(des || "").trim().toUpperCase();
    const m = s.match(/^(\d{1,2})([LCR])?$/);
    if(!m) return false;
    const n = Number(m[1]);
    return isFinite(n) && n >= 1 && n <= 36;
  }
  function normalizeRunwayDesignator(des){
    const s = String(des || "").trim().toUpperCase();
    const m = s.match(/^(\d{1,2})([LCR])?$/);
    if(!m) return null;
    let n = Number(m[1]);
    if(!isFinite(n) || n < 1 || n > 36) return null;
    const num = String(n).padStart(2, "0");
    const side = m[2] ? String(m[2]).toUpperCase() : "";
    return `${num}${side}`;
  }
  function bearingToRunwayDesignator(brg){
    const b = normDeg360(brg);
    if(b == null) return null;
    let n = Math.round(b / 10);
    if(n <= 0) n = 36;
    if(n > 36) n = ((n - 1) % 36) + 1;
    return String(n).padStart(2, "0");
  }

  function parseRunwayRefPair(ref){
    const raw = String(ref || "").trim().toUpperCase();
    if(!raw) return null;
    // Typical: "07C/25C" or "07/25" (sometimes with spaces)
    const parts = raw.split("/").map(s => s.trim()).filter(Boolean);
    if(parts.length >= 2){
      const a = parts[0].match(/^(\d{1,2})([LCR])?$/) ? parts[0].padStart(2,"0") : parts[0];
      const b = parts[1].match(/^(\d{1,2})([LCR])?$/) ? parts[1].padStart(2,"0") : parts[1];
      return [a, b];
    }
    return null;
  }

  function buildRunwayEndpointsFromElements(elements){
    const endpoints = [];
    for(const el of (elements || [])){
      if(el?.type !== "way") continue;
      const geom = Array.isArray(el.geometry) ? el.geometry : [];
      if(geom.length < 2) continue;
      const a = geom[0];
      const b = geom[geom.length - 1];
      if(!a || !b || !isFinite(a.lat) || !isFinite(a.lon) || !isFinite(b.lat) || !isFinite(b.lon)) continue;

      const tags = el.tags || {};
      const ref = String(tags.ref || tags.name || "").trim().toUpperCase();
      const pair = parseRunwayRefPair(ref);

      // If no usable ref, derive best-effort numeric designators from geometry bearing.
      // This avoids leaking internal fallback IDs into UI (e.g. "RW:509962199:A").
      const brgAB = bearingDeg(a.lat, a.lon, b.lat, b.lon);
      const guessA = bearingToRunwayDesignator(brgAB);
      const guessB = bearingToRunwayDesignator((brgAB + 180) % 360);

      // Keep original pair when present; otherwise use guessed numeric designators.
      // (Parallels without L/C/R will remain ambiguous, but still far better than internal IDs.)
      const rwAraw = pair ? pair[0] : (guessA || `RW:${el.id}:A`);
      const rwBraw = pair ? pair[1] : (guessB || `RW:${el.id}:B`);

      // Normalize where possible for consistency ("5" -> "05")
      const rwA = normalizeRunwayDesignator(rwAraw) || String(rwAraw).trim().toUpperCase();
      const rwB = normalizeRunwayDesignator(rwBraw) || String(rwBraw).trim().toUpperCase();

      const degA = runwayDesignatorToDeg(rwA);
      const degB = runwayDesignatorToDeg(rwB);

      // Decide which designator corresponds to the A->B bearing
      // If unknown, default: rwA at first point, rwB at last point
      let aIsRwA = true;
      if(degA != null && degB != null){
        const dA = angleDiffDeg(brgAB, degA);
        const dB = angleDiffDeg(brgAB, degB);
        aIsRwA = dA <= dB;
      }

      const ep1 = aIsRwA
        ? { epId:`way:${el.id}:${rwA}`, wayId: el.id, runwayRef: ref || "", designator: rwA, lat: a.lat, lon: a.lon }
        : { epId:`way:${el.id}:${rwB}`, wayId: el.id, runwayRef: ref || "", designator: rwB, lat: a.lat, lon: a.lon };
      const ep2 = aIsRwA
        ? { epId:`way:${el.id}:${rwB}`, wayId: el.id, runwayRef: ref || "", designator: rwB, lat: b.lat, lon: b.lon }
        : { epId:`way:${el.id}:${rwA}`, wayId: el.id, runwayRef: ref || "", designator: rwA, lat: b.lat, lon: b.lon };

      endpoints.push(ep1, ep2);
    }

    // Dedup identical endpoint IDs (just in case)
    const seen = new Set();
    return endpoints.filter(e => (seen.has(e.epId) ? false : (seen.add(e.epId), true)));
  }

  async function fetchOverpassRunwaysForAirport(icao){
    const ap = getAirport(icao);
    if(!ap) return [];

    const icaoQ = normalizeCode(icao);
    const iataQ = normalizeCode(ap.iata || "");

    // Prefer area query (more exact than around). Fallback to around if area yields nothing.
    const qArea = `
[out:json][timeout:25];
(
  area["icao"="${icaoQ}"];
  ${iataQ ? `area["iata"="${iataQ}"];` : ""}
)->.airport;
way["aeroway"="runway"](area.airport);
out geom tags;
`.trim();

    const runQuery = async (q) => fetchOverpassJson(q, { kind:"runways", icao });

    let data = null;
    try{
      data = await runQuery(qArea);
    }catch{
      data = null;
    }

    let els = data?.elements || [];
    if(!Array.isArray(els) || els.length === 0){
      const qAround = `
[out:json][timeout:25];
(
  way["aeroway"="runway"](around:14000,${ap.latitude},${ap.longitude});
);
out geom tags;
`.trim();
      const data2 = await runQuery(qAround);
      els = data2?.elements || [];
    }

    return buildRunwayEndpointsFromElements(els);
  }

  function ensureRunwayIndexForIcao(icao){
    icao = normalizeCode(icao);
    if(runwayIndexByIcao.has(icao)){
      const cur = runwayIndexByIcao.get(icao);
      if(cur && (Date.now() - cur.ts) < RUNWAY_CACHE_TTL_MS) return Promise.resolve(cur);
    }
    if(runwayLoadPromises.has(icao)) return runwayLoadPromises.get(icao);

    const p = (async () => {
      const cache = await loadRunwayCache();
      const cached = cache[icao];
      if(cached && cached.ts && (Date.now() - cached.ts) < RUNWAY_CACHE_TTL_MS && Array.isArray(cached.endpoints)){
        const idx = { ts: cached.ts, endpoints: cached.endpoints };
        runwayIndexByIcao.set(icao, idx);
        return idx;
      }

      // NEW: stale cache fallback
      if(cached && Array.isArray(cached.endpoints)){
        const staleIdx = { ts: cached.ts || 0, endpoints: cached.endpoints, __stale:true };
        runwayIndexByIcao.set(icao, staleIdx);
        setTimeout(() => {
          if(runwayLoadPromises.has(icao)) return;
          ensureRunwayIndexForIcao(icao).catch(()=>{});
        }, 30_000);
        return staleIdx;
      }

      let endpoints = [];
      try{
        endpoints = await fetchOverpassRunwaysForAirport(icao);
      }catch(err){
        if(err?.__softFail || err?.__overpassTransient || isOverpassTransientStatus(err?.status)) return { ts: Date.now(), endpoints: [], __softFail:true };
        throw err;
      }
      const idx = { ts: Date.now(), endpoints };
      runwayIndexByIcao.set(icao, idx);
      cache[icao] = { ts: idx.ts, endpoints: idx.endpoints };
      saveRunwayCache(cache);
      return idx;
    })().finally(() => {
      runwayLoadPromises.delete(icao);
    });

    runwayLoadPromises.set(icao, p);
    return p;
  }

  function pruneRunwayTargetMem(){
    const now = Date.now();
    const ttl = 25 * 60 * 1000;
    for(const [cid, m] of runwayTargetMem.entries()){
      if(!m?.lastSeen || (now - m.lastSeen) > ttl) runwayTargetMem.delete(cid);
    }
  }

  function pruneRunwayEntryMem(){
    const now = Date.now();
    const ttl = 25 * 60 * 1000;
    for(const [cid, m] of runwayEntryMem.entries()){
      if(!m?.lastSeen || (now - m.lastSeen) > ttl) runwayEntryMem.delete(cid);
    }
  }

  function quantizeM(x, step){
    if(!isFinite(x) || !isFinite(step) || step <= 0) return null;
    return Math.round(x / step) * step;
  }

  // --- Runway endpoint metric (stabilizes multi-runway airports) -----------------
  function runwayEndpointMetric(lat, lon, ep, runwayIdx){
    const dNow = haversineMeters(lat, lon, ep.lat, ep.lon);
    let axisLat = null;
    try{
      const other = runwayIdx?.endpoints?.find(e => e.wayId === ep.wayId && e.epId !== ep.epId) || null;
      if(other){
        const proj = projectToRunwayAxisMeters(lat, lon, ep.lat, ep.lon, other.lat, other.lon);
        axisLat = proj?.lateralM ?? null;
      }
    }catch{}
    // Penalty: clamp to avoid dominating far away from the airport.
    // Factor chosen so that being ~300-500m away from the "wrong" parallel runway axis strongly discourages it.
    const axisPenalty = (isFinite(axisLat) ? Math.min(900, axisLat * 2.2) : 0);
    const metric = (isFinite(dNow) ? dNow : Infinity) + axisPenalty;
    return { dNow, axisLat, metric };
  }

  // For ETD display: avoid "rounding up" into +2..3 minutes when very close to line-up.
  // Strategy: floor to minute of predicted time, but never show the current minute (prevents "past-looking" times).
  function etdDisplayMinuteTs(ts, now=Date.now()){
    if(ts == null || !isFinite(ts)) return null;
    const nowMin  = Math.floor(now / MIN_MS) * MIN_MS;
    const candMin = Math.floor(ts  / MIN_MS) * MIN_MS;
    return (candMin <= nowMin) ? (nowMin + MIN_MS) : candMin;
  }

  // Project aircraft position onto the runway axis (threshold A -> opposite end B), in meters (local flat approx).
  // Returns:
  // - alongM: distance from threshold A along runway axis to closest point
  // - lateralM: perpendicular distance to runway axis
  // - t: 0..1 projection factor (0=A, 1=B)
  // - lenM: runway length in meters
  function projectToRunwayAxisMeters(pLat, pLon, aLat, aLon, bLat, bLon){
    if(!isFinite(pLat) || !isFinite(pLon) || !isFinite(aLat) || !isFinite(aLon) || !isFinite(bLat) || !isFinite(bLon)) return null;
    const A = { x:0, y:0 };
    const B = llToXYm(bLat, bLon, aLat, aLon);
    const P = llToXYm(pLat, pLon, aLat, aLon);
    const vx = B.x - A.x, vy = B.y - A.y;
    const vv = vx*vx + vy*vy;
    if(vv < 1e-6) return null;
    let t = (P.x*vx + P.y*vy) / vv;
    t = Math.max(0, Math.min(1, t));
    const Qx = vx * t, Qy = vy * t;
    const lateralM = Math.hypot(P.x - Qx, P.y - Qy);
    const lenM = Math.hypot(vx, vy);
    const alongM = lenM * t;
    return { alongM, lateralM, t, lenM };
  }

  function intersectionHintFromRemarks(focusIcao, remarks){
    const r = String(remarks || "").toUpperCase();
    if(/\b(INT|INTERSECTION)\b/.test(r)) return true;
    // Small EDDB convenience: common VATSIM intersection callouts for 06R/24L ("M3", "M5", ...)
    if(normalizeCode(focusIcao) === "EDDB" && /\bM\d{1,2}\b/.test(r)) return true;
    return false;
  }

  function resolveEntryModeSticky(cid, candKey){
    // candKey: string that identifies entry choice (mode + cluster), e.g. "INT:way:123:06R:1500"
    cid = String(cid);
    const now = Date.now();
    let m = runwayEntryMem.get(cid);
    if(!m){
      m = { stableKey: candKey, stableSince: now, pendingKey: null, pendingSince: 0, lastSeen: now };
      runwayEntryMem.set(cid, m);
      return candKey;
    }
    m.lastSeen = now;

    const switching = candKey !== m.stableKey;
    const preferStable = (now - m.stableSince) < ETD_ENTRY_MODE_STICKY_MS;
    if(!switching || preferStable){
      if(m.pendingKey && m.pendingKey !== candKey){ m.pendingKey = null; m.pendingSince = 0; }
      return m.stableKey;
    }

    if(m.pendingKey === candKey){
      if((now - m.pendingSince) >= ETD_ENTRY_MODE_CONFIRM_MS){
        m.stableKey = candKey;
        m.stableSince = now;
        m.pendingKey = null; m.pendingSince = 0;
        return m.stableKey;
      }
    }else{
      m.pendingKey = candKey;
      m.pendingSince = now;
    }
    return m.stableKey;
  }

  function pickBestRunwayEndpoint(cid, lat, lon, runwayIdx){
    if(!runwayIdx?.endpoints?.length) return null;
    if(!isFinite(lat) || !isFinite(lon)) return null;

    const prev = prevPilotStates.get(String(cid)) || null;
    const prevOk = prev && isFinite(prev.lat) && isFinite(prev.lon) && isFinite(prev.t) && (Date.now() - prev.t) < 120*1000;

    let bestApproach = null;
    let bestAny = null;

    for(const ep of runwayIdx.endpoints){
      const mNow = runwayEndpointMetric(lat, lon, ep, runwayIdx);
      const dNow = mNow.dNow;
      const metricNow = mNow.metric;
      if(!isFinite(dNow) || dNow > RUNWAY_TARGET_MAX_CONSIDER_M) continue;
      if(!isFinite(metricNow)) continue;

      if(!bestAny || metricNow < bestAny.metric){
        bestAny = { ep, dNow, metric: metricNow, axisLatM: mNow.axisLat, approaching:false, gainM:0 };
      }

      if(prevOk){
        const mPrev = runwayEndpointMetric(prev.lat, prev.lon, ep, runwayIdx);
        const gainM = (mPrev.metric - metricNow); // positive => getting closer (includes axis stability)
        if(isFinite(gainM) && gainM >= RUNWAY_APPROACH_MIN_GAIN_M){
          if(!bestApproach || metricNow < bestApproach.metric){
            bestApproach = { ep, dNow, metric: metricNow, axisLatM: mNow.axisLat, approaching:true, gainM };
          }
        }
      }
    }

    return bestApproach || bestAny;
  }

  function resolveRunwayTargetForCid(cid, lat, lon, runwayIdx){
    cid = String(cid);
    const now = Date.now();

    const best = pickBestRunwayEndpoint(cid, lat, lon, runwayIdx);
    if(!best) return null;

    let m = runwayTargetMem.get(cid);
    if(!m){
      m = { stableId: best.ep.epId, stableSince: now, pendingId: null, pendingSince: 0, lastSeen: now };
      runwayTargetMem.set(cid, m);
      return best;
    }
    m.lastSeen = now;

    // Compute metric to current stable target for hysteresis (more stable on parallel RWYs)
    const stableEp = runwayIdx.endpoints.find(e => e.epId === m.stableId) || null;
    const stableM = stableEp ? runwayEndpointMetric(lat, lon, stableEp, runwayIdx) : null;
    const stableMetric = stableM?.metric ?? Infinity;
    const stableDist = stableM?.dNow ?? (stableEp ? haversineMeters(lat, lon, stableEp.lat, stableEp.lon) : Infinity);
    const bestMetric = (best.metric ?? best.dNow ?? Infinity);

    const switching = best.ep.epId !== m.stableId;
    const preferStable =
      (now - m.stableSince) < RUNWAY_TARGET_STICKY_MS &&
      isFinite(stableMetric) && isFinite(bestMetric) &&
      (stableMetric <= (bestMetric + 160)); // keep stable unless new is clearly better

    if(!switching || preferStable){
      // keep stable; clear pending if it doesn't match
      if(m.pendingId && m.pendingId !== best.ep.epId){
        m.pendingId = null; m.pendingSince = 0;
      }
      if(stableEp){
        return { ep: stableEp, dNow: stableDist, metric: stableMetric, axisLatM: stableM?.axisLat ?? null, approaching: best.approaching, gainM: best.gainM || 0 };
      }
      // If stable vanished, adopt best immediately
      m.stableId = best.ep.epId;
      m.stableSince = now;
      m.pendingId = null; m.pendingSince = 0;
      return best;
    }

    // Candidate differs and is clearly better; require confirmation time before switching
    if(m.pendingId === best.ep.epId){
      if((now - m.pendingSince) >= RUNWAY_TARGET_CONFIRM_MS){
        m.stableId = best.ep.epId;
        m.stableSince = now;
        m.pendingId = null; m.pendingSince = 0;
        return best;
      }
    }else{
      m.pendingId = best.ep.epId;
      m.pendingSince = now;
    }

    // still return stable until confirmed
    if(stableEp){
      return { ep: stableEp, dNow: stableDist, approaching: best.approaching, gainM: best.gainM || 0 };
    }
    return best;
  }

  function getRunwayTargetForFlight(f, runwayIdx){
    if(!f || !runwayIdx) return null;
    const p = f.pilot || null;
    const lat = Number(p?.latitude), lon = Number(p?.longitude);
    if(!isFinite(lat) || !isFinite(lon)) return null;

    const r = resolveRunwayTargetForCid(f.cid, lat, lon, runwayIdx);
    if(!r?.ep) return null;
    // Track bearing (for “on runway roll” detection + better intersection robustness)
    const trackBrg = deriveTrackBearingDeg(f.cid, lat, lon, p?.heading ?? null);

    // Determine opposite end of the same runway way to build an axis (A=takeoff threshold, B=opposite end)
    const wayId = r.ep.wayId;
    const other = runwayIdx.endpoints.find(e => e.wayId === wayId && e.epId !== r.ep.epId) || null;

    // Default: classic threshold distance (kept for backward compatibility / fallback)
    const thrDistM = isFinite(r.dNow) ? r.dNow : haversineMeters(lat, lon, r.ep.lat, r.ep.lon);

    // Axis projection (enables: intersection handling + better "along-runway" path approx)
    let proj = null, prevProj = null;
    if(other){
      proj = projectToRunwayAxisMeters(lat, lon, r.ep.lat, r.ep.lon, other.lat, other.lon);
      const prev = prevPilotStates.get(String(f.cid)) || null;
      const prevOk = prev && isFinite(prev.lat) && isFinite(prev.lon) && isFinite(prev.t) && (Date.now() - prev.t) < 120*1000;
      if(prevOk){
        prevProj = projectToRunwayAxisMeters(Number(prev.lat), Number(prev.lon), r.ep.lat, r.ep.lon, other.lat, other.lon);
      }
    }

    // Runway axis bearings (from selected takeoff threshold towards the opposite end)
    const axisBrg = other ? bearingDeg(r.ep.lat, r.ep.lon, other.lat, other.lon) : null;
    const axisOppBrg = (axisBrg == null) ? null : ((axisBrg + 180) % 360);
    const dAxis = (axisBrg != null && trackBrg != null) ? angleDiffDeg(trackBrg, axisBrg) : null;
    const dOpp  = (axisBrg != null && trackBrg != null) ? angleDiffDeg(trackBrg, axisOppBrg) : null;
    const trackAlignedAxis = (dAxis != null && dOpp != null) ? (Math.min(dAxis, dOpp) <= ETD_ON_RUNWAY_ALIGN_DEG) : false;
    const trackAwayFromThreshold = (dAxis != null) ? (dAxis <= ETD_ON_RUNWAY_ALIGN_DEG) : false; // “takeoff direction”
    const gsNow = Number(p?.groundspeed || 0);
    const onAxisTight  = !!(proj && isFinite(proj.lateralM) && proj.lateralM <= ETD_ON_RUNWAY_AXIS_M        && proj.t > 0.03 && proj.t < 0.97);
    const onAxisStrict = !!(proj && isFinite(proj.lateralM) && proj.lateralM <= ETD_ON_RUNWAY_AXIS_STRICT_M && proj.t > 0.03 && proj.t < 0.97);
    const mergeGainM = (proj && prevProj && isFinite(prevProj.lateralM)) ? (prevProj.lateralM - proj.lateralM) : 0;

    const axisApproachGainM = (proj && prevProj && isFinite(prevProj.lateralM) && isFinite(proj.lateralM)) ? (prevProj.lateralM - proj.lateralM) : null;
    const axisApproaching = (axisApproachGainM != null && axisApproachGainM >= 6);

    // Detect the most common false-positive: taxiing parallel to the runway axis (close lateral distance but not converging).
    // This can trigger INTERSECTION mode and/or LINEUP at multi-runway airports with parallel taxiways.
    const parallelToAxisLikely =
      !!(proj &&
         !onAxisStrict &&
         trackAlignedAxis &&
         isFinite(gsNow) && gsNow >= 4 && gsNow <= 28 &&
         isFinite(proj.lateralM) && proj.lateralM <= 140 &&
         !axisApproaching);

    const justMergedOntoAxis =
      onAxisStrict &&
      isFinite(mergeGainM) && mergeGainM >= ETD_ON_RUNWAY_MERGE_GAIN_M &&
      isFinite(gsNow) && gsNow >= 5;
    const rollingOnAxis =
      onAxisStrict &&
      trackAlignedAxis &&
      isFinite(gsNow) && gsNow >= ETD_ON_RUNWAY_GS_MIN_KTS;

    // Decide between THRESHOLD vs INTERSECTION entry (heuristic + sticky per CID)
    const remarksHint = intersectionHintFromRemarks(currentAirportIcao, f?.fp?.remarks || f?.flight_plan?.remarks || "");
    const cls = aircraftTaxiClass(f?.aircraft);

    let score = 0;
    if(remarksHint) score += 3;
    if(proj){
      // prefer intersection only if projection is not near runway ends
      if(proj.t > 0.08 && proj.t < 0.92) score += 1;
      if(proj.lateralM <= 90) score += 2;
      else if(proj.lateralM <= ETD_INTERSECTION_LATERAL_MAX_M) score += 1;
      if(proj.alongM >= 800) score += 1; // far from threshold along runway -> intersection more plausible
      if(prevProj){
        const dLat  = (prevProj.lateralM - proj.lateralM); // approaching axis
        const dAlong = (prevProj.alongM - proj.alongM);    // moving toward threshold (positive = toward threshold)
        if(dLat >= 8 && Math.abs(dAlong) <= 4) score += 2; // mostly perpendicular -> likely aiming for an entry/intersection
        if(dAlong >= 10) score -= 2;                       // clearly progressing toward threshold -> full length more likely
      }
      const gs = Number(p?.groundspeed || 0);
      if(isFinite(gs) && gs <= DEP_QUEUE_STOP_GS_KTS && proj.lateralM <= 120) score += 1; // stopped near hold short
      // NEW: Robust “entered runway via intersection” signals:
      // - justMergedOntoAxis: strong evidence the aircraft is turning onto runway centerline now
      // - rollingOnAxis in takeoff direction: aircraft is already rolling along runway → treat as intersection entry (do NOT keep full-length-to-threshold)
      if(justMergedOntoAxis) score += 4;
      if(rollingOnAxis && trackAwayFromThreshold && isFinite(proj.alongM) && proj.alongM >= 120) score += 4;
      // If rolling on axis *towards* the threshold (backtrack), do NOT force intersection (would make ETD too optimistic).
      if(rollingOnAxis && !trackAwayFromThreshold && isFinite(proj.alongM) && proj.alongM >= 250) score -= 3;
      // Penalize parallel taxiing close to the axis (classic false INTERSECTION trigger at multi-runway airports).
      if(parallelToAxisLikely) score -= 4;
      // If we are actually converging to the axis, nudge towards INTERSECTION.
      if(axisApproaching) score += 1.5;
        }
    if(cls === "heavy") score -= 1;
    else if(cls === "light") score += 0.5;

    // Default score-based choice…
    let modeRaw = (score >= 3) ? "INTERSECTION" : "THRESHOLD";
    // Hard guard: do not use INTERSECTION just because we are near and parallel to the runway axis.
    if(parallelToAxisLikely && !justMergedOntoAxis) modeRaw = "THRESHOLD";
    // …but if we are clearly on/merging onto the runway axis *and* moving in takeoff direction,
    // force INTERSECTION to avoid ETD showing minutes while the aircraft is already rolling on the runway.
    if(proj && onAxisStrict && (justMergedOntoAxis || (rollingOnAxis && trackAwayFromThreshold)) && isFinite(proj.alongM) && proj.alongM >= 120){
      modeRaw = "INTERSECTION";
    }
    const clusterM = (modeRaw === "INTERSECTION" && proj) ? (quantizeM(proj.alongM, ETD_ENTRY_CLUSTER_M) ?? 0) : 0;
    const candEntryKey = `${modeRaw}:${wayId}:${r.ep.designator}:${clusterM}`;
    const entryKey = resolveEntryModeSticky(f.cid, candEntryKey);
    const entryMode = entryKey.startsWith("INTERSECTION:") ? "INTERSECTION" : "THRESHOLD";

    // Compute effective remaining taxi distance (meters)
    let taxiDistM = thrDistM;
    let queueDistM = thrDistM;
    let entryAlongM = null;
    let entryLateralM = null;

    if(proj){
      entryAlongM = proj.alongM;
      entryLateralM = proj.lateralM;
      const axisOk = proj.lateralM <= ETD_AXIS_PATH_MAX_LATERAL_M;

      // Intersection mode is ONLY valid if we are truly converging to the runway axis,
      // or already on the runway axis (merged / rolling).
      const intersectionPlausible =
        (entryMode === "INTERSECTION") &&
        !parallelToAxisLikely &&
        (onAxisStrict || justMergedOntoAxis || axisApproaching) &&
        proj.t > 0.05 && proj.t < 0.95 &&
        proj.lateralM <= (ETD_INTERSECTION_LATERAL_MAX_M * 1.35);

      if(intersectionPlausible){
        // remaining distance ~ distance to the runway axis at the chosen intersection (bounded)
        taxiDistM = Math.max(12, proj.lateralM);
        queueDistM = taxiDistM;
      }else{
        // full-length: approximate remaining distance by "along runway axis to threshold" + a small lateral penalty
        if(axisOk && isFinite(proj.alongM)){
          const approx = proj.alongM + Math.min(250, proj.lateralM);
          // keep sane and avoid being *too* optimistic vs direct threshold distance
          taxiDistM = Math.max(thrDistM * 0.90, approx);
          queueDistM = taxiDistM;
        }else{
          taxiDistM = thrDistM;
          queueDistM = thrDistM;
        }
      }
    }

    // cache on flight object for this refresh (useful for queue scanning + debug)
    f.rwTarget = { epId: r.ep.epId, designator: r.ep.designator, runwayRef: r.ep.runwayRef || "" };
    f.rwDistM = thrDistM;               // kept: threshold distance
    f.rwTaxiDistM = taxiDistM;          // new: effective remaining distance used for ETD
    f.rwEntryMode = entryMode;          // new: THRESHOLD vs INTERSECTION
    f.rwEntryAlongM = entryAlongM;      // new: along-axis position
    f.rwEntryLateralM = entryLateralM;  // new: lateral distance to axis
    f.rwQueueKey = entryKey;            // new: sticky key (mode+cluster)
    f.rwQueueDistM = queueDistM;        // new: distance used for queue ordering/delay
    f.rwAxisBrg = axisBrg;
    f.rwTrackBrg = trackBrg;
    f.rwOnAxisTight = onAxisTight;
    f.rwOnAxisStrict = onAxisStrict;
    f.rwParallelToAxisLikely = parallelToAxisLikely;
    f.rwRollingOnAxis = rollingOnAxis;
    f.rwTrackAway = trackAwayFromThreshold;
    // Extra signal: helps LINEUP detection trigger as soon as the aircraft merges onto the runway centerline.
    f.rwJustMergedOntoAxis = justMergedOntoAxis;
    f.rwTrackAlignedAxis = trackAlignedAxis;

    return {
      epId: r.ep.epId,
      designator: r.ep.designator,
      runwayRef: r.ep.runwayRef || "",
      // distances
      thrDistM,
      taxiDistM,
      // entry
      entryMode,
      entryAlongM,
      entryLateralM,
      // queue
      queueKey: entryKey,
      queueDistM
    };
  }

  function getDepartureQueueDelayForFlight(f, runwayIdx, queueKey){
    if(!f || !runwayIdx || !queueKey) return { delaySec:0, pos:null, size:0, ahead:0 };
    const myGs = Number(f.pilot?.groundspeed || 0);
    if(!isFinite(myGs) || myGs > DEP_QUEUE_STOP_GS_KTS) return { delaySec:0, pos:null, size:0, ahead:0 };

    const now = Date.now();
    const list = [];
    for(const g of (lastDeps || [])){
      if(!g || g.__prefile) continue;
      if((g.status?.phase || "UNK") !== "TAXI") continue;
      const gs = Number(g.pilot?.groundspeed || 0);
      if(!isFinite(gs) || gs > DEP_QUEUE_STOP_GS_KTS) continue;

      // Require that the aircraft has actually been taxiing for a bit (filters early apron stops)
      const tm = taxiMem.get(String(g.cid)) || null;
      if(!tm?.taxiSince || (now - tm.taxiSince) < 60*1000) continue;

      const tgt = getRunwayTargetForFlight(g, runwayIdx);
      if(!tgt || tgt.queueKey !== queueKey || !isFinite(tgt.queueDistM)) continue;
      if(tgt.queueDistM > DEP_QUEUE_MAX_DIST_M) continue;

      list.push({ cid:String(g.cid), distM:tgt.queueDistM });
    }

    if(list.length < DEP_QUEUE_MIN_AIRCRAFT) return { delaySec:0, pos:null, size:list.length, ahead:0 };
    list.sort((a,b) => a.distM - b.distM); // closest to threshold first
    const idx = list.findIndex(x => x.cid === String(f.cid));
    if(idx < 0) return { delaySec:0, pos:null, size:list.length, ahead:0 };

    const delaySec = idx * DEP_QUEUE_PER_ACFT_SEC;
    return { delaySec, pos: idx+1, size: list.length, ahead: idx };
  }

 /********************
   * Arrivals: Actual Times (ALDT/AIBT) memory + fallbacks
   *
   * Goal:
   * - Once an arrival is detected "landed at focus airport": freeze ALDT
   * - Once an arrival is detected "in-block / on position": freeze AIBT and keep ALDT as a small sub-line
   * - Only show ALDT/AIBT when we actually have them; otherwise show ETA (with small "ETA" label)
   ********************/
  const arrActualTimeMem = new Map(); // cid -> { aldtTs, aibtTs, lastSeen }
  const ARR_ACTUAL_TTL_MS = 8 * 60 * 60 * 1000; // 8h

  function pilotLastUpdatedTs(p){
    try{
      const lu = p?.last_updated ? new Date(p.last_updated).getTime() : null;
      return isFinite(lu) ? lu : null;
    }catch{ return null; }
  }
  function pickActualTs(p){
    const now = Date.now();
    const lu = pilotLastUpdatedTs(p);
    // Use last_updated if it looks plausible; otherwise fallback to "now"
    if(isFinite(lu) && lu <= (now + 2*MIN_MS) && lu >= (now - 30*MIN_MS)) return lu;
    return now;
  }

  function pruneArrActualTimeMem(){
    const now = Date.now();
    for(const [cid, e] of arrActualTimeMem.entries()){
      if(!e?.lastSeen || (now - e.lastSeen) > ARR_ACTUAL_TTL_MS) arrActualTimeMem.delete(cid);
    }
  }

  function updateArrActualTimesForPilot(p, { isLandedAtFocus=false, isInBlockAtFocus=false } = {}){
    const cid = String(p?.cid ?? "");
    if(!cid) return;
    const now = Date.now();

    let e = arrActualTimeMem.get(cid);
    if(!e){
      e = { aldtTs:null, aibtTs:null, lastSeen: now };
      arrActualTimeMem.set(cid, e);
    }
    e.lastSeen = now;

    // Landed: freeze ALDT
    if(isLandedAtFocus){
      const candAldt = roundToMinute(pickActualTs(p));
      if(e.aldtTs == null || (isFinite(candAldt) && candAldt < e.aldtTs)) e.aldtTs = candAldt; // keep earliest plausible
    }

    // In-block: freeze AIBT (and ensure ALDT exists as fallback)
    if(isLandedAtFocus && isInBlockAtFocus){
      const candAibt = roundToMinute(pickActualTs(p));
      if(e.aibtTs == null) e.aibtTs = candAibt;
      if(e.aldtTs == null) e.aldtTs = e.aibtTs; // fallback: if we only ever see them in-block
      if(e.aibtTs != null && e.aldtTs != null && e.aibtTs < e.aldtTs) e.aibtTs = e.aldtTs;
    }

    // Attach to pilot for rendering/sorting fallbacks (flight objects keep pilot reference)
    p.__aldtTs = e.aldtTs ?? null;
    p.__aibtTs = e.aibtTs ?? null;
  }

  /********************
   * Core API Rate Limiter
   ********************/
  class RateLimiter {
    constructor({minIntervalMs=8000, storageKey=null}={}){
      this.minIntervalMs = minIntervalMs;
      this.storageKey = storageKey;
      this.queue = [];
      this.running = false;
      const last = Number(this.storageKey ? (localStorage.getItem(this.storageKey) || "0") : "0");
      this.lastRequestAt = isFinite(last) ? last : 0;
      this.backoffUntil = 0;
      this.inFlight = 0;
    }
    enqueue(fn){
      return new Promise((resolve, reject) => {
        this.queue.push({ fn, resolve, reject });
        this.pump();
      });
    }
    clear(){
      this.queue = [];
    }
    async pump(){
      if(this.running) return;
      this.running = true;
      while(this.queue.length){
        const now = Date.now();
        const waitForBackoff = Math.max(0, this.backoffUntil - now);
        const waitForInterval = Math.max(0, (this.lastRequestAt + this.minIntervalMs) - now);
        const waitMs = Math.max(waitForBackoff, waitForInterval);
        if(waitMs > 0) await new Promise(r => setTimeout(r, waitMs));

        if(this.queue.length === 0) break;

        const item = this.queue.shift();
        this.inFlight = 1;
        try{
          const res = await item.fn();
          this.lastRequestAt = Date.now();
          if(this.storageKey) localStorage.setItem(this.storageKey, String(this.lastRequestAt));
          item.resolve(res);
        }catch(e){
          if(e && e.__rateLimited) this.backoffUntil = Date.now() + 60000;
          item.reject(e);
        }finally{
          this.inFlight = 0;
        }
      }
      this.running = false;
    }
  }
  const limiter = new RateLimiter({ minIntervalMs: 8000, storageKey: API_LAST_REQ_KEY });

  /********************
   * Overpass: Queue + Backoff + Proxy-Fallback
   ********************/
  const overpassLimiter = new RateLimiter({ minIntervalMs: 25000, storageKey: OVERPASS_LAST_REQ_KEY });
  const overpassFailState = new Map(); // key -> { until, n, lastStatus }

  function isOverpassTransientStatus(s){
    return s === 429 || s === 502 || s === 503 || s === 504;
  }
  function overpassKey(kind, icao){
    return `${String(kind||"generic")}:${normalizeCode(icao||"")}`;
  }
  function overpassBackoffMs(key){
    const s = overpassFailState.get(key);
    const now = Date.now();
    return (s && s.until && s.until > now) ? (s.until - now) : 0;
  }
  function noteOverpassFailure(key, status){
    const cur = overpassFailState.get(key) || { until: 0, n: 0, lastStatus: status || 0 };
    cur.n = Math.min(8, (cur.n || 0) + 1);
    cur.lastStatus = status || cur.lastStatus || 0;
    // 429: deutlich länger pausieren, 5xx/timeout: kürzer aber exponentiell
    const base = (status === 429) ? 90_000 : 25_000;
    const maxW = (status === 429) ? 20 * 60_000 : 8 * 60_000;
    const jitter = Math.floor(Math.random() * 12_000);
    const wait = Math.min(maxW, Math.floor(base * Math.pow(2, cur.n - 1)) + jitter);
    cur.until = Date.now() + wait;
    overpassFailState.set(key, cur);
  }
  function clearOverpassFailure(key){
    overpassFailState.delete(key);
  }
  async function fetchOverpassJson(query, { kind="generic", icao="", timeoutMs=16000 } = {}){
    const key = overpassKey(kind, icao);
    const wait = overpassBackoffMs(key);
    if(wait > 0){
      const e = new Error(`Overpass backoff active (${Math.ceil(wait/1000)}s)`);
      e.__softFail = true;
      e.status = overpassFailState.get(key)?.lastStatus || 0;
      throw e;
    }

    const url = `${OVERPASS_API}?data=${encodeURIComponent(query)}`;

    const runOnce = async (proxyBase) => {
      const controller = new AbortController();
      const to = setTimeout(() => controller.abort(), timeoutMs);
      try{
        const finalUrl = proxyBase + encodeURIComponent(url);
        const res = await fetch(finalUrl, { cache:"no-store", signal: controller.signal });
        if(res.status === 429){
          const err = new Error("Overpass rate limited (429)");
          err.status = 429;
          err.__rateLimited = true;
          throw err;
        }
        if(isOverpassTransientStatus(res.status)){
          const err = new Error(`Overpass transient HTTP ${res.status}`);
          err.status = res.status;
          err.__overpassTransient = true;
          throw err;
        }
        if(!res.ok){
          const err = new Error(`Overpass HTTP ${res.status}`);
          err.status = res.status;
          throw err;
        }
        return res.json();
      }catch(err){
        if(err?.name === "AbortError"){
          const e = new Error("Overpass request timeout");
          e.status = 504;
          e.__overpassTransient = true;
          throw e;
        }
        throw err;
      }finally{
        clearTimeout(to);
      }
    };

    // Queue + try proxies
    return overpassLimiter.enqueue(async () => {
      let lastErr = null;
      for(const proxyBase of OVERPASS_PROXIES){
        try{
          const data = await runOnce(proxyBase);
          clearOverpassFailure(key);
          return data;
        }catch(err){
          lastErr = err;
          const st = err?.status || 0;
          // Nur bei transienten Fehlern den nächsten Proxy probieren
          if(isOverpassTransientStatus(st) || err?.__overpassTransient) continue;
          throw err;
        }
      }
      noteOverpassFailure(key, lastErr?.status || 504);
      throw lastErr;
    });
  }

  async function fetchJsonPossiblyEmpty(url, { useProxy=false, retryEmpty=3, retryDelayMs=800 } = {}){
    const finalUrl = useProxy ? (CORS_PROXY + encodeURIComponent(url)) : url;

    const runOnce = async () => {
      const res = await fetch(finalUrl, { cache:"no-store" });
      if(res.status === 429){
        const err = new Error("Rate limited (429)");
        err.__rateLimited = true;
        throw err;
      }

      if(!res.ok){
        const err = new Error(`HTTP ${res.status}`);
        err.status = res.status;
        throw err;
      }

      const text = await res.text();
      if(!text || !text.trim()) return { __empty:true, __status: res.status };
      return JSON.parse(text);
    };

    for(let attempt=1; attempt<=retryEmpty; attempt++){
      const out = useProxy ? await limiter.enqueue(runOnce) : await runOnce();
      if(out && out.__empty){
        await new Promise(r => setTimeout(r, retryDelayMs * attempt));
        continue;
      }
      return out;
    }
    throw new Error("API returned empty body repeatedly.");
  }

  function updateApiQueuePill(){
    const q = limiter.queue.length;
    const now = Date.now();
    const backoff = limiter.backoffUntil && limiter.backoffUntil > now;
    const inflight = limiter.inFlight || 0;

    apiDot.className = "dot " + (backoff ? "bad" : (q>0 || inflight) ? "warn" : "good");
    apiText.textContent = `API Q: ${q}`;

    if(backoff){
      apiExtra.textContent = `${Math.ceil((limiter.backoffUntil-now)/1000)}s`;
    }else if(inflight){
      apiExtra.textContent = "RUN";
    }else{
      apiExtra.textContent = "OK";
    }
  }
  setInterval(updateApiQueuePill, 250);

  /********************
   * Member Cache + API with 404 Guard
   ********************/
  function getCacheEntry(cid){ return memberCache[String(cid)] || null; }
  function upsertCacheEntry(cid, patch){
    const key = String(cid);
    const cur = memberCache[key] || {};
    memberCache[key] = { ...cur, ...patch, t: Date.now() };
    saveMemberCache();
  }
  function isFresh(ts, ttlMs){ return ts && (Date.now() - ts) < ttlMs; }
  function isCoolingDown(entry) { return entry && entry.status404Ts && isFresh(entry.status404Ts, MEMBER_404_TTL_MS); }

  async function getMemberDetails(cid){
    const entry = getCacheEntry(cid);
    if(isCoolingDown(entry)) return null;
    if(entry?.details && isFresh(entry.detailsTs, settings.memberTtlDetailsMs)) return entry.details;
    const url = `${CORE_API_BASE}/members/${cid}`;
    try {
      const details = await fetchJsonPossiblyEmpty(url, { useProxy:true, retryEmpty:4 });
      upsertCacheEntry(cid, { details, detailsTs: Date.now(), status404Ts: null });
      return details;
    } catch(err) {
      if(err.status === 404) {
        upsertCacheEntry(cid, { details: null, status404Ts: Date.now() });
        return null;
      }
      throw err;
    }
  }

  async function getMemberStats(cid){
    const entry = getCacheEntry(cid);
    if(isCoolingDown(entry)) return null;
    if(entry?.stats && isFresh(entry.statsTs, settings.memberTtlStatsMs)) return entry.stats;
    const url = `${CORE_API_BASE}/members/${cid}/stats`;
    try {
      const stats = await fetchJsonPossiblyEmpty(url, { useProxy:true, retryEmpty:5 });
      upsertCacheEntry(cid, { stats, statsTs: Date.now(), status404Ts: null });
      return stats;
    } catch(err) {
      if(err.status === 404) {
        upsertCacheEntry(cid, { stats: null, status404Ts: Date.now() });
        return null;
      }
      throw err;
    }
  }

  // Pilot history removed (UI hidden + no API fetch to preserve rate limits)
  async function getMemberHistory(_cid, _opts){
    return null;
  }

  /********************
   * Time Helpers (+1 / +n on next UTC day)
   ********************/
  const DAY_MS = 24 * 3600 * 1000;
  const MIN_MS = 60 * 1000;

  function utcDayStartMs(refMs=Date.now()){
    const d = new Date(refMs);
    return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
  }
  function fmtHHMMFromTs(ts){
    if(ts == null || !isFinite(ts)) return "—";
    return new Date(ts).toISOString().slice(11,16);
  }
  function dayOffsetFromNowUtc(ts, refMs=Date.now()){
    if(ts == null || !isFinite(ts)) return 0;
    const base = utcDayStartMs(refMs);
    const off = Math.floor((ts - base) / DAY_MS);
    return Math.max(0, off);
  }
  function fmtHHMMPlusText(ts, refMs=Date.now()){
    const base = fmtHHMMFromTs(ts);
    if(base === "—") return base;
    const off = dayOffsetFromNowUtc(ts, refMs);
    return off > 0 ? `${base} +${off}` : base;
  }
  function fmtHHMMPlusHtml(ts, refMs=Date.now()){
    const base = fmtHHMMFromTs(ts);
    if(base === "—") return base;
    const off = dayOffsetFromNowUtc(ts, refMs);
    return off > 0 ? `${base}<span class="dayPlus">+${off}</span>` : base;
  }
    function roundToMinute(ts){
    if(ts == null || !isFinite(ts)) return null;
    return Math.round(ts / MIN_MS) * MIN_MS;
  }

  const SURFACE_RADIUS_NM = 7.5; // count only aircraft on ground within this radius around airport ref point

  const taxiModel = {
    densityEma: 0,
    movingShareEma: 0,
    capHint: 22,
    lastUpdate: 0,
    snap: null
  };

  // Stable pseudo-random in [0..1] from any value (CID etc.) — deterministic across refreshes.
  function hashUnit(x){
    const s = String(x ?? "");
    let h = 2166136261;
    for(let i=0;i<s.length;i++){
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h >>> 0) / 4294967295;
  }

  function airportCapacityHint(icao){
    icao = normalizeCode(icao);
    const idx = gateIndexByIcao.get(icao) || null;
    const g = idx?.gates?.length || 0;
    // If we have gate data: scale "capacity" with gate count, but keep sane limits.
    if(g > 0){
      return Math.max(14, Math.min(60, Math.round(10 + (g / 6))));
    }
    // Fallback for unknown airports
    return 22;
  }

  function computeSurfaceTrafficSnapshot(pilots, focusIcao, focusAp){
    const out = {
      cap: airportCapacityHint(focusIcao),
      density: 0,
      totalGround: 0,
      movingTotal: 0,
      movingShare: 0,
      depGround: 0,
      depMoving: 0,
      depStopped: 0,
      arrGround: 0,
      arrMoving: 0
    };

    if(!focusAp || !Array.isArray(pilots) || pilots.length === 0) return out;

    for(const p of pilots){
      const fp = p?.flight_plan;
      if(!fp?.departure || !fp?.arrival) continue;

      const dep = normalizeCode(fp.departure);
      const arr = normalizeCode(fp.arrival);
      // Only consider flights that are relevant to this airport (DEP or ARR)
      if(dep !== focusIcao && arr !== focusIcao) continue;

      const lat = Number(p.latitude), lon = Number(p.longitude);
      const alt = Number(p.altitude || 0);
      const gs  = Number(p.groundspeed || 0);
      if(!isFinite(lat) || !isFinite(lon) || !isFinite(gs) || !isFinite(alt)) continue;

      const d = haversineNm(lat, lon, focusAp.latitude, focusAp.longitude);
      if(!isFinite(d) || d > SURFACE_RADIUS_NM) continue;

      // On-ground detection (consistent with elevation-aware logic)
      const groundRef = Number(focusAp.elevation || 0);
      const isGroundAlt = groundRef > 0 ? (alt < (groundRef + 350)) : (alt < 1500);
      const onGround = (gs < 45 && isGroundAlt);
      if(!onGround) continue;

      const moving = (gs > TAXI_HIDE_GS_KTS);
      const stopped = (gs <= STATIONARY_MAX_GS_KTS);

      out.totalGround++;
      if(moving) out.movingTotal++;

      if(dep === focusIcao){
        out.depGround++;
        if(moving) out.depMoving++;
        if(stopped) out.depStopped++;
      }else if(arr === focusIcao){
        out.arrGround++;
        if(moving) out.arrMoving++;
      }
    }

    out.movingShare = out.totalGround > 0 ? (out.movingTotal / out.totalGround) : 0;

    // "Pressure" weights:
    // - departures on the surface matter most (they compete for taxiways/runway queue)
    // - moving aircraft add extra interaction/queue pressure
    // - arrivals on surface count but slightly less for takeoff queue
    const pressure =
      (out.depGround * 1.00) +
      (out.depMoving * 0.75) +
      (out.depStopped * 0.35) +
      (out.arrGround * 0.60) +
      (out.arrMoving * 0.25);

    out.density = clamp01(pressure / Math.max(8, out.cap));
    return out;
  }

  function updateSurfaceTrafficModel(pilots, focusIcao, focusAp){
    // Prefetch OSM runway/taxiway/gate indexes early to avoid late status transitions (e.g. LINEUP).
    // Safe: cached with TTL + map guards; Overpass requests are throttled by reuse.
    try{
      const icao = normalizeCode(focusIcao || "");
      if(icao){
        if(!runwayIndexByIcao.has(icao)) ensureRunwayIndexForIcao(icao).catch(()=>{});
        if(!taxiwayIndexByIcao.has(icao)) ensureTaxiwayIndexForIcao(icao).catch(()=>{});
        if(!gateIndexByIcao.has(icao)) ensureGateIndexForIcao(icao).catch(()=>{});
      }
    }catch{}
    const snap = computeSurfaceTrafficSnapshot(pilots, focusIcao, focusAp);
    taxiModel.capHint = snap.cap;
    taxiModel.snap = snap;

    const a = 0.25; // EMA smoothing factor (higher = more reactive)
    const now = Date.now();
    if(!taxiModel.lastUpdate){
      taxiModel.densityEma = snap.density;
      taxiModel.movingShareEma = snap.movingShare;
    }else{
      taxiModel.densityEma = (taxiModel.densityEma * (1-a)) + (snap.density * a);
      taxiModel.movingShareEma = (taxiModel.movingShareEma * (1-a)) + (snap.movingShare * a);
    }
    taxiModel.lastUpdate = now;
    return snap;
  }

  function aircraftTaxiClass(typeStr){
    const t = String(typeStr || "").trim().toUpperCase();
    if(!t) return "medium";

    // rough & intentionally simple
    if(
      t.includes("A380") || t.startsWith("A38") ||
      t.startsWith("A35") || t.startsWith("A34") || t.startsWith("A33") ||
      t.startsWith("B74") || t.startsWith("B77") || t.startsWith("B78") ||
      t.includes("MD11") || t.includes("C17")
    ) return "heavy";

    // common airline medium jets
    if(t.startsWith("A32") || t.startsWith("B73") || t.startsWith("E1") || t.startsWith("CRJ") || t.startsWith("A22"))
      return "medium";

    return "light";
  }

  function estimateTaxiMinutesForFlight(f){
    // Inputs (smoothed)
    const density = clamp01(taxiModel.densityEma || 0);
    const movingShare = clamp01(taxiModel.movingShareEma || 0);

    // Base taxi time for a flight that is already "rolling" (TAXI phase)
    let minutes = 3.0;

    // Queue / interaction term: rises nonlinearly with density and a bit with movingShare.
    // Typical range: ~1..10 minutes.
    const queue = 1.0 + 7.0 * Math.pow(density, 1.35);
    const interaction = 1.0 + 1.2 * density * movingShare;
    minutes += queue * interaction;

    // Aircraft class adjustment (very rough)
    const cls = aircraftTaxiClass(f?.aircraft);
    if(cls === "heavy") minutes += 2.0;
    else if(cls === "light") minutes -= 0.4;

    // Very rough hint from distance to airport refpoint (often correlates a bit with runway ends vs apron)
    const d = f?.dFromFocusNm;
    if(isFinite(d)){
      if(d < 0.35) minutes += 1.2;      // likely still near terminal/apron
      else if(d > 1.40) minutes -= 0.9; // could be closer to a runway end
    }

    // Groundspeed hint (already moving faster -> likely progressed)
    const gs = Number(f?.pilot?.groundspeed || 0);
    if(isFinite(gs)){
      if(gs > 18) minutes -= 0.7;
      else if(gs < 10) minutes += 0.6;
    }

    // Stable per-flight jitter (CID-based) to avoid identical ETDs
    const u = hashUnit(f?.cid);
    minutes += (u - 0.5) * 2.4; // +-1.2 min

    // Guardrails
    minutes = Math.max(2.5, Math.min(28, minutes));
    return minutes;
  }

  // --- Flight State Persistence (Taxi/Lineup/Takeoff) ---
  // Ensures that upon reload, flights immediately show as TAXI/LINEUP/TAKEOFF
  // instead of falling back to GATE until movement is detected again.
  let flightStateDirty = false;

  function serializeMap(map){
    return JSON.stringify(Array.from(map.entries()));
  }
  function deserializeMap(json){
    try { return new Map(JSON.parse(json)); } catch { return new Map(); }
  }

  function saveFlightStateCache(){
    if(!flightStateDirty) return;
    // Only save essential active states to keep storage small
    const state = {
       taxi: serializeMap(taxiMem),
       lineup: serializeMap(lineupMem),
       takeoff: serializeMap(takeoffMem),
       ts: Date.now()
    };
    try{ localStorage.setItem(FLIGHT_STATE_KEY, JSON.stringify(state)); }catch{}
    flightStateDirty = false;
  }

  function loadFlightStateCache(){
    try{
      const raw = localStorage.getItem(FLIGHT_STATE_KEY);
      if(!raw) return;
      const state = JSON.parse(raw);
      if(state.ts && (Date.now() - state.ts) < FLIGHT_STATE_TTL_MS){
         // Restore Maps
         const tMap = deserializeMap(state.taxi);
         const lMap = deserializeMap(state.lineup);
         const toMap = deserializeMap(state.takeoff);

         // Merge into active maps (pruning logic happens in loop anyway)
         for(const [k,v] of tMap) taxiMem.set(k,v);
         for(const [k,v] of lMap) lineupMem.set(k,v);
         for(const [k,v] of toMap) takeoffMem.set(k,v);
      }
    }catch(e){ console.warn("State load err", e); }
  }

  // Hook into the save interval
  setInterval(() => {
     saveFlightStateCache();
  }, 4000);

  // Helper to flag dirty whenever we modify these critical maps
  function flagStateDirty(){ flightStateDirty = true; }


  // --- ETD Persistence (Reload Safety) ---
  let etdCacheData = {};
  let etdCacheDirty = false;

  async function loadEtdCache(){
    if (DB_CONFIG.enabled) {
        const remote = await dbLoad(ETD_PERSIST_KEY);
        if (remote) {
            etdCacheData = remote;
            pruneLocalIfDbActive(ETD_PERSIST_KEY);
        }
    }
    try{
       const raw = localStorage.getItem(ETD_PERSIST_KEY);
       if(raw && Object.keys(etdCacheData).length === 0) etdCacheData = JSON.parse(raw);
    }catch{}
    pruneEtdCache();
  }

  function saveEtdCache(){
    if(!etdCacheDirty) return;
    if (DB_CONFIG.enabled) {
        dbSave(ETD_PERSIST_KEY, etdCacheData).then(ok => { if(ok) pruneLocalIfDbActive(ETD_PERSIST_KEY); });
    } else {
        try{ localStorage.setItem(ETD_PERSIST_KEY, JSON.stringify(etdCacheData)); }catch{}
    }
        etdCacheDirty = false;
  }
  // Save periodically (e.g. every 5s) to avoid IO spam
  setInterval(saveEtdCache, 5000);

  function pruneEtdCache(){
    const now = Date.now();
    let changed = false;
    for(const cid in etdCacheData){
       if((now - etdCacheData[cid].t) > ETD_PERSIST_TTL_MS){
          delete etdCacheData[cid];
          changed = true;
       }
    }
    if(changed) etdCacheDirty = true;
  }

        function getPersistedEtd(cid){
                const e = etdCacheData[String(cid)];
                if(!e || !isFinite(e.ts) || !isFinite(e.t)) return null;
        return e; // { ts, t }
}

  function persistEtd(cid, ts){
    if(!ts || !isFinite(ts)) return;
    etdCacheData[String(cid)] = { ts, t: Date.now() };
    etdCacheDirty = true;
  }

  // ETD stabilizer (separate from ETA stabilizer)
  let etdMemory = new Map();
  function etdKey(cid){ return `etd:${String(cid)}`; }
  function stabilizeEtd(key, candTs, phase){
    const now = Date.now();
    let mem = etdMemory.get(key);

    // If not in TAXI anymore: drop ETD memory quickly
    if(phase !== "TAXI"){
      if(mem) etdMemory.delete(key);
      return null;
    }

    // Taxi age (and confirmation) are used to avoid seeding overly optimistic ETDs during pushback
    // and to allow faster correction if the first estimate was too short.
    let taxiAgeSec = 0;
    let taxiConfirmedAt = 0;
    try{
      // key format: "etd:<cid>"
      const cid = String(key || "").split(":")[1] || "";
      const tm = taxiMem.get(cid) || null;
      if(tm?.taxiSince && now >= tm.taxiSince) taxiAgeSec = Math.max(0, (now - tm.taxiSince) / 1000);
      taxiConfirmedAt = Number(tm?.taxiConfirmedAt || 0);
    }catch{}

    if(candTs == null || !isFinite(candTs)){
      if(mem && (now - mem.lastSeen) < 2*60*1000){
        mem.lastSeen = now;
        return mem.ts;
      }
      return null;
    }

    if(!mem){
                // Try to load from persistence (reload recovery)
                const persisted = getPersistedEtd(String(key).split(":")[1]);
                        if(persisted){
                                mem = { ts: persisted.ts, lastSeen: now, createdAt: now - 30000 };
                                etdMemory.set(key, mem);
                                }
                        }

    // Early TAXI logic...
    // Apply a slightly larger minimum lead at the start, relaxed once taxi is "confirmed".
    const earlyConfirmed = (taxiConfirmedAt && (now - taxiConfirmedAt) >= 15_000);
    const seedFloorMs =
      (taxiAgeSec > 0 && taxiAgeSec < 60)  ? ((earlyConfirmed ? 3 : 4) * MIN_MS) :
      (taxiAgeSec >= 60 && taxiAgeSec < 120) ? (3 * MIN_MS) :
      (ETD_MIN_AHEAD_SEC * 1000);
    const target = Math.max(candTs, now + seedFloorMs);

    if(!mem){
      mem = { ts: target, lastSeen: now, createdAt: now };
      etdMemory.set(key, mem);
          persistEtd(String(key).split(":")[1], target);
      return target;
    }

    if(!mem.createdAt) mem.createdAt = now; // migrate old cache entries
    mem.lastSeen = now;

    const prev = mem.ts;
    // Phase is always TAXI here; adapt smoothing based on taxi-age to prevent
    // (a) early overly optimistic ETD and (b) slow "creep" that only moves later.
    const lifeSec = Math.max(0, (now - (mem.createdAt || now)) / 1000);
    const baseAlpha =
      (taxiAgeSec > 0 && taxiAgeSec < 120) ? 0.18 :
      (taxiAgeSec >= 120 && taxiAgeSec < 420) ? 0.26 :
      0.32;

    // If the initial estimate was too short, we must be able to correct quickly early on.
    const earlyPhase = (lifeSec < 90) || (taxiAgeSec > 0 && taxiAgeSec < 150);
    const bigLater = (target - prev) > (4 * MIN_MS);
    const alpha = (earlyPhase && bigLater) ? Math.max(baseAlpha, 0.55) : baseAlpha;

    const raw = prev + (target - prev) * alpha;

    // Asymmetric jump limits:
    // - allow ETD to move EARLIER a bit more (progress can legitimately beat the estimate)
    // - limit how fast it moves LATER (removes the "always getting pushed back" feel)
    const maxJumpLater = earlyPhase ? (4.5 * MIN_MS) : (2.2 * MIN_MS);
    const maxJumpEarlier = (taxiAgeSec > 0 && taxiAgeSec < 120) ? (2.5 * MIN_MS) : (4.0 * MIN_MS);
    const diff = raw - prev;
    const limited = prev + (diff >= 0
      ? Math.min(maxJumpLater, diff)
      : Math.max(-maxJumpEarlier, diff)
    );

    mem.ts = limited;
        persistEtd(String(key).split(":")[1], limited);
    return limited;
  }
  function pruneEtdMemory(){
    const now = Date.now();
    const ttl = 20 * 60 * 1000;
    for(const [k,v] of etdMemory.entries()){
      if(!v?.lastSeen || (now - v.lastSeen) > ttl) etdMemory.delete(k);
    }
        pruneRunwayTargetMem();
        pruneRunwayEntryMem();
        pruneLocalFlightMem();
  }

  // For taxiing departures: runway-threshold based ETD:
  //   remaining = (distance_to_threshold / avg_taxi_speed) + lineup_buffer + queue_delay
  function computeEtdForTaxi(stdTs, now=Date.now(), flight=null){
        const MAX_AHEAD_MS = 120 * MIN_MS;   // cap: avoid insane ETDs

    let predicted = null;

    // Ensure runway index (async). We still provide a fallback if not ready.
    const focusIcao = normalizeCode(currentAirportIcao || "");
    const rIdx = focusIcao ? (runwayIndexByIcao.get(focusIcao) || null) : null;
    if(focusIcao && !rIdx){
      ensureRunwayIndexForIcao(focusIcao).catch(()=>{});
    }
    // Ensure HotZones (Lineup Segments)
    ensureHotZoneIndexForIcao(focusIcao).catch(()=>{});

    // Taxi age & smoothed ground-speed (reduces early optimism and ETD "creep to the right")
      const tm = flight ? (taxiMem.get(String(flight.cid)) || null) : null;
    // Early taxi overhead (pushback, stop&go, hold-short) that decays as we observe taxi time.
    // This specifically addresses "ETD too optimistic at the beginning, then shifts later".
    const taxiAgeSec = (tm?.taxiSince && now >= tm.taxiSince) ? Math.max(0, (now - tm.taxiSince) / 1000) : 0;
        let startupExtraSec = tm
      ? Math.max(0, Math.min(220, 190 - taxiAgeSec * 0.65))  // ~+3:10 at start -> ~0 after ~5 min (more conservative for pushback)
      : 170;

    // Dynamic buffer: smaller when very close to the entry / already queued.
    function etdLineupBufferSec(distM, gsKts, stopped, hasQueueAhead){
      // Base buffer derived from historical data could go here, but for "final approach to runway"
      // we stick to physics/geometry.
      let buf = 45;
      if(isFinite(distM)){
        if(distM <= 60) buf = 25;
        else if(distM <= 120) buf = 35;
        else if(distM <= 220) buf = 40;
        else if(distM <= 420) buf = 50;
        else if(distM >= 1400) buf = 70;
      }
      // Add conservatism during the first ~2 minutes of taxi (before runway intent stabilizes).
      if(taxiAgeSec > 0 && taxiAgeSec < 60) buf += 18;
      else if(taxiAgeSec >= 60 && taxiAgeSec < 120) buf += 10;
      if(stopped && isFinite(distM) && distM <= 120) buf -= 8;
      if(isFinite(gsKts) && gsKts >= 25 && isFinite(distM) && distM <= 220) buf -= 10;
      if(hasQueueAhead) buf += 8;
      return Math.max(20, Math.min(120, Math.round(buf)));
    }

    // Primary: runway-axis based (threshold + intersection aware)
    if(rIdx && flight?.pilot){
      const tgt = getRunwayTargetForFlight(flight, rIdx);
      const distM = tgt?.taxiDistM;
      if(isFinite(distM)){
        // NEW: If the aircraft is already rolling on the runway (after joining via an intersection),
        // treat remaining distance as “to line-up” (near-zero), not “to threshold”.
        let distUsedM = distM;
        try{
          const gsNow = Number(flight.pilot.groundspeed || 0);
          const onAxis = !!flight.rwOnAxisStrict;
          const axisBrg = Number(flight.rwAxisBrg);
          const trackBrg = Number(flight.rwTrackBrg);
          if(onAxis && isFinite(axisBrg) && isFinite(trackBrg) && isFinite(gsNow)){
            const dA = angleDiffDeg(trackBrg, axisBrg);
            const dO = angleDiffDeg(trackBrg, (axisBrg + 180) % 360);
            const aligned = Math.min(dA, dO) <= ETD_ON_RUNWAY_ALIGN_DEG;
            const away = dA <= ETD_ON_RUNWAY_ALIGN_DEG; // takeoff direction away from threshold
            const latM = Number(flight.rwEntryLateralM);

            // Rolling along runway in takeoff direction => ETD must be near-immediate.
            if(aligned && away && gsNow >= ETD_ON_RUNWAY_GS_MIN_KTS && isFinite(latM)){
              distUsedM = Math.min(distUsedM, Math.max(0, Math.min(ETD_ON_RUNWAY_AXIS_STRICT_M, latM)));
              // also remove most of the “startup” padding once already on the runway
              startupExtraSec = Math.min(startupExtraSec, 12);
            }
            // NEW: Rapid ETD countdown if rolling on runway
            if(aligned && away && gsNow > 15 && onAxisStrict){
               const rapidCap = (gsNow > 40) ? 30 : 60; // seconds
               const capTs = now + rapidCap * 1000;
               // We apply this clamp at the very end
               flight.__rapidRunwayRoll = capTs;
            }
            // Lined-up / very slow on runway axis (common just before takeoff clearance)
            if(aligned && away && gsNow <= DEP_QUEUE_STOP_GS_KTS && isFinite(latM) && latM <= (ETD_ON_RUNWAY_AXIS_M + 6)){
              distUsedM = Math.min(distUsedM, Math.max(0, latM));
              startupExtraSec = Math.min(startupExtraSec, 10);
            }
          }
        }catch{}

        // Use smoothed track-speed on ground when available; fall back to instantaneous GS.
        let taxiKts = Number(tm?.speedEma || flight.pilot.groundspeed || 0);
        if(!(taxiKts >= ETD_TAXI_SPEED_MIN_KTS && taxiKts <= ETD_TAXI_SPEED_MAX_KTS)){
          taxiKts = ETD_TAXI_SPEED_AVG_KTS;
        }
        // Prevent early "sprints" from making ETD unrealistically early.
        if(taxiAgeSec > 0 && taxiAgeSec < 120){
          taxiKts = Math.min(taxiKts, 14.5);
        }
        const speedMps = taxiKts * 0.514444; // kts -> m/s
        const stopped = (Number(flight.pilot.groundspeed || 0) <= DEP_QUEUE_STOP_GS_KTS);

        // Queue delay (works for both threshold + intersection "entry keys")
        const q = getDepartureQueueDelayForFlight(flight, rIdx, tgt?.queueKey);
        const hasAhead = !!(q && q.ahead > 0);

        // HISTORICAL TAXI TIME FACTOR
        // If we are still far from the runway, blend in the historical average for this gate/runway.
        let historicalMs = null;
        if (tm && tm.gateLat && tm.gateLon) {
           // We stored gate location when taxi started (see resolveTaxiStatusForCid)
           historicalMs = TaxiTimeManager.estimate(currentAirportIcao, tm.gateLat, tm.gateLon, tgt.designator);
        }

        const bufSec = etdLineupBufferSec(distUsedM, Number(flight.pilot.groundspeed || 0), stopped, hasAhead);
        let physicsSec = (distUsedM / Math.max(2.0, speedMps)) + bufSec + ETD_TAKEOFF_ROLL_SEC + startupExtraSec;

        // Blending Logic:
        // If we have a historical average (e.g. 12 mins) and we know the flight started taxiing 4 mins ago,
        // remaining is roughly 8 mins.
        // As the aircraft gets closer to the runway (distance < 1500m), we fade out history and rely on physics.
        if (historicalMs && taxiAgeSec > 30 && distUsedM > 800) {
            const remainingHistSec = Math.max(120, (historicalMs/1000) - taxiAgeSec);
            // Blend factor: 1.0 at distance > 3000m, 0.0 at distance < 800m
            const blend = Math.min(1, Math.max(0, (distUsedM - 800) / 2200));
            physicsSec = (physicsSec * (1-blend)) + (remainingHistSec * blend);
        }

        // If we are already essentially at the hold short / line-up point and nobody is ahead, bias slightly earlier.
        const closeBonus = (!hasAhead && stopped && isFinite(distUsedM) && distUsedM <= 80) ? -8 : 0;
        const sec = Math.max(10, physicsSec + (q?.delaySec || 0) + closeBonus);

        // Use ETD-specific minute handling (prevents +2..3min artifacts near line-up)
        predicted = etdDisplayMinuteTs(now + sec * 1000, now);

        // Apply Rapid Roll Cap
        if(flight.__rapidRunwayRoll){
           predicted = Math.min(predicted, flight.__rapidRunwayRoll);
        }
      }
    }

    // Fallback: keep the old “surface traffic” taxi estimate if runway data isn't ready
    if(predicted == null){
      const taxiMin = flight ? estimateTaxiMinutesForFlight(flight) : 4.0;
      predicted = roundToMinute(now + taxiMin * MIN_MS);
    }

    // Early-roll guard:
    // During the first ~1–2 minutes after taxi start (often pushback/initial roll),
    // the runway-axis distance model can be *way* too optimistic (especially if apron is close to the runway axis).
    // Use a conservative floor (traffic model + minimal lead) until intent stabilizes,
    // unless the aircraft is clearly already on/merging onto the runway.
    if(flight && isFinite(predicted)){
      const gsNow = Number(flight?.pilot?.groundspeed || 0);
      // NEW: Rapid Roll Cap is VERY authoritative.
      if(flight.__rapidRunwayRoll){
         predicted = Math.min(predicted, flight.__rapidRunwayRoll);
      }
      const distToThrM = Number(flight?.rwDistM);
      const distToEntryM = Number(flight?.rwTaxiDistM);
      const closeEntry = isFinite(distToEntryM) && distToEntryM <= 260;
      const nearRunwayArea = isFinite(distToThrM) && distToThrM <= 1100;
      const runwayStrong = !!(
        flight.rwOnAxisStrict &&
        (flight.rwJustMergedOntoAxis || (flight.rwRollingOnAxis && flight.rwTrackAway && gsNow >= ETD_ON_RUNWAY_GS_MIN_KTS))
      );
      const allowShortEarly = runwayStrong || (nearRunwayArea && closeEntry);

      const earlyRoll = (taxiAgeSec > 0 && taxiAgeSec < 110) || (!!tm && !tm.taxiConfirmedAt && gsNow >= 2 && gsNow < 14);
      if(earlyRoll && !allowShortEarly){
        const trafficMin = estimateTaxiMinutesForFlight(flight);
        const trafficFloorTs = etdDisplayMinuteTs(now + trafficMin * MIN_MS, now);

        // Minimal lead: pushback / uncertain intent should never show "immediate" ETD.
        let floorLeadMs = (gsNow < 9) ? (4 * MIN_MS) : (3 * MIN_MS);
        const d = Number(flight?.dFromFocusNm);
        if((!tm?.taxiConfirmedAt && taxiAgeSec < 90) || (isFinite(d) && d < 0.45 && taxiAgeSec < 90)){
          floorLeadMs = Math.max(floorLeadMs, 6 * MIN_MS);
        }
        const hardFloorTs = etdDisplayMinuteTs(now + floorLeadMs, now);

        predicted = Math.max(predicted, trafficFloorTs, hardFloorTs);
      }
    }

    // Apply Rapid Roll Cap (again/final) & General Bounds
    if(predicted != null && isFinite(predicted)){
       if(flight && flight.__rapidRunwayRoll){
           predicted = Math.min(predicted, flight.__rapidRunwayRoll);
       }
       predicted = Math.max(now + (ETD_MIN_AHEAD_SEC * 1000), Math.min(now + MAX_AHEAD_MS, predicted));
    }
    return predicted;
  }


  /********************
   * XP Logic (localized labels)
   ********************/
  const atcWeights = { s1:1.00, s2:1.05, s3:1.10, c1:1.15, c2:1.20, c3:1.25, i1:1.30, i2:1.35, i3:1.40, sup:1.45, adm:1.50 };
  const XP_HOURS_CAP = 20000;
  const PILOT_HOURS_FACTOR = 0.85;
  const AGE_BONUS_MAX = 120;
  const AGE_BONUS_CAP_YEARS = 10;
  const AGE_BONUS_MIN_HOURS = 30;
  const AGE_BONUS_FULL_HOURS = 200;
  const AGE_BONUS_MIN_HPY = 6;
  const AGE_BONUS_FULL_HPY = 30;
  const AGE_BONUS_DOMINANCE = 0.35;
  const AGE_BONUS_EXTRA_CAP = 15;

  const XP_LEVELS = {
    new:        { de:"Neu",            en:"New",         sde:"Neu",  sen:"New" },
    starter:    { de:"Einsteiger",     en:"Beginner",    sde:"Einst.", sen:"Beg." },
    advanced:   { de:"Fortgeschritten",en:"Advanced",    sde:"Fortg.", sen:"Adv." },
    experienced:{ de:"Erfahren",       en:"Experienced", sde:"Erf.", sen:"Exp." },
    veteran:    { de:"Veteran",        en:"Veteran",     sde:"Vet.",  sen:"Vet." }
  };

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function smoothstep(edge0, edge1, x){
    if(edge1 <= edge0) return x >= edge1 ? 1 : 0;
    const t0 = clamp01((x - edge0) / (edge1 - edge0));
    return t0 * t0 * (3 - 2 * t0);
  }
  function fmtHours(h){
    if(h == null || !isFinite(h)) return "—";
    if(h < 10) return `${h.toFixed(2)}h`;
    if(h < 100) return `${h.toFixed(1)}h`;
    return `${Math.round(h)}h`;
  }
  function fmtDateUtc(iso){
    try{
      const d = new Date(iso);
      if(!isFinite(d)) return "—";
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth()+1).padStart(2,"0");
      const da = String(d.getUTCDate()).padStart(2,"0");
      return `${y}-${m}-${da}`;
    }catch{ return "—"; }
  }
  function levelLabel(key){
    const L = XP_LEVELS[key] || XP_LEVELS.new;
    return (lang() === "en") ? L.en : L.de;
  }
  function levelShort(key){
    const L = XP_LEVELS[key] || XP_LEVELS.new;
    return (lang() === "en") ? L.sen : L.sde;
  }

  function xpUsesAgeBonus(){
    return !!settings.xpAgeBonusEnabled;
  }


  function normalizedThresholds(th){
    let t1 = clampInt(th?.t1 ?? 20, 1, 99);
    let t2 = clampInt(th?.t2 ?? 40, 2, 100);
    let t3 = clampInt(th?.t3 ?? 60, 3, 100);
    let t4 = clampInt(th?.t4 ?? 80, 4, 100);
    t2 = Math.max(t2, t1+1);
    t3 = Math.max(t3, t2+1);
    t4 = Math.max(t4, t3+1);
    t4 = Math.min(t4, 100);
    t3 = Math.min(t3, t4-1);
    t2 = Math.min(t2, t3-1);
    t1 = Math.min(t1, t2-1);
    return { t1,t2,t3,t4 };
  }

  function levelFromScore(score){
    const {t1,t2,t3,t4} = normalizedThresholds(settings.xpThresholds);
    if(score < t1) return { key:"new", cls:"bad" };
    if(score < t2) return { key:"starter", cls:"warn" };
    if(score < t3) return { key:"advanced", cls:"info" };
    if(score < t4) return { key:"experienced", cls:"good" };
    return { key:"veteran", cls:"good" };
  }

  function computeExperience(details, stats){
    const ageOn = xpUsesAgeBonus();

    // "Missing" (404/Hidden): stats are always required, details only when age bonus is ON
    if(stats === null || (ageOn && details === null)) {
      return {
        levelKey:null, label:t("xp_na"), short:t("xp_na"), cls:"missing", score:null, atcWeighted:null,
        reasons:[t("xp_missing_reasons_1"), t("xp_missing_reasons_2")]
      };
    }

    // "Loading": stats required; details required only when age bonus is ON
    if(!stats || (ageOn && !details)){
      return { levelKey:null, label:"—", short:"—", cls:"info", score:null, atcWeighted:null, reasons:[t("xp_loading")] };
    }

    const pilot = Number(stats.pilot || 0);
    const atc = Number(stats.atc || 0);

    let atcWeighted = 0;
    for(const [k,w] of Object.entries(atcWeights)){
      atcWeighted += Number(stats[k] || 0) * w;
    }

    const atcBonusFactor = 1.20;
    const totalWeightedHours = (pilot * PILOT_HOURS_FACTOR) + (atcWeighted * atcBonusFactor);

    let ageDays = null;
    if(ageOn){
      try{
        const regIso = details?.reg_date;
        if(regIso){
          const reg = new Date(regIso);
          if(isFinite(reg)) ageDays = (Date.now() - reg.getTime()) / 86400000;
        }
      }catch{}
    }

    const totalOnlineHours = pilot + atc;
    const ageYears = (ageDays && ageDays > 0) ? (ageDays / 365.25) : null;
    const baseAgeBonus = (ageOn && ageDays && ageDays > 0)
      ? Math.min(AGE_BONUS_MAX, (Math.log1p(ageDays) / Math.log(1 + (AGE_BONUS_CAP_YEARS * 365))) * AGE_BONUS_MAX) : 0;

    const activityFactor = smoothstep(AGE_BONUS_MIN_HOURS, AGE_BONUS_FULL_HOURS, totalOnlineHours);
    const hoursPerYear = (ageYears && isFinite(ageYears) && ageYears > 0) ? (totalOnlineHours / Math.max(0.25, ageYears)) : 0;
    const densityFactor = smoothstep(AGE_BONUS_MIN_HPY, AGE_BONUS_FULL_HPY, hoursPerYear);
    const dominanceCap = (totalWeightedHours * AGE_BONUS_DOMINANCE) + AGE_BONUS_EXTRA_CAP;
    const ageBonus = ageOn ? Math.max(0, Math.min(baseAgeBonus * activityFactor * densityFactor, dominanceCap)) : 0;

    const raw = totalWeightedHours + ageBonus;
    const score = Math.max(0, Math.min(100, Math.round((Math.log1p(raw) / Math.log(1 + XP_HOURS_CAP)) * 100)));
    const mapped = levelFromScore(score);

    const reasons = [];
    reasons.push(t("xp_reason_pilot", { h: fmtHours(pilot), f: PILOT_HOURS_FACTOR.toFixed(2) }));
    reasons.push(t("xp_reason_atc", { h: fmtHours(atc), f: atcBonusFactor.toFixed(2) }));
    if(ageOn){
      if(ageDays != null) reasons.push(t("xp_reason_reg", { d: fmtDateUtc(details?.reg_date) }));
      else reasons.push(t("xp_reason_reg_missing"));
    }else{
      reasons.push(t("xp_reason_reg_disabled"));
    }

    return { levelKey:mapped.key, label: levelLabel(mapped.key), short: levelShort(mapped.key), cls:mapped.cls, score, atcWeighted, reasons };
  }

  function experienceTooltipText(cid, details, stats, exp){
    if(exp && exp.cls === 'missing') return t("xp_missing_tip");
    const lines = [];
    lines.push(t("tooltip_header", { cid: cid ?? details?.id ?? "—", score: exp?.score ?? "—", label: exp?.label ?? "" }));
    if(xpUsesAgeBonus()){
      lines.push(t("tooltip_reg", { d: details?.reg_date ? fmtDateUtc(details.reg_date) : "—" }));
    }else{
      lines.push(t("tooltip_reg_off"));
    }
    if(stats){
      lines.push(t("tooltip_hours", { p: fmtHours(stats.pilot), a: fmtHours(stats.atc) }));
    }
    return lines.join("\n");
  }

  function rebuildLegend(){
    const {t1,t2,t3,t4} = normalizedThresholds(settings.xpThresholds);
    const noteKey = xpUsesAgeBonus() ? "legend_note_age_on" : "legend_note_age_off";
    legendContent.innerHTML = `
      <span class="legendTitle">${escapeHtml(t("legend_title"))}</span>
      <span class="xpPill bad" style="cursor:default"><span class="xDot"></span><span class="lvl">${escapeHtml(levelShort("new"))}</span><span class="score">0–${t1-1}</span></span>
      <span class="xpPill warn" style="cursor:default"><span class="xDot"></span><span class="lvl">${escapeHtml(levelShort("starter"))}</span><span class="score">${t1}–${t2-1}</span></span>
      <span class="xpPill info" style="cursor:default"><span class="xDot"></span><span class="lvl">${escapeHtml(levelShort("advanced"))}</span><span class="score">${t2}–${t3-1}</span></span>
      <span class="xpPill good" style="cursor:default"><span class="xDot"></span><span class="lvl">${escapeHtml(levelShort("experienced"))}</span><span class="score">${t3}–${t4-1}</span></span>
      <span class="xpPill good" style="cursor:default"><span class="xDot"></span><span class="lvl">${escapeHtml(levelShort("veteran"))}</span><span class="score">${t4}–100</span></span>
      <span class="xpPill missing" style="cursor:default"><span class="xDot"></span><span class="lvl">${escapeHtml(t("xp_na"))}</span></span>
      <span class="legendNote">${escapeHtml(t(noteKey))}</span>
    `;
  }

  /********************
   * FIDS Logic
   ********************/
  function parseClockHHMM(s){
    const tt = (s||"").trim();
    if(!/^\d{4}$/.test(tt)) return null;
    const hh = Number(tt.slice(0,2));
    const mm = Number(tt.slice(2,4));
    if(hh>23 || mm>59) return null;
    return hh*60 + mm;
  }
  function parseDurationHHMM(s){
    const tt = (s||"").trim();
    if(!/^\d{4}$/.test(tt)) return null;
    const hh = Number(tt.slice(0,2));
    const mm = Number(tt.slice(2,4));
    if(mm>59) return null;
    return hh*60 + mm;
  }
  function clockMinToTsNearFuture(refMinOfDay, refMs=Date.now(), maxPastMin=180){
    if(refMinOfDay == null) return null;
    const base = utcDayStartMs(refMs);
    let ts = base + refMinOfDay * 60000;
    const diff = ts - refMs;
    if(diff < -12*3600*1000) ts += DAY_MS;
    else if(diff > 12*3600*1000) ts -= DAY_MS;
    if(ts < refMs - maxPastMin*60000) ts += DAY_MS;
    return ts;
  }
  function plannedStdTs(deptimeHHMM, refMs=Date.now()){
    const m = parseClockHHMM(deptimeHHMM);
    return m == null ? null : clockMinToTsNearFuture(m, refMs, 240);
  }
  function plannedEtaTs(stdTs, enrouteHHMM){
    const durMin = parseDurationHHMM(enrouteHHMM);
    if(stdTs == null || durMin == null) return null;
    return stdTs + durMin*60000;
  }

  function altGsText(p){
    const rawAlt = (p.altitude ?? null);
    const gs = (p.groundspeed ?? null);
    const alt = rawAlt != null ? Math.round(rawAlt / 100) * 100 : null;
    const a = (alt != null) ? String(alt).padStart(5," ") : "  —  ";
    const g = (gs != null) ? String(Math.round(gs)).padStart(3," ") : "—";
    return `${a} / ${g}`;
  }

  function escapeHtml(s){
    return String(s ?? "").replace(/[&<>"']/g, (c) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
  }

  // Status Helpers
  let prevPilotStates = new Map();
  let statusMemory = new Map();
  const takeoffMem = new Map(); // cid -> { until, lastSeen }
  // Lineup memory (per CID)
  const lineupMem = new Map(); // cid -> { until, lastSeen, rwy }
  function markLineup(cid, rwy){
    const now = Date.now();
    // Only store a valid runway designator string; otherwise store "true" (lineup w/o rwy)
    const norm = (typeof rwy === "string") ? normalizeRunwayDesignator(rwy) : null;
    lineupMem.set(String(cid), { until: now + LINEUP_HOLD_MS, lastSeen: now, rwy: norm || true });
        flagStateDirty();
  }
  function getLineupHeld(cid){
    const e = lineupMem.get(String(cid));
    if(!e) return null;
    const now = Date.now();
    e.lastSeen = now;
    if(e.until && e.until > now) return e.rwy ?? true;
    return null;
  }
  function pruneLineupMem(){
    const now = Date.now();
    for(const [cid, e] of lineupMem.entries()){
      if(!e?.lastSeen || (now - e.lastSeen) > LINEUP_MEM_TTL_MS) lineupMem.delete(cid);
    }
  }

  // Phase groups (used to prevent noisy regressions, e.g. DEPARTING -> TAKEOFF)
  const AIRBORNE_PHASES = new Set(["DEPARTING","CLIMB","CRUISE","DESCENT","APPROACH","FINAL","GOAROUND","DEPAREA"]);
  const GROUND_PHASES   = new Set(["GATE","TAXI","TAKEOFF","PREFILE","LOCAL"]);
  function isAirbornePhase(phase){ return AIRBORNE_PHASES.has(String(phase || "").toUpperCase()); }
  function isGroundPhase(phase){ return GROUND_PHASES.has(String(phase || "").toUpperCase()); }

  // Detect "LINEUP" for departures at the focus airport.
  // Returns: runway designator string (e.g. "26L"), true (lineup but no designator), or null.
  function detectDepartureLineupRwy(p, fp, focusIcao){
    try{
      if(!p || !fp) return null;
      const gs = Number(p.groundspeed || 0);
      if(!isFinite(gs) || gs > LINEUP_GS_MAX_KTS) return null;
      const lat = Number(p.latitude), lon = Number(p.longitude);
      if(!isFinite(lat) || !isFinite(lon)) return null;

    // 1. HOT ZONE LOGIC (Pre-Calculated Lineup Segments)
    // This handles long taxiways and complex intersections correctly.
    const hotZones = hotZoneIndexByIcao.get(normalizeCode(focusIcao));
    if(hotZones){
      for(const zone of hotZones){
        // Simple Distance Check to the Lineup Segment (Holding Point <-> Runway Intersection)
        const proj = projectPointToSegment(lat, lon, zone.hpLat, zone.hpLon, zone.intLat, zone.intLon);

        // Inside the HotZone? (Buffer e.g. 25m lateral to the line)
        if(proj.dist <= HOTZONE_DIST_M){
           const planeHdg = Number(p.heading || 0);

           // Logic: Angle Difference to Runway
           const diff = angleDiffDeg(planeHdg, zone.rwyHdg);
           const diffOpp = angleDiffDeg(planeHdg, (zone.rwyHdg + 180) % 360);
           const align = Math.min(diff, diffOpp);

           // CROSSING: Heading is roughly perpendicular (+/- 45 deg to 90) -> 45..135 deg off axis
           // Actually, simpler: if alignment is > 45, it is NOT a lineup.
           if(align > 45){
             // It's a Crossing -> Status remains TAXI (return null)
             return null;
           }

           // LINEUP: Heading approximates Runway (< 30 deg)
           if(align < 35 || (proj.t > 0.8 && align < 50)){
             return zone.rwyDes;
           }
        }
      }
    }

    // Fallback: Existing Logic (Runway Proximity + Axis)
    // This handles cases where HotZone pre-calc might miss (e.g. backtracking)


      const icao = normalizeCode(focusIcao || "");
      if(!icao) return null;

      const rIdx = runwayIndexByIcao.get(icao) || null;
      if(!rIdx){
        // kick async load (non-blocking); next refresh will have it
        ensureRunwayIndexForIcao(icao).catch(()=>{});
        return null;
      }

      // Build a minimal flight wrapper for the runway targeting logic
      const f = {
        cid: String(p.cid),
        pilot: p,
        fp,
        flight_plan: fp,
        aircraft: fp?.aircraft_short || fp?.aircraft || ""
      };
      const tgt = getRunwayTargetForFlight(f, rIdx);
      if(!tgt) return null;

      // Must be tightly on runway axis.
      // NOTE: Do NOT rely on f.rwOnAxisTight here (it intentionally excludes runway ends via proj.t > 0.03),
      // which caused missed lineups close to the threshold.
      const latM = Number(f.rwEntryLateralM);
      if(!isFinite(latM) || latM > LINEUP_ON_AXIS_M) return null;

      // Direction check with robust fallback:
      // - Prefer "takeoff direction away from threshold" (f.rwTrackAway)
      // - If heading is noisy and we are very close to the threshold, accept aligned-in-either-direction.
      const axisBrg = Number(f.rwAxisBrg);
      const trackBrg = Number(f.rwTrackBrg);
      const nearThr = isFinite(f.rwDistM) ? (Number(f.rwDistM) <= 180) : false;
      if(!f.rwTrackAway){
        if(!(isFinite(axisBrg) && isFinite(trackBrg))) return null;
        const dA = angleDiffDeg(trackBrg, axisBrg);
        const dO = angleDiffDeg(trackBrg, (axisBrg + 180) % 360);
        const alignedEither = Math.min(dA, dO) <= ETD_ON_RUNWAY_ALIGN_DEG;
        if(!(nearThr && alignedEither)) return null;
      }

      // Only return valid runway designators for display; otherwise fall back to generic LINEUP.
      const desNorm = normalizeRunwayDesignator(tgt.designator);
      return desNorm || true;
    }catch{
      return null;
    }
  }
  function markTakeoff(cid){
    const now = Date.now();
    takeoffMem.set(String(cid), { until: now + TAKEOFF_HOLD_MS, lastSeen: now });
    flagStateDirty();
    // RECORD TAXI TIME
    // If we have a taxi record for this CID, finalize it now.
    const tm = taxiMem.get(String(cid));
    // Only record if we explicitly saw the flight stationary at a gate (wasAtGate)
    if(tm && tm.taxiSince && tm.gateLat && tm.wasAtGate) {
        const duration = now - tm.taxiSince;
        // Try to get runway from lineup mem or current location
        const rwy = getLineupHeld(cid) || (typeof cid === 'string' /* placeholder */ ? null : null);
        // We don't have explicit Rwy here easily without looking up targets again, but we can pass null to let manager guess or simple store.
        TaxiTimeManager.record(currentAirportIcao, tm.gateLat, tm.gateLon, (typeof rwy === 'string' ? rwy : null), duration);
    }
  }
  function isTakeoffHeld(cid){
    const e = takeoffMem.get(String(cid));
    if(!e) return false;
    const now = Date.now();
    e.lastSeen = now;
    return (e.until && e.until > now);
  }
  function pruneTakeoffMem(){
    const now = Date.now();
    for(const [cid, e] of takeoffMem.entries()){
      if(!e?.lastSeen || (now - e.lastSeen) > TAKEOFF_MEM_TTL_MS) takeoffMem.delete(cid);
    }
  }
  const STATUS_BANDS = { NEAR_APT_NM: 7, APPROACH_ENTER_NM: 55, APPROACH_EXIT_NM: 82, FINAL_ENTER_NM: 10, FINAL_EXIT_NM: 18, DEPAREA_ENTER_NM: 25, DEPAREA_EXIT_NM: 40 };

  function computeVerticalRateFpm(prev, curAlt, curT){
    if(!prev || prev.alt == null || prev.t == null) return null;
    const dt = (curT - prev.t) / 1000;
    if(!isFinite(dt) || dt <= 2) return null;
    return ((Number(curAlt) - Number(prev.alt)) / dt) * 60;
  }
  function statusKey(cid, boardType){ return `${boardType}:${String(cid)}`; }

  function stabilizeStatus(key, candidate){
    const now = Date.now();
    const sig = `${candidate.phase}|${candidate.rank}|${candidate.text}|${candidate.cls}|${candidate.finished?1:0}`;
    const dwellMs = Math.max(9000, Math.min(45000, Math.round((settings.feedIntervalMs || 15000) * 0.9)));
    let mem = statusMemory.get(key);
    if(!mem){
      mem = { status: candidate, sig, lastChange: now, lastSeen: now, pendSig: null, pendCount: 0 };
      statusMemory.set(key, mem);
      return candidate;
    }
    const curPhase = mem?.status?.phase || null;
    if(curPhase && isAirbornePhase(curPhase) && isGroundPhase(candidate.phase) && !candidate.finished){
      return mem.status;
    }
    mem.lastSeen = now;
    if(sig === mem.sig){ mem.pendSig = null; mem.pendCount = 0; return mem.status; }
    if(candidate.finished || mem.status.finished){
      mem.status = candidate; mem.sig = sig; mem.lastChange = now; mem.pendSig = null; mem.pendCount = 0;
      return candidate;
    }
    const withinDwell = (now - mem.lastChange) < dwellMs;
    const strongerChange = candidate.rank < mem.status.rank;
    if(withinDwell && !strongerChange) return mem.status;

    if(mem.pendSig === sig) mem.pendCount++;
    else { mem.pendSig = sig; mem.pendCount = 1; }

    const need = strongerChange ? 1 : 2;
    if(mem.pendCount >= need){
      mem.status = candidate; mem.sig = sig; mem.lastChange = now; mem.pendSig = null; mem.pendCount = 0;
      return candidate;
    }
    return mem.status;
  }

  function pruneStatusMemory(){
    const now = Date.now();
    const ttl = 20 * 60 * 1000;
    for(const [k,v] of statusMemory.entries()){ if(!v?.lastSeen || (now - v.lastSeen) > ttl) statusMemory.delete(k); }
    pruneArrActualTimeMem();
        pruneTakeoffMem();
        pruneLineupMem();
  }

  function statusTxt(key, vars){ return t(`status_${key}`, vars); }

  function classifyFlight(p, boardType){
    const fp = p.flight_plan;
    const dep = normalizeCode(fp?.departure || "");
    const arr = normalizeCode(fp?.arrival || "");
    const focusIcao = normalizeCode(currentAirportIcao || "");
    const depAp = getAirport(dep);
    const arrAp = getAirport(arr);
    const lat = Number(p.latitude);
    const lon = Number(p.longitude);
    const alt = Number(p.altitude || 0);
    const gs  = Number(p.groundspeed || 0);
    const hdg = Number(p.heading || 0);
    const nowT = Date.now();
    const prev = prevPilotStates.get(String(p.cid));
    const vr = computeVerticalRateFpm(prev, alt, nowT);
    const absVr = (vr == null) ? null : Math.abs(vr);
    const climbing  = (vr != null && vr > 350);
    const descending = (vr != null && vr < -350);

    const dDep = (depAp ? haversineNm(lat, lon, depAp.latitude, depAp.longitude) : null);
    const dArr = (arrAp ? haversineNm(lat, lon, arrAp.latitude, arrAp.longitude) : null);

    // SMART GROUND LOGIC (Elevation Aware)
    let groundRef = 0;
    if(depAp && dDep != null && dDep < 15) groundRef = depAp.elevation;
    else if(arrAp && dArr != null && dArr < 15) groundRef = arrAp.elevation;

    const isGroundAlt = groundRef > 0 ? (alt < (groundRef + 350)) : (alt < 1500);
    // Robust on-ground detection:
    let onGround = (gs < 45 && isGroundAlt);
    if(isGroundAlt){
      // If vertical-rate is available and small: treat as ground even at high GS (takeoff/landing roll).
      if(absVr != null && absVr < 260 && gs < 220){
        onGround = true;
      }else{
        // If we were ground-alt a moment ago and are not clearly climbing yet, keep ground state (prevents TAXI->DEPARTING flicker).
        const prevAlt = prev ? Number(prev.alt) : null;
        const prevGroundAlt = (prevAlt != null && isFinite(prevAlt))
          ? (groundRef > 0 ? (prevAlt < (groundRef + 350)) : (prevAlt < 1500))
          : false;
        if(prevGroundAlt && !climbing && gs < 165) onGround = true;
      }
    }
    const airborne = !onGround;

    const nearDep = (dDep != null && dDep < STATUS_BANDS.NEAR_APT_NM);
    const nearArr = (dArr != null && dArr < STATUS_BANDS.NEAR_APT_NM);
    // Surface association should be more forgiving than "near" (prevents bad flips on large airports)
    const surfaceDep = (dDep != null && dDep < 15);
    const surfaceArr = (dArr != null && dArr < 15);
  // Fix for phantom departures:
  const arrMem = arrActualTimeMem.get(String(p.cid));
  const recentlyLandedHere = arrMem && arrMem.aldtTs && (nowT - arrMem.aldtTs) < 45 * 60 * 1000; // 45 min grace after landing

  // If tracking as departure, but we know it just landed here AND flight plan hasn't changed (still pointing to this apt as dest), skip.
  if(boardType === "dep" && recentlyLandedHere && arr === focusIcao && dep !== focusIcao) return { phase:"UNK", rank:99, text:"—", cls:"hidden", finished:true };
    // Local flight (DEP==ARR==focus): treat ARR-board ground state carefully (avoid immediate "LANDED")
    const isLocalAtFocus = !!(focusIcao && dep === focusIcao && arr === focusIcao);
    const localState = updateLocalFlightState(p.cid, { isLocal: isLocalAtFocus, airborne, onGround });
    p.__isLocal = isLocalAtFocus;
    const key = statusKey(p.cid, boardType);
    const prevStable = statusMemory.get(key)?.status || null;
    const prevPhase = prevStable?.phase || null;
    const approachBand = (prevPhase === "APPROACH" || prevPhase === "FINAL" || prevPhase === "GOAROUND") ? STATUS_BANDS.APPROACH_EXIT_NM : STATUS_BANDS.APPROACH_ENTER_NM;
    const finalBand = (prevPhase === "FINAL") ? STATUS_BANDS.FINAL_EXIT_NM : STATUS_BANDS.FINAL_ENTER_NM;
    const depBand = (prevPhase === "DEPARTING" || prevPhase === "CLIMB") ? STATUS_BANDS.DEPAREA_EXIT_NM : STATUS_BANDS.DEPAREA_ENTER_NM;
    const inApproachZone = (dArr != null && dArr <= approachBand);
    const inFinalZone    = (dArr != null && dArr <= finalBand);
    const inDepZone      = (dDep != null && dDep <= depBand);
    const stableCruise = airborne && alt >= 20000 && gs >= 140 && (absVr == null || absVr < 350) && !(inApproachZone);

    const finalCeiling = dArr != null ? Math.max(1800, Math.min(9500, dArr*330 + 1100)) : 5000;
    const finalOk = airborne && inFinalZone && gs >= 80 && alt <= finalCeiling && (descending || (vr != null && vr < -200) || alt <= 3500);

    const approachOk = airborne && inApproachZone && gs >= 80 && (descending || alt <= 16000 || (dArr != null && dArr < 35 && alt <= 21000));
    const goAroundOk = airborne && inApproachZone && climbing && alt <= 11000 && gs >= 90;

    function divertText(){
      const nearest = findNearestAirport(lat, lon, 10);
      if(nearest){
        if(nearest.ap.icao && nearest.ap.icao !== arr && nearest.ap.icao !== dep) return statusTxt("diverted_at", { icao: nearest.ap.icao });
        return statusTxt("on_ground_at", { icao: nearest.ap.icao });
      }
      return statusTxt("on_ground_unknown");
    }

    // Pre-compute departure lineup hint (used to render "LINEUP RWY xx" instead of plain TAXI).
    let depLineupHeld = null; // string designator | true | null
    if(boardType === "dep" && onGround && focusIcao && dep === focusIcao){
      const rwy = detectDepartureLineupRwy(p, fp, focusIcao);
      if(rwy){
        markLineup(p.cid, rwy === true ? null : rwy);
        depLineupHeld = rwy;
      }else{
        const held = getLineupHeld(p.cid);
        if(held) depLineupHeld = held;
      }
    }

let gateLabel = null;
let gateIcaoForThis = null;
let groundState = null; // { isStationary, taxiSure, uncertain }
let taxiInfo = null;

try{
  const focusIcao = currentAirportIcao;

  // Welche Airport-Gates sollen wir matchen?
  if(onGround){
    if(boardType === "dep" && dep === focusIcao && surfaceDep){
      gateIcaoForThis = focusIcao; // Departures: Gate am Fokus-Airport
    }else if(boardType === "arr" && arr === focusIcao){
      if(surfaceArr){
        gateIcaoForThis = focusIcao; // Arrivals: Gate am Ziel (Fokus)
      }else if(surfaceDep){
        gateIcaoForThis = dep;       // Arrivals: noch am Origin → Gate am Origin
      }
    }
  }

  if(gateIcaoForThis){
    const idx = gateIndexByIcao.get(gateIcaoForThis) || null;
if(idx){
  const r = resolveGateForCid(p.cid, lat, lon, gs, idx, gateIcaoForThis);
  gateLabel = r?.gate ? r.gate.label : null;
  groundState = r?.ground || null;
}else{
  // async laden, nächster Refresh hat Gate-Daten
  ensureGateIndexForIcao(gateIcaoForThis).catch(()=>{});
  // trotzdem Samples weiter füttern (für Stationary/Hysterese + Cache-Gate)
  const r = resolveGateForCid(p.cid, lat, lon, gs, null, gateIcaoForThis);
  gateLabel = r?.gate ? r.gate.label : null;       // wichtig: Cache-Gate kann schon da sein
  groundState = r?.ground || null;
}
  }else{
    // Samples weiterführen, wenn wir “fast” am Airport sind (gegen Flattern)
    if(onGround){
      const keepIcao =
        (dep === focusIcao && dDep != null && dDep < 3) ? focusIcao :
        (arr === focusIcao && dArr != null && dArr < 3) ? focusIcao :
        null;
      if(keepIcao){
        const idx = gateIndexByIcao.get(keepIcao) || null;
        resolveGateForCid(p.cid, lat, lon, gs, idx, keepIcao);
      }
    }
  }
}catch{}

// Taxiway-based taxi logic (with fallback/hysteresis)
try{
  if(onGround && gateIcaoForThis && isFinite(lat) && isFinite(lon) && isFinite(gs)){
    const tIdx = taxiwayIndexByIcao.get(gateIcaoForThis) || null;
    if(!tIdx){
      // async load, fallback will still work via "moving-on-ground" confirm
      ensureTaxiwayIndexForIcao(gateIcaoForThis).catch(()=>{});
    }
    taxiInfo = resolveTaxiStatusForCid(
      p.cid,
      lat, lon, gs,
      { onGround, isStationary: !!groundState?.isStationary, taxiSure: !!groundState?.taxiSure },
      tIdx,
      gateIcaoForThis
    );
  }else{
    // still keep TTL state around
    const m = taxiMem.get(String(p.cid));
    if(m) m.lastSeen = Date.now();
  }
}catch{}

    // Arrivals: update ALDT/AIBT memory using the already computed gate/ground hints.
    // - "landed" when onGround + surfaceArr at focus airport
    // - "in-block" when stationary at a resolved gate (position)
    if(boardType === "arr"){
      const focus = normalizeCode(currentAirportIcao || "");
      if(focus && arr === focus){
        const landedHere = !!(onGround && surfaceArr && (!isLocalAtFocus || localState?.hasAirborne));
        const inBlockHere =
          landedHere &&
          !!groundState?.isStationary &&
          !!gateLabel &&
          !groundState?.taxiSure &&
          !taxiInfo?.taxiActive;
        updateArrActualTimesForPilot(p, { isLandedAtFocus: landedHere, isInBlockAtFocus: inBlockHere });
      }
    }

    let cand = { phase:"UNK", rank:99, text:"—", cls:"info", finished:false };

    if(boardType === "dep"){
      if(p.__prefile) cand = { phase:"PREFILE", rank:0, text: statusTxt("prefile"), cls:"info", finished:false };
else if(onGround && surfaceDep){
  const tm = taxiInfo?.mem || taxiMem.get(String(p.cid)) || null;

  // If we're clearly parked at a gate for a while, release any prior taxi latch.
  // This allows "pushback abort" or "back to stand" to return to GATE reliably.
  if(tm){
    const gateHoldOk = !!groundState?.isStationary && !!gateLabel && isFinite(gs) && gs <= (STATIONARY_MAX_GS_KTS + 1.5);
    if(gateHoldOk){
      if(!tm.gateHoldSince) tm.gateHoldSince = nowT;
      if((nowT - tm.gateHoldSince) >= DEP_TAXI_GATE_RESET_MS){
        tm.depTaxiUntil = 0;
        tm.lastTaxiTs = 0;
        tm.taxiStickyUntil = 0;
        tm.taxiSince = 0;
      }
    }else{
      tm.gateHoldSince = 0;
    }
  }

  // "Rolling" must always win over "at gate" to avoid Taxi <-> Gate flapping.
  const rolling = isFinite(gs) && gs >= DEP_TAXI_ROLLING_GS_KTS;

  // Long latch through stop-and-go queues until takeoff (unless explicitly parked at a gate as above).
  const taxiLatched = !!(tm && (
    (tm.depTaxiUntil && tm.depTaxiUntil > nowT) ||
    (tm.lastTaxiTs && (nowT - tm.lastTaxiTs) < DEP_TAXI_LATCH_MS)
  ));

  const taxiActive = rolling || !!groundState?.taxiSure || !!taxiInfo?.taxiActive || taxiLatched;

  // Extend latch while taxiing (covers long queues even with intermittent low GS or stops).
  if(tm && taxiActive){
    tm.depTaxiUntil = nowT + DEP_TAXI_LATCH_MS;
  }

  const atGateSure = !!groundState?.isStationary && !!gateLabel && !taxiActive;

  if(taxiActive){
    cand = { phase:"TAXI", rank:0, text: statusTxt("taxi"), cls:"info", finished:false };
  }else{
    // Flag flight as "Started at Gate" for Taxi History recording
    if(atGateSure && tm){
       tm.wasAtGate = true;
       tm.gateLat = lat;
       tm.gateLon = lon;
    }
    const txt = atGateSure
      ? statusTxt("gate_named", { gate: gateLabel })
      : (gateLabel ? statusTxt("gate_named", { gate: gateLabel }) : statusTxt("gate_plain"));
    cand = { phase:"GATE", rank:0, text: txt, cls:"info", finished:false };
  }
}
      else if(airborne && nearDep){
        // Optional Takeoff status: if we were taxiing for a while, and now speed/alt increase
        const tm = taxiInfo?.mem || taxiMem.get(String(p.cid)) || null;
        const agl = (groundRef > 0) ? (alt - groundRef) : alt;
        const fromTaxiRecently =
          tm && tm.lastTaxiTs && (nowT - tm.lastTaxiTs) <= TAKEOFF_FROM_TAXI_GRACE_MS &&
          tm.taxiSince && (nowT - tm.taxiSince) >= TAKEOFF_TAXI_MIN_MS;
        // New: High-Speed Takeoff Logic
        let rwCtx = null;
        if(focusIcao && dep === focusIcao){
          const rIdx = runwayIndexByIcao.get(focusIcao);
          if(rIdx) {
            const tmp = { cid: String(p.cid), pilot: p, fp };
            getRunwayTargetForFlight(tmp, rIdx); // populates tmp with rw... props
            rwCtx = tmp;
          }
        }

        // If > 60kts on runway -> TAKEOFF.
        const onRunwayStrong = !!(rwCtx && (rwCtx.rwOnAxisStrict || rwCtx.rwRollingOnAxis));
        const highSpeedTakeoff = onRunwayStrong && gs > 60;

        // High-Speed Entry Logic (>30kts, aligned, accelerating)
        // If entering >30kts, we want LINEUP, *unless* accelerating for takeoff.
        const accel = (prev && isFinite(prev.gs)) ? (gs - prev.gs) : 0;
        const aligned = rwCtx && rwCtx.rwTrackAlignedAxis; // < 35 deg deviation
        const fastTakeoffEntry = onRunwayStrong && gs > 30 && aligned && (accel > 0.5 || fromTaxiRecently);
                const takeoffOk =
                 highSpeedTakeoff ||
          fastTakeoffEntry ||
          (
            fromTaxiRecently &&
            isFinite(agl) && agl >= 0 && agl <= TAKEOFF_MAX_AGL_FT &&
            isFinite(gs) && gs >= TAKEOFF_GS_KTS &&
            (climbing || (vr != null && vr > 200) || agl > 80)
          );

        // Also trigger TAKEOFF when we JUST transitioned from TAXI (even if nearDep is noisy)
        const memEntry = statusMemory.get(key) || null;
        const prevTaxiRecently =
          (prevPhase === "TAXI") &&
          memEntry?.lastChange &&
          (nowT - memEntry.lastChange) <= (2.5 * 60 * 1000) &&
          isFinite(agl) && agl >= 0 && agl <= (TAKEOFF_MAX_AGL_FT + 900) &&
          isFinite(gs) && gs >= 60 &&
          (climbing || (vr != null && vr > 120) || agl > 120);

        const held = isTakeoffHeld(p.cid);
        if(takeoffOk || prevTaxiRecently || held){
          if(takeoffOk || prevTaxiRecently) markTakeoff(p.cid);
          cand = { phase:"TAKEOFF", rank:1, text: statusTxt("takeoff"), cls:"warn", finished:false };
        }else{
          // IMPORTANT: avoid "—" between TAXI -> (TAKEOFF/DEPARTING). This branch is hit first,
          // so we must set a sensible fallback status when the takeoff heuristic doesn't trigger.
          if(alt < 7000) cand = { phase:"DEPARTING", rank:1, text: statusTxt("departing"), cls:"warn", finished:false };
          else cand = { phase:"CLIMB", rank:1, text: statusTxt("climb"), cls:"warn", finished:false };
        }
      }
      else if(airborne && inDepZone){
        // If TAKEOFF was shown recently, keep it briefly even if nearDep condition is missed.
        if(isTakeoffHeld(p.cid)){
          cand = { phase:"TAKEOFF", rank:1, text: statusTxt("takeoff"), cls:"warn", finished:false };
        }else{
        if(alt < 7000) cand = { phase:"DEPARTING", rank:1, text: statusTxt("departing"), cls:"warn", finished:false };
        else cand = { phase:"CLIMB", rank:1, text: statusTxt("climb"), cls:"warn", finished:false };
                }
      }
      else if(airborne){
        if(goAroundOk) cand = { phase:"GOAROUND", rank:3, text: statusTxt("goaround"), cls:"warn", finished:false };
        else if(finalOk) cand = { phase:"FINAL", rank:3, text: statusTxt("final"), cls:"warn", finished:false };
        else if(approachOk) cand = { phase:"APPROACH", rank:3, text: statusTxt("approach"), cls:"warn", finished:false };
        else if(descending && alt < 30000) cand = { phase:"DESCENT", rank:3, text: statusTxt("descent"), cls:"warn", finished:false };
        else if(stableCruise) cand = { phase:"CRUISE", rank:2, text: statusTxt("cruise"), cls:"good", finished:false };
        else {
          if(prevPhase === "APPROACH" && dArr != null && dArr < STATUS_BANDS.APPROACH_EXIT_NM) cand = { phase:"APPROACH", rank:3, text: statusTxt("approach"), cls:"warn", finished:false };
          else cand = { phase:"CRUISE", rank:2, text: statusTxt("cruise"), cls:"good", finished:false };
        }
      }
      else {
        cand = { phase:"FINISHED", rank:4, text: nearArr ? statusTxt("landed_dest") : divertText(), cls: nearArr ? "good" : "bad", finished:true };
      }
    } else {
      if(p.__prefile) cand = { phase:"PREFILE", rank:6, text: statusTxt("prefile"), cls:"info", finished:false };
      else if(airborne){
        if(goAroundOk) cand = { phase:"GOAROUND", rank:0, text: statusTxt("goaround"), cls:"warn", finished:false };
        else if(finalOk) cand = { phase:"FINAL", rank:0, text: statusTxt("final"), cls:"warn", finished:false };
        else if(approachOk) cand = { phase:"APPROACH", rank:0, text: statusTxt("approach"), cls:"warn", finished:false };
        else if(descending && alt < 30000 && dArr != null && dArr < 180) cand = { phase:"DESCENT", rank:1, text: statusTxt("descent"), cls:"info", finished:false };
        else if(stableCruise) cand = { phase:"CRUISE", rank:1, text: statusTxt("cruise"), cls:"good", finished:false };
        else if(airborne && dDep != null && dDep < depBand && (climbing || alt < 18000)) cand = { phase:"DEPAREA", rank:2, text: statusTxt("deparea"), cls:"info", finished:false };
        else cand = { phase:"CRUISE", rank:1, text: statusTxt("cruise"), cls:"good", finished:false };
      } else {
  if(surfaceArr && !(isLocalAtFocus && !localState?.hasAirborne)){
    // gelandet am Ziel (Fokus)
    cand = {
      phase:"FINISHED",
      rank:3,
      text: gateLabel ? statusTxt("landed_gate", { gate: gateLabel }) : statusTxt("landed"),
      cls:"good",
      finished:true
    };
} else if(surfaceDep) {
  const taxiActive = !!taxiInfo?.taxiActive || !!groundState?.taxiSure;
  const atGateSure = !!groundState?.isStationary && !taxiActive;

  let txt;
   if(taxiActive){
    txt = statusTxt("taxi");
  }else if(atGateSure){
    // NUR wenn Gate angezeigt wird: "@ICAO" anhängen (Requirement)
    txt = gateLabel
      ? statusTxt("gate_named_at", { gate: gateLabel, icao: dep })
      : statusTxt("gate_plain_at", { icao: dep }); // <- fallback: "Am Gate @ICAO"
  }else{
    txt = statusTxt("gate"); // Fallback: Am Gate / Taxi
  }

  cand = { phase:"GATE", rank:6, text: txt, cls:"info", finished:false };
}
 else {
    // irgendwo am Boden (divert/unknown)
    cand = { phase:"FINISHED", rank:3, text: divertText(), cls:"info", finished:true };
  }
}

}
    if(boardType === "dep" && onGround && cand && String(cand.phase || "").toUpperCase() === "TAXI"){
      const rwy = depLineupHeld;
      if(rwy){
        cand.text = (rwy === true)
          ? statusTxt("lineup")
          : statusTxt("lineup_rwy", { rwy: rwy });
        // A subtle visual hint: treat as "info" (keeps TAXI coloring stable if you prefer; safe to override)
        if(cand.cls === "warn") cand.cls = "info";
      }
    }
    return stabilizeStatus(key, cand);
  }

  // ETA Logic
  let etaMemory = new Map();
  function etaKey(cid, boardType){ return `eta:${boardType}:${String(cid)}`; }
  function computeTrackSpeedKts(prev, lat, lon, nowMs){
    if(!prev || prev.lat==null || prev.lon==null || !prev.t) return null;
    const dtH = (nowMs - prev.t) / 3600000;
    if(!isFinite(dtH) || dtH < 0.0025) return null;
    const kts = haversineNm(lat, lon, prev.lat, prev.lon) / dtH;
    if(!isFinite(kts) || kts < 30 || kts > 750) return null;
    return kts;
  }
  function stabilizeEta(key, candTs, phase){
  const now = Date.now();
  let mem = etaMemory.get(key);

    if(candTs == null || !isFinite(candTs)){
      if(mem && (now - mem.lastSeen) < 2*60*1000){ mem.lastSeen = now; return mem.etaTs; }
      return null;
    }

  const curPhase = phase || "UNK";

    // Never show ETAs in the past (prevents sudden "jump backwards" artifacts).
    const minEta = now + MIN_MS;
    if(isFinite(candTs)) candTs = Math.max(candTs, minEta);

    if(!mem){
      mem = { etaTs: candTs, lastSeen: now, phase: curPhase };
      etaMemory.set(key, mem);
      return candTs;
    }

  mem.lastSeen = now;

  const prev = mem.etaTs;
  const prevPhase = mem.phase || "UNK";

    // Snap on ground/prefile/finished transitions (keeps the display stable when switching modes)
    const snapPhase = (x) => (x==="GATE" || x==="TAXI" || x==="PREFILE" || x==="FINISHED");
    if(prevPhase !== curPhase && (snapPhase(prevPhase) || snapPhase(curPhase))){
      mem.etaTs = candTs;
      mem.phase = curPhase;
      return candTs;
    }

    // If previous ETA is clearly stale (e.g. switched aircraft/plan), snap.
    if(isFinite(prev) && prev < (now - 5*60*1000) && candTs > (now + 10*60*1000)){
      mem.etaTs = candTs;
      mem.phase = curPhase;
      return candTs;
    }

    // Phase-aware smoothing: especially after takeoff, raw estimates can swing wildly.
    let alpha = 0.20;
    let maxJump = 5 * MIN_MS;
    if(curPhase === "TAKEOFF" || curPhase === "DEPARTING" || curPhase === "CLIMB"){
      alpha = 0.10;
      maxJump = 2.0 * MIN_MS;
    }else if(curPhase === "CRUISE"){
      alpha = 0.24;
      maxJump = 6.0 * MIN_MS;
    }else if(curPhase === "DESCENT" || curPhase === "APPROACH" || curPhase === "FINAL" || curPhase === "GOAROUND"){
      alpha = 0.16;
      maxJump = 4.0 * MIN_MS;
    }

    // Additional guard: huge spikes right after takeoff are treated as outliers.
    if((curPhase === "TAKEOFF" || curPhase === "DEPARTING" || curPhase === "CLIMB") && isFinite(prev)){
      const jump = Math.abs(candTs - prev);
      if(jump > 25 * MIN_MS){
        // Clamp candidate toward prev; still allow convergence over time via smoothing.
        candTs = prev + Math.sign(candTs - prev) * (10 * MIN_MS);
      }
    }

    const raw = prev + (candTs - prev) * alpha;
    // Asymmetric clamp helps avoid "ETA always increasing wildly" right after takeoff.
    const upClamp = maxJump;
    const downClamp = (curPhase === "TAKEOFF" || curPhase === "DEPARTING" || curPhase === "CLIMB") ? (3.5 * MIN_MS) : maxJump;
    const diff = raw - prev;
    const limited = prev + (diff >= 0 ? Math.min(upClamp, diff) : Math.max(-downClamp, diff));

    mem.etaTs = Math.max(limited, minEta);
    mem.phase = curPhase;
    return mem.etaTs;
}

  function pruneEtaMemory(){
    const now = Date.now();
    const ttl = 25 * 60 * 1000;
    for(const [k,v] of etaMemory.entries()){
      if(!v?.lastSeen || (now - v.lastSeen) > ttl) etaMemory.delete(k);
    }
  }

  function computeDynamicEtaTs(p, destAp, phase){
    if(!p || !destAp) return null;
    const lat = Number(p.latitude), lon = Number(p.longitude);
    if(!isFinite(lat) || !isFinite(lon)) return null;
    const now = Date.now();
    const distNm = haversineNm(lat, lon, destAp.latitude, destAp.longitude);
    if(!isFinite(distNm)) return null;
    const prev = prevPilotStates.get(String(p.cid));
    const derived = computeTrackSpeedKts(prev, lat, lon, now);
    const gs = Number(p.groundspeed || 0);
    let speed = Math.max(gs, derived || 0);
    const minSpeed = (phase==="FINAL" || phase==="APPROACH" || phase==="GOAROUND") ? 85 : 110;
    speed = Math.max(speed, minSpeed);
    speed = Math.min(speed, 560);
    if(distNm < 1.2) return now + 60*1000;
    const factor = (phase==="FINAL") ? 1.16 : (phase==="APPROACH") ? 1.12 : (phase==="DESCENT") ? 1.08 : (phase==="DEPAREA") ? 1.10 : 1.05;
    return now + (distNm / speed) * 60 * factor * 60000;
  }
  function applyEtaForFlight(f, focusAp, boardType){
    if(boardType !== "arr") return;
    const now = Date.now();
    const phase = f.status?.phase || "UNK";
    let cand = null;
    if(f.status?.finished){
      const lu = f.pilot?.last_updated ? new Date(f.pilot.last_updated).getTime() : null;
      cand = isFinite(lu) ? lu : (f.etaPlannedTs ?? null);
    } else if(f.__prefile){
      cand = f.etaPlannedTs ?? null;
    } else if((f.dFromPlanNm != null && f.dFromPlanNm <= (STATUS_BANDS.NEAR_APT_NM + 3)) && Number(f.pilot?.altitude || 0) < 2500 && Number(f.pilot?.groundspeed || 0) < 120){
      const durMin = parseDurationHHMM(f.fp?.enroute_time || "");
      if(durMin != null){
        const baseDep = (f.stdTs != null && f.stdTs > (now - 10*60000)) ? f.stdTs : now;
        cand = baseDep + durMin*60000;
      }else{ cand = f.etaPlannedTs ?? null; }
    } else {
      cand = computeDynamicEtaTs(f.pilot, focusAp, phase);
      if(isFinite(cand) && isFinite(f.etaPlannedTs) && Math.abs(f.etaPlannedTs - cand) < 4*3600*1000) cand = cand*0.70 + f.etaPlannedTs*0.30;
      else if(!isFinite(cand)) cand = f.etaPlannedTs ?? null;
      if(isFinite(cand) && cand < (now - 2*60*1000)) cand = now + 2*60*1000;
    }
    const sm = stabilizeEta(etaKey(f.cid, boardType), cand, phase);
    f.etaTs = sm;
    f.etaText = sm != null ? fmtHHMMPlusText(sm) : "—";
  }

  // Departures: compute ETA at *destination* (used for time column once departed)
  function applyDestEtaForDepFlight(f){
    if(!f) return;
    const now = Date.now();
    const phase = f.status?.phase || "UNK";
    const destAp = getAirport(f.arr);

    let cand = null;

    if(f.status?.finished){
      const lu = f.pilot?.last_updated ? new Date(f.pilot.last_updated).getTime() : null;
      cand = isFinite(lu) ? lu : (f.etaPlannedTs ?? null);
    } else if(f.__prefile){
      cand = f.etaPlannedTs ?? null;
    } else if(phase === "GATE" || phase === "TAXI"){
      const durMin = parseDurationHHMM(f.fp?.enroute_time || "");
      if(durMin != null){
        const baseDep = (phase === "TAXI" && isFinite(f.etdTs)) ? f.etdTs : f.stdTs;
        const useDep = (baseDep != null && isFinite(baseDep) && baseDep > (now - 30*60*1000)) ? baseDep : now;
        cand = useDep + durMin*60000;
      }else{
        cand = f.etaPlannedTs ?? null;
      }
    } else if(destAp){
      // Map early departure phases to DEPAREA so computeDynamicEtaTs uses a sensible factor.
      const etaPhase = (phase === "DEPARTING" || phase === "CLIMB") ? "DEPAREA" : phase;
      cand = computeDynamicEtaTs(f.pilot, destAp, etaPhase);
      if(isFinite(cand) && isFinite(f.etaPlannedTs) && Math.abs(f.etaPlannedTs - cand) < 4*3600*1000){
        cand = cand*0.70 + f.etaPlannedTs*0.30;
      }else if(!isFinite(cand)){
        cand = f.etaPlannedTs ?? null;
      }
      if(isFinite(cand) && cand < (now - 2*60*1000)) cand = now + 2*60*1000;
    } else {
      cand = f.etaPlannedTs ?? null;
    }

    const sm = stabilizeEta(etaKey(f.cid, "dep"), cand, phase);
    f.destEtaTs = sm;
    f.destEtaText = sm != null ? fmtHHMMPlusText(sm) : "—";
  }

  function applyEtdForDepFlight(f){
    if(!f) return;
    if(f.__prefile) { f.etdTs = null; f.etdText = "—"; return; }
    const phase = f.status?.phase || "UNK";
    const now = Date.now();
    const cand = (phase === "TAXI") ? computeEtdForTaxi(f.stdTs, now, f) : null;
    const sm = stabilizeEtd(etdKey(f.cid), cand, phase);
    f.etdTs = sm;
    f.etdText = sm != null ? fmtHHMMPlusText(sm) : "—";
  }

  // What the Departures "time" column should show:
  // - TAXI: ETD (if computed) else STD
  // - GATE/PREFILE: STD
  // - departed (airborne): destination ETA
  // - finished: arrival timestamp / ETA (still grey at bottom)
  function depDisplayTimeTs(f){
    const phase = f.status?.phase || "UNK";
    // If we have a calculated ETD, prefer it even if phase is momentarily GATE (reload recovery)
    if(f.etdTs != null && isFinite(f.etdTs)) return f.etdTs;
    if(phase === "GATE" || phase === "PREFILE") return (f.stdTs ?? null);
    return (f.destEtaTs ?? f.etaPlannedTs ?? null);
  }

  function depDisplayTimeKind(f){
    const phase = f.status?.phase || "UNK";
    if(f.etdTs != null && isFinite(f.etdTs)) return "ETD";
    if(phase === "TAXI"){
      // reflect the actually displayed time (ETD if available, otherwise STD)
      return (f.etdTs != null && isFinite(f.etdTs)) ? "ETD" : "STD";
    }
    if(phase === "GATE" || phase === "PREFILE") return "STD";
    return "ETA";
  }

  // Arrivals: what the Arrivals "time" column should show:
  // - default: ETA
  // - after touchdown: ALDT (frozen)
  // - in-block/on-position: AIBT (frozen) + small ALDT
  function getArrAldtTs(f){ return (f?.aldtTs ?? f?.pilot?.__aldtTs ?? null); }
  function getArrAibtTs(f){ return (f?.aibtTs ?? f?.pilot?.__aibtTs ?? null); }
  function arrDisplayTimeKind(f){
    const aibt = getArrAibtTs(f);
    const aldt = getArrAldtTs(f);
    if(aibt != null && isFinite(aibt)) return "AIBT";
    if(aldt != null && isFinite(aldt)) return "ALDT";
    return "ETA";
  }
  function arrDisplayTimeTs(f){
    const kind = arrDisplayTimeKind(f);
    if(kind === "AIBT") return (getArrAibtTs(f) ?? null);
    if(kind === "ALDT") return (getArrAldtTs(f) ?? null);
    return (f?.etaTs ?? f?.etaPlannedTs ?? null);
  }
  function arrDisplaySubAldtTs(f){
    return (arrDisplayTimeKind(f) === "AIBT") ? (getArrAldtTs(f) ?? null) : null;
  }

  // Sorting
  const ARR_PHASE_ORDER = { GOAROUND:0, FINAL:1, APPROACH:2, DESCENT:3, CRUISE:4, DEPAREA:5, PREFILE:6, GATE:7, UNK:90, FINISHED:99 };
  const DEP_PHASE_ORDER = { TAKEOFF:1, LINEUP:2, TAXI:3, GATE:4, PREFILE:5, DEPARTING:6, CLIMB:7, CRUISE:8, DESCENT:9, APPROACH:10, FINAL:11, GOAROUND:10, UNK:90, FINISHED:99 };
  const SUBKEY_MAX = 1e12 - 1;
  function statusSensibleKey(f, boardType){
    const phase = f.status?.phase || "UNK";
    const base = (boardType==="arr") ? (ARR_PHASE_ORDER[phase] ?? 90) : (DEP_PHASE_ORDER[phase] ?? 90);
    let sub = 9e12;
    if(boardType === "arr"){
      if(phase==="FINAL" || phase==="APPROACH" || phase==="DESCENT" || phase==="GOAROUND") sub = Math.floor((f.dToFocusNm ?? 9999) * 1000);
      else { const ts = (arrDisplayTimeTs(f) ?? null); sub = ts != null ? Math.floor(ts/1000) : 9e12; }
    } else {
            if(phase==="TAXI"){
        const ts = (f.etdTs ?? f.stdTs ?? null);
        sub = ts != null ? Math.floor(ts/1000) : 9e12;
      }
          else if(phase==="TAKEOFF"){
        sub = Math.floor((f.dFromFocusNm ?? 9999) * 1000);
      }
      else if(phase==="GATE" || phase==="PREFILE"){
        const ts = f.stdTs ?? null;
        sub = ts != null ? Math.floor(ts/1000) : 9e12;
      }
      else if(phase==="DEPARTING" || phase==="CLIMB"){
        sub = Math.floor((f.dFromFocusNm ?? 9999) * 1000);
      }
      else if(phase==="CRUISE"){
        const ts = (f.destEtaTs ?? f.etaPlannedTs ?? null);
        const metric =
          (ts != null && isFinite(ts)) ? Math.floor(ts / 1000)
          : (isFinite(f.dToPlanNm) ? Math.floor(f.dToPlanNm * 1000) : null);

        // Invert within phase, but keep sub < 1e12 to preserve base ordering.
        sub = (metric != null && isFinite(metric)) ? (SUBKEY_MAX - metric) : 9e12;
      }
      else if(phase==="DESCENT" || phase==="APPROACH" || phase==="FINAL" || phase==="GOAROUND"){
        sub = Math.floor((f.dToPlanNm ?? 9999) * 1000);
      }
      else {
        const ts = (f.destEtaTs ?? f.etaPlannedTs ?? null);
        sub = ts != null ? Math.floor(ts/1000) : 9e12;
      }
    }
    return base*1e12 + sub;
  }
  function sortFlights(list, {by, dir}, boardType){
    const d = dir || 1;
    const coll = [...list];
    const keyFn = (f) => {
      if(by === "status") return statusSensibleKey(f, boardType);
      if(by === "callsign") return f.callsign;
      if(by === "dest") return f.arr;
      if(by === "orig") return f.dep;
      if(by === "xp") return (f.exp?.score ?? -1);
            if(by === "time") return (boardType === "dep"
        ? (depDisplayTimeTs(f) ?? 9e15)
        : (arrDisplayTimeTs(f) ?? 9e15)
      );
      return 0;
    };
    coll.sort((a,b) => {
      const fa = a.status?.finished ? 1 : 0;
      const fb = b.status?.finished ? 1 : 0;
      if(fa !== fb) return fa - fb;
      const ka = keyFn(a); const kb = keyFn(b);
      if(typeof ka === "number" && typeof kb === "number"){ if(ka !== kb) return d * (ka - kb); }
      else { const sa = String(ka ?? ""), sb = String(kb ?? ""); const c = sa.localeCompare(sb, "en", { sensitivity:"base" }); if(c !== 0) return d * c; }
      const ta = (boardType === "dep") ? (depDisplayTimeTs(a) ?? 9e15) : (a.etaTs ?? a.etaPlannedTs ?? 9e15);
      const tb = (boardType === "dep") ? (depDisplayTimeTs(b) ?? 9e15) : (b.etaTs ?? b.etaPlannedTs ?? 9e15);
      if(ta !== tb) return ta - tb;
      return a.callsign.localeCompare(b.callsign, "en", { sensitivity:"base" });
    });
    return coll;
  }

  /********************
   * Rendering (dynamic columns)
   ********************/
  let renderEpoch = 0;

  class Board {
    constructor(tbody, boardType){
      this.tbody = tbody;
      this.boardType = boardType;
      this.rows = new Map();
    }
    getLayout(){
      return settings.boardLayout[this.boardType];
    }
    getVisibleKeys(){
      const layout = this.getLayout();
      return layout.order.filter(k => layout.visible[k]);
    }
    reset(){
      this.rows.clear();
      this.tbody.innerHTML = "";
    }
    makeRow(f){
      const tr = document.createElement("tr");
      tr.dataset.id = String(f.id);
      tr.__cells = {};
      tr.__statusSig = null;
      tr.__blinkActive = false;
      tr.__blinkSetAt = -1;
      tr.__timeKindSig = null;
      tr.__timeBlinkActive = false;
      tr.__timeBlinkSetAt = -1;

      const keys = this.getVisibleKeys();
      for(const key of keys){
        const td = document.createElement("td");
        const meta = COL_META[key] || {};
        if(meta.tdClass) td.className = meta.tdClass;
        if(key === "typeRoute" && !td.classList.contains("cell-route")) td.classList.add("cell-route");
        if(key === "time"){
          td.classList.add("center");
          td.classList.add("timeCell");
        }
        tr.__cells[key] = td;
        tr.appendChild(td);
      }

      tr.addEventListener("click", () => {
        if(window.getSelection && String(window.getSelection()).length) return;
        openPilotModal(tr.__flight || f);
      });

      tr.__flight = f;
      return tr;
    }

    updateXpCell(td, f){
      if(!td) return;
      let pill = td.querySelector(".xpPill");
      if(!pill){
        td.innerHTML = `<span class="xpPill loading info" data-cid="${escapeHtml(f.cid)}" data-tip="${escapeHtml(t("xp_loading"))}"><span class="spinner" aria-hidden="true"></span><span class="lvl">XP</span><span class="score">…</span></span>`;
        pill = td.querySelector(".xpPill");
      }

      if(f.exp && f.exp.cls === 'missing') {
        pill.className = "xpPill missing";
        pill.innerHTML = `<span class="xDot" aria-hidden="true"></span><span class="lvl">${escapeHtml(t("xp_na"))}</span>`;
        pill.dataset.tip = t("xp_missing_tip");
        return;
      }

      const ready = !!(f.exp && f.exp.score != null && f.stats && (!xpUsesAgeBonus() || f.details));
      if(ready){
        pill.classList.remove("loading");
        pill.classList.remove("good","warn","bad","info","missing");
        pill.classList.add(f.exp.cls || "info");
        pill.innerHTML = `<span class="xDot" aria-hidden="true"></span><span class="lvl">${escapeHtml(f.exp.short)}</span><span class="score">${escapeHtml(String(f.exp.score))}</span>`;
        pill.dataset.tip = experienceTooltipText(f.cid, f.details, f.stats, f.exp);
      }else{
        pill.className = "xpPill loading info";
        pill.innerHTML = `<span class="spinner" aria-hidden="true"></span><span class="lvl">XP</span><span class="score">…</span>`;
        pill.dataset.tip = t("xp_loading");
      }
    }

    updateRow(tr, f){
      if(f.status?.finished) tr.classList.add("finishedRow"); else tr.classList.remove("finishedRow");
      if(this.boardType === "arr" && !f.status?.finished && f.status?.phase === "GATE") tr.classList.add("groundRow");
      else tr.classList.remove("groundRow");

      // divider is order-dependent and applied in render()
      tr.classList.remove("landedDivider");
      if(tr.__blinkActive && tr.__blinkSetAt < renderEpoch) tr.__blinkActive = false;
      if(tr.__timeBlinkActive && tr.__timeBlinkSetAt < renderEpoch) tr.__timeBlinkActive = false;

      const newSig = `${f.status.rank}|${f.status.text}|${f.status.cls}|${f.status.finished ? 1 : 0}`;
      if(tr.__statusSig && tr.__statusSig !== newSig){ tr.__blinkActive = true; tr.__blinkSetAt = renderEpoch; }
      tr.__statusSig = newSig;

      const c = tr.__cells;

      if(c.time){
        if(this.boardType === "dep"){
          const ts = depDisplayTimeTs(f);
          const kind = depDisplayTimeKind(f);

          // Blink the kind label for one refresh period if it changed vs last refresh.
          if(tr.__timeKindSig && tr.__timeKindSig !== kind){
            tr.__timeBlinkActive = true;
            tr.__timeBlinkSetAt = renderEpoch;
          }
          tr.__timeKindSig = kind;

          c.time.innerHTML =
            `<span class="timeKind${tr.__timeBlinkActive ? " blink" : ""}">${escapeHtml(kind)}</span>` +
            `<span class="timeVal">${fmtHHMMPlusHtml(ts)}</span>`;
        }else{
          const kind = arrDisplayTimeKind(f);
          const ts = arrDisplayTimeTs(f);
          const subAldt = arrDisplaySubAldtTs(f);

          // Blink (one refresh) when we switch ETA -> ALDT -> AIBT, or when frozen actual times update.
          // IMPORTANT: do NOT blink on every ETA recalculation.
          const sig = (kind === "ETA")
            ? "ETA"
            : `${kind}|${String(roundToMinute(ts) ?? "")}|${String(roundToMinute(subAldt) ?? "")}`;

          if(tr.__timeKindSig && tr.__timeKindSig !== sig){
            tr.__timeBlinkActive = true;
            tr.__timeBlinkSetAt = renderEpoch;
          }
          tr.__timeKindSig = sig;

          const hasSub = (kind === "AIBT" && subAldt != null && isFinite(subAldt));
          c.time.classList.toggle("hasSub", hasSub);

          c.time.innerHTML =
            `<span class="timeKind${tr.__timeBlinkActive ? " blink" : ""}">${escapeHtml(kind)}</span>` +
            `<span class="timeVal${tr.__timeBlinkActive ? " blink" : ""}">${fmtHHMMPlusHtml(ts)}</span>` +
            (hasSub
              ? `<span class="timeSub"><span class="subKind">ALDT</span>${escapeHtml(fmtHHMMFromTs(subAldt))}</span>`
              : ``);
        }
      }

      if(c.callsign){
        c.callsign.innerHTML = `<span style="font-weight:800">${escapeHtml(f.callsign)}</span>`;
        c.callsign.title = `${f.name || ""}\nCID: ${f.cid}`;
      }

      if(c.ap){
        c.ap.innerHTML = this.boardType === "dep"
          ? `<span style="font-weight:800">${escapeHtml(f.arr)}</span>`
          : `<span style="font-weight:800">${escapeHtml(f.dep)}</span>`;
      }

      if(c.typeRoute){
        const routeText = (f.route || "").trim() || `${f.dep} → ${f.arr}`;
        c.typeRoute.innerHTML = `<span style="font-weight:800">${escapeHtml(f.aircraft || "—")}</span><span class="muted"> · </span><span class="muted">${escapeHtml(routeText)}</span>`;
        c.typeRoute.title = routeText;
      }

      if(c.altgs){
        c.altgs.textContent = altGsText(f.pilot);
      }

      if(c.status){
        c.status.innerHTML = `<span class="badge ${f.status.cls}${tr.__blinkActive ? " blink" : ""}"><span class="sDot"></span><span>${escapeHtml(f.status.text)}</span></span>`;
      }

      if(c.xp){
        this.updateXpCell(c.xp, f);
      }

      tr.__flight = f;
    }

    async render(list){
      // Board header count (active flights; finished/landed excluded; prefiles included iff shown)
      const activeCount = list.reduce((n, f) => n + (f?.status?.finished ? 0 : 1), 0);
      if(this.boardType === "dep"){
        depTitleEl.textContent = `${t("dep_title")} (${activeCount})`;
      }else{
        arrTitleEl.textContent = `${t("arr_title")} (${activeCount})`;
      }
      const first = new Map();
      for(const [id, tr] of this.rows) first.set(id, tr.getBoundingClientRect());
      const newIds = new Set(list.map(x => String(x.id)));

      for(const [id, tr] of [...this.rows.entries()]){
        if(!newIds.has(id)){
          tr.classList.add("removing");
          this.rows.delete(id);
          tr.addEventListener("transitionend", () => tr.remove(), { once:true });
          setTimeout(() => { if(tr.isConnected) tr.remove(); }, 400);
        }
      }

      for(const f of list){
        const id = String(f.id);
        let tr = this.rows.get(id);
        if(!tr){
          tr = this.makeRow(f);
          tr.classList.add("adding");
          this.rows.set(id, tr);
        }
        this.updateRow(tr, f);
      }

      const frag = document.createDocumentFragment();
      for(const f of list){
        const tr = this.rows.get(String(f.id));
        if(tr) frag.appendChild(tr);
      }
      this.tbody.appendChild(frag);

      // Arrivals: add a subtle divider above the first finished (landed) arrival row
      if(this.boardType === "arr"){
        const firstFinished = list.find(f => !!f?.status?.finished);
        if(firstFinished){
          const tr = this.rows.get(String(firstFinished.id));
          if(tr) tr.classList.add("landedDivider");
        }
      }

      requestAnimationFrame(() => {
        for(const [, tr] of this.rows){
          if(tr.classList.contains("adding")){
            tr.classList.remove("adding");
            tr.style.transition = "opacity .18s ease, transform .18s ease";
            tr.style.opacity = "1";
            tr.style.transform = "translateY(0)";
            setTimeout(() => { tr.style.transition = ""; tr.style.opacity = ""; tr.style.transform = ""; }, 250);
          }
        }
      });

      requestAnimationFrame(() => {
        for(const [id, tr] of this.rows){
          const firstRect = first.get(id);
          if(!firstRect) continue;
          const lastRect = tr.getBoundingClientRect();
          const dx = firstRect.left - lastRect.left;
          const dy = firstRect.top - lastRect.top;
          if(Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) continue;
          tr.style.transform = `translate(${dx}px, ${dy}px)`;
          tr.style.transition = "transform 0s";
          requestAnimationFrame(() => {
            tr.style.transition = "transform 420ms cubic-bezier(.2,.8,.2,1)";
            tr.style.transform = "";
          });
        }
      });
    }

    updateXpById(id){
      const tr = this.rows.get(String(id));
      if(!tr) return;
      const td = tr.__cells?.xp;
      if(td) this.updateXpCell(td, tr.__flight);
    }
  }

  const depBoard = new Board(depBody, "dep");
  const arrBoard = new Board(arrBody, "arr");

  /********************
   * Tooltip
   ********************/
  let tooltipActive = false;
  function showTooltip(text, x, y){
    // Allow HTML
    if(text.includes("<")) tooltip.innerHTML = text;
    else tooltip.textContent = text;
    tooltip.style.left = `${x}px`;
    tooltip.style.top = `${y}px`;
    tooltip.classList.add("show");
    tooltipActive = true;
  }
  function hideTooltip(){
    tooltip.classList.remove("show");
    tooltipActive = false;
  }
  document.addEventListener("mousemove", (e) => {
    if(!tooltipActive) return;
    tooltip.style.left = `${e.clientX}px`;
    tooltip.style.top = `${e.clientY}px`;
  });
  function attachTooltipDelegation(tbody){
    tbody.addEventListener("mouseover", (e) => {
      const pill = e.target.closest(".xpPill");
      if(!pill) return;
      showTooltip(pill.dataset.tip || "—", e.clientX, e.clientY);
    });
    tbody.addEventListener("mouseout", (e) => {
      const pill = e.target.closest(".xpPill");
      if(!pill) return;
      hideTooltip();
    });
  }
  attachTooltipDelegation(depBody);
  attachTooltipDelegation(arrBody);

  /********************
   * Pilot Modal
   ********************/
  function setKv(el, pairs){
    el.innerHTML = "";
    for(const [k,v] of pairs){
      const dk = document.createElement("div");
      dk.className="k"; dk.textContent = k;
      const dv = document.createElement("div");
      dv.className="v"; dv.textContent = v;
      el.appendChild(dk); el.appendChild(dv);
    }
  }
  function setLinks(el, links){
    el.innerHTML = "";
    for(const {href, text} of links){
      const a = document.createElement("a");
      a.className = "aBtn";
      a.href = href;
      a.target = "_blank";
      a.rel = "noreferrer";
      a.textContent = text;
      el.appendChild(a);
    }
  }

  async function openPilotModal(f){
    pilotModalOverlay.classList.add("show");
    historyKv.innerHTML = "";
    xpList.innerHTML = "";
    xpLinks.innerHTML = "";

    pilotModalTitle.textContent = `${t("pilot_modal_title")} · CID ${f.cid} · ${f.callsign}`;
    pilotModalSubtitle.textContent = `${f.name || "—"} · ${f.dep} → ${f.arr}`;

    const modalIsDep = (normalizeCode(f.dep) === normalizeCode(currentAirportIcao));
    const modalEtaTs = modalIsDep
      ? (f.destEtaTs ?? f.etaPlannedTs ?? null)
      : (f.etaTs ?? f.etaPlannedTs ?? null);

    setKv(flightKv, [
      [t("kv_callsign"), f.callsign],
      [t("kv_cid"), String(f.cid)],
      [t("kv_name"), f.name || "—"],
      [t("kv_route"), `${f.dep} → ${f.arr}`],
      [t("kv_type"), f.aircraft || "—"],
      [t("kv_std"), f.stdTs != null ? fmtHHMMPlusText(f.stdTs) : "—"],
      [t("kv_eet"), (f.fp?.enroute_time ? (f.fp.enroute_time.slice(0,2)+":"+f.fp.enroute_time.slice(2,4)) : "—")],
      [t("kv_eta"), (modalEtaTs != null ? fmtHHMMPlusText(modalEtaTs) : "—")],
      [t("kv_status"), f.status?.text || "—"],
      [t("kv_last_updated"), f.pilot?.last_updated ? (new Date(f.pilot.last_updated).toISOString().slice(0,19) + "Z") : "—"]
    ]);

    let details = f.details, stats = f.stats, exp = f.exp;
    try{
      // Respect setting: avoid member-details endpoint when age bonus is OFF
      if(!xpUsesAgeBonus()){
        details = null;
      }else{
        if(!details) details = await getMemberDetails(f.cid);
      }
      if(!stats) stats = await getMemberStats(f.cid);
      exp = computeExperience(details, stats);
    }catch(err){
      console.warn("Modal fetch err:", err);
    }

    setKv(xpKv, [
      [t("kv_experience"), exp?.score != null ? `${exp.label} · Score ${exp.score}/100` : (exp?.cls==='missing' ? t("xp_na") : "—")],
      [t("kv_registered"), (xpUsesAgeBonus() && details?.reg_date) ? fmtDateUtc(details.reg_date) : "—"],
      [t("kv_pilot_hours"), stats ? fmtHours(stats.pilot) : "—"],
      [t("kv_atc_hours"), stats ? fmtHours(stats.atc) : "—"],
      [t("kv_atc_weighted"), (stats && exp) ? fmtHours(exp.atcWeighted) : "—"],
      [t("kv_region_div"), (xpUsesAgeBonus() && details?.region_id && details?.division_id) ? `${details.region_id} / ${details.division_id}` : "—"]
    ]);

    for(const r of (exp?.reasons || [])){
      const li = document.createElement("li");
      li.textContent = r;
      xpList.appendChild(li);
    }

    setLinks(xpLinks, [
      { href: `https://stats.vatsim.net/stats/${encodeURIComponent(f.cid)}`, text: "VATSIM Stats Center" }
    ]);

    try{
      const hist = await getMemberHistory(f.cid, { limit: 50 });
      if(hist){
        const items = Array.isArray(hist?.items) ? hist.items : [];
        const count = Number(hist?.count ?? items.length ?? 0);
        let lastEnd = null;
        for(const it of items){
          if(it?.end){
            const d = new Date(it.end);
            if(isFinite(d) && (!lastEnd || d > lastEnd)) lastEnd = d;
          }
        }
        setKv(historyKv, [
          [t("kv_sessions_ret"), String(items.length)],
          [t("kv_sessions_count"), String(count)],
          [t("kv_last_end"), lastEnd ? (lastEnd.toISOString().slice(0,19) + "Z") : "—"],
          [t("kv_note"), t("history_note_kv")]
        ]);
      } else {
        setKv(historyKv, [[t("pilot_card_history"), t("history_unavailable")]]);
      }
    }catch(err){
      setKv(historyKv, [[t("pilot_card_history"), t("history_error")]]);
    }
  }
  function closePilotModal(){ pilotModalOverlay.classList.remove("show"); }
  pilotModalClose.addEventListener("click", closePilotModal);
  pilotModalOverlay.addEventListener("click", (e) => { if(e.target === pilotModalOverlay) closePilotModal(); });

  /********************
 +   * Airport Pilot XP Index (Logic & Tooltip)
   ********************/

  function computeBoardXpIndex(list){
    const total = list.length;
    let sum = 0, loaded = 0;
    for(const f of list){
      const s = f?.exp?.score;
      if(s != null && isFinite(s)){
        sum += Number(s);
        loaded++;
      }
    }
    if(total === 0) return { total, loaded, avg:null, cls:"info" };
    if(loaded === 0) return { total, loaded, avg:null, cls:"info" };
    const avg = Math.round(sum / loaded);
    const mapped = levelFromScore(avg);
    return { total, loaded, avg, cls: mapped.cls || "info" };
  }
  // Store XP data for tabs
  function updateTabsXpMetadata(){
     // iterate all airports in store
     for(const [icao, data] of Object.entries(flightStore)){
        const depIdx = computeBoardXpIndex(data.deps || []);
        const arrIdx = computeBoardXpIndex(data.arrs || []);
        data.xpStats = { dep: depIdx, arr: arrIdx };
     }
        }
  // Scheduling wrapper mainly for UI updates if needed, but tabs handle tooltip on hover dynamically
  function scheduleAirportXpIndexUpdate(){ updateTabsXpMetadata(); }


  /********************
   * Config (tabs + board layout editor)
   ********************/
  let cfgDraftLayout = structuredClone(settings.boardLayout);

  function colNameForConfig(key, boardType){
    if(key === "time") return (boardType === "dep") ? t("th_time_std") : t("th_time_eta");
    if(key === "ap") return (boardType === "dep") ? t("th_to") : t("th_from");
    if(key === "callsign") return t("th_callsign");
    if(key === "typeRoute") return t("th_type_route");
    if(key === "altgs") return t("th_alt_gs");
    if(key === "status") return t("th_status");
    if(key === "xp") return t("th_xp");
    return key;
  }

  function renderColEditor(boardType, container){
    container.innerHTML = "";
    const lay = cfgDraftLayout[boardType];
    const keys = lay.order.slice();

    for(let i=0;i<keys.length;i++){
      const key = keys[i];
      const item = document.createElement("div");
      item.className = "colItem";
      item.dataset.key = key;

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = !!lay.visible[key];
      cb.title = "toggle";

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = colNameForConfig(key, boardType);

      const btns = document.createElement("div");
      btns.className = "miniBtns";

      const up = document.createElement("button");
      up.type = "button";
      up.className = "btnGhost";
      up.textContent = "▲";
      up.title = "Up";

      const dn = document.createElement("button");
      dn.type = "button";
      dn.className = "btnGhost";
      dn.textContent = "▼";
      dn.title = "Down";

      up.disabled = (i === 0);
      dn.disabled = (i === keys.length - 1);

      cb.addEventListener("change", () => { lay.visible[key] = !!cb.checked; });

      up.addEventListener("click", () => {
        const idx = lay.order.indexOf(key);
        if(idx > 0){
          const tmp = lay.order[idx-1];
          lay.order[idx-1] = lay.order[idx];
          lay.order[idx] = tmp;
          renderDisplayEditors();
        }
      });
      dn.addEventListener("click", () => {
        const idx = lay.order.indexOf(key);
        if(idx >= 0 && idx < lay.order.length-1){
          const tmp = lay.order[idx+1];
          lay.order[idx+1] = lay.order[idx];
          lay.order[idx] = tmp;
          renderDisplayEditors();
        }
      });

      btns.append(up, dn);
      item.append(cb, name, btns);
      container.appendChild(item);
    }
  }

  function renderDisplayEditors(){
    renderColEditor("dep", cfgDepCols);
    renderColEditor("arr", cfgArrCols);
  }

  function openConfigModal(){
    cfgAirport1.value = (settings.airports && settings.airports[0]) ? settings.airports[0] : "";
    cfgAirport2.value = (settings.airports && settings.airports[1]) ? settings.airports[1] : "";
    cfgAirport3.value = (settings.airports && settings.airports[2]) ? settings.airports[2] : "";
    cfgInterval.value = Math.round((settings.feedIntervalMs || 15000) / 1000);
    cfgLanguage.value = settings.language || "de";
    cfgPrefiles.checked = !!settings.showPrefiles;
    cfgHideArrLanded.checked = !!settings.hideArrivalsLanded;
    cfgHideDepFinished.checked = !!settings.hideDeparturesFinished;
        cfgAgeBonus.checked = !!settings.xpAgeBonusEnabled;

    const th = normalizedThresholds(settings.xpThresholds);
    cfgT1.value = th.t1; cfgT2.value = th.t2; cfgT3.value = th.t3; cfgT4.value = th.t4;

    cfgDraftLayout = structuredClone(settings.boardLayout);
    renderDisplayEditors();

    setActiveCfgTab("general");
    configModalOverlay.classList.add("show");
  }
  function closeConfigModal(){ configModalOverlay.classList.remove("show"); }
  configBtn.addEventListener("click", openConfigModal);
  configClose.addEventListener("click", closeConfigModal);
  cfgCancel.addEventListener("click", closeConfigModal);
  configModalOverlay.addEventListener("click", (e) => { if(e.target === configModalOverlay) closeConfigModal(); });

  cfgDefaults.addEventListener("click", () => {
    cfgAirport1.value = DEFAULTS.airports[0];
    cfgAirport2.value = DEFAULTS.airports[1];
    cfgAirport3.value = DEFAULTS.airports[2];
    cfgInterval.value = Math.round(DEFAULTS.feedIntervalMs/1000);
    cfgLanguage.value = DEFAULTS.language;
    cfgPrefiles.checked = DEFAULTS.showPrefiles;
    cfgHideArrLanded.checked = DEFAULTS.hideArrivalsLanded;
    cfgHideDepFinished.checked = DEFAULTS.hideDeparturesFinished;
        cfgAgeBonus.checked = DEFAULTS.xpAgeBonusEnabled;
    cfgT1.value = DEFAULTS.xpThresholds.t1;
    cfgT2.value = DEFAULTS.xpThresholds.t2;
    cfgT3.value = DEFAULTS.xpThresholds.t3;
    cfgT4.value = DEFAULTS.xpThresholds.t4;

    cfgDraftLayout = structuredClone(DEFAULTS.boardLayout);
    renderDisplayEditors();
  });

  function resetCache(){
    localStorage.removeItem(MEMBER_CACHE_KEY);
    localStorage.removeItem(API_LAST_REQ_KEY);
        localStorage.removeItem(GATE_CACHE_KEY);
        localStorage.removeItem(GATE_FLIGHT_CACHE_KEY);
        localStorage.removeItem(TAXIWAY_CACHE_KEY);
        localStorage.removeItem(RUNWAY_CACHE_KEY);
        localStorage.removeItem(HOTZONE_CACHE_KEY);
        localStorage.removeItem(ETD_PERSIST_KEY);
    localStorage.removeItem(FLIGHT_STATE_KEY);
        gateFlightCache = {};
    gateIndexByIcao.clear();
        gateLoadPromises.clear();
        gateMem.clear();
        taxiwayIndexByIcao.clear();
    taxiwayLoadPromises.clear();
    taxiMem.clear();
        runwayIndexByIcao.clear();
    runwayLoadPromises.clear();
    runwayTargetMem.clear();
    hotZoneIndexByIcao.clear();
    hotZoneLoadPromises.clear();
        TaxiTimeManager.data = {};
    localStorage.removeItem(TAXI_TIMES_CACHE_KEY);
    memberCache = {};
    limiter.clear();
    etdCacheData = {};
    etdCacheDirty = false;
    flightStateDirty = false;
    inflightXp.clear();
    for(const f of [...lastDeps, ...lastArrs]){
      f.details = null; f.stats = null; f.exp = null;
      depBoard.updateXpById(f.id);
      arrBoard.updateXpById(f.id);
    }
    requestXpForVisibleFlights();
    scheduleAirportXpIndexUpdate();
  }
  // Event listener is now defined in the UI Hooks section above to ensure it only targets LocalStorage
  // cfgResetCache.addEventListener("click", ... );

  cfgSave.addEventListener("click", async () => {
    const a1 = normalizeCode(cfgAirport1.value);
    const a2 = normalizeCode(cfgAirport2.value);
    const a3 = normalizeCode(cfgAirport3.value);
    const newAirports = [a1, a2, a3].filter(Boolean);
    if(newAirports.length === 0) newAirports.push("EDDB");
    const intervalS = clampInt(cfgInterval.value, 5, 120);
    const th = normalizedThresholds({ t1: cfgT1.value, t2: cfgT2.value, t3: cfgT3.value, t4: cfgT4.value });

    settings.airports = newAirports;
    // If active tab is no longer in list, switch to first
    if(!newAirports.includes(settings.activeTab)) settings.activeTab = newAirports[0];
    settings.feedIntervalMs = intervalS * 1000;
    settings.language = (cfgLanguage.value === "en") ? "en" : "de";

    settings.showPrefiles = !!cfgPrefiles.checked;
    settings.hideArrivalsLanded = !!cfgHideArrLanded.checked;
    settings.hideDeparturesFinished = !!cfgHideDepFinished.checked;

    settings.xpThresholds = th;
        settings.xpAgeBonusEnabled = !!cfgAgeBonus.checked;

    // Commit layout
    settings.boardLayout = {
      dep: normalizeLayout(cfgDraftLayout.dep, "dep"),
      arr: normalizeLayout(cfgDraftLayout.arr, "arr")
    };

    saveSettings();

    // Apply UI updates
    applyLanguage();
    depBoard.reset();
    arrBoard.reset();

    await initTabs();
    closeConfigModal();
  });

  /********************
   * Loop / Feed
   ********************/
  let currentAirportIcao = "EDDB";
  let lastFeedTs = null;
  let feedTimer = null;

  // We keep a store of the calculated board state for each configured airport
  // { "EDDB": { deps:[], arrs:[] }, "EDDF": ... }
  let flightStore = {};

  let lastDeps = [];
  let lastArrs = [];
  let flightsByCid = new Map();
  let inflightXp = new Map();
  let resortTimers = { dep:null, arr:null };

  // Build the tab UI based on settings.airports
  async function initTabs(){
     // Ensure distinct list (filter empty strings but keep holes if desired? No, squash holes for logic, keep 3 slots UI)
     let list = (settings.airports || []).map(normalizeCode).filter(Boolean);
     list = [...new Set(list)];
     if(list.length === 0) list = ["EDDB"];
     settings.airports = list; // Logic uses compact list
     // Sync active tab
     if(!list.includes(settings.activeTab)) settings.activeTab = list[0];
     saveSettings();

     // Setup UI
     airportTabsContainer.innerHTML = "";
     // Render exactly 3 tabs
     for(let i=0; i<3; i++){
        const code = list[i] || null;
        const btn = document.createElement("button");
        btn.className = "airportTab";
        btn.textContent = code || "—";

        if(code){
           btn.dataset.icao = code;
           btn.addEventListener("click", () => switchTab(code));
           // Add Tooltip for XP stats
           btn.addEventListener("mouseover", (e) => {
              const store = flightStore[code];
              if(!store || !store.xpStats) return;
              const xp = store.xpStats;

              const makeRows = () => {
                 // Helper to generate the grid content
                 const rows = [];
                 const add = (lbl, data) => {
                 if(!data) return "";
                 const val = (data.avg == null) ? (data.total ? "…" : "—") : data.avg;
                 rows.push(
                    `<span class="dot ${data.cls}" style="margin-top:4px;"></span>`,
                    `<span style="font-weight:700; color:var(--text-muted);">${lbl}</span>`,
                    `<span style="font-weight:800; color:#fff; text-align:right;">${val}</span>`,
                    `<span style="color:var(--text-muted); font-size:9px; opacity:0.7;">${data.loaded}/${data.total}</span>`
                 );
                 };
                 add("DEP", xp.dep);
                 add("ARR", xp.arr);
                 return rows.join("");
              };

              const html = `
<div style="display:grid; white-space:normal; grid-template-columns: auto auto auto auto; gap:2px 8px; align-items:center; font-family:var(--font-mono); font-size:11px;">
  <div style="grid-column:1/-1; margin-bottom:2px; font-weight:700; font-size:10px; letter-spacing:0.05em; color:var(--text-main); border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:2px;">
    ${code} XP
  </div>
  ${makeRows()}
</div>`;
              showTooltip(html, e.clientX, e.clientY);
              // Force tooltip below the mouse for header tabs
              tooltip.classList.add("south");
           });
           btn.addEventListener("mouseout", () => {
              tooltip.classList.remove("south");
              hideTooltip();
           });
           // Kick off preload
           ensureGateIndexForIcao(code).catch(()=>{});
           ensureTaxiwayIndexForIcao(code).catch(()=>{});
           ensureHotZoneIndexForIcao(code).catch(()=>{});
        } else {
           btn.disabled = true;
        }
        airportTabsContainer.appendChild(btn);
     }


     // Clear old store to avoid ghosts
     flightStore = {};
     limiter.clear();
     inflightXp.clear();

     // Initial refresh
     await refresh();
     updateTabUi();
  }

  function switchTab(icao){
     if(settings.activeTab === icao) return;
     settings.activeTab = icao;
     saveSettings(); // Persist active tab immediately
     updateTabUi();
     renderBoardsFromStore();
  }

  function updateTabUi(){
     for(const btn of airportTabsContainer.children){
        const code = btn.dataset.icao;
        if(!code) continue; // skip disabled/empty tabs
        btn.classList.toggle("active", code === settings.activeTab);
     }
  }

  async function renderBoardsFromStore(){
     const data = flightStore[settings.activeTab] || { deps:[], arrs:[] };
     // Update globals so sorting/tooltips work
     currentAirportIcao = settings.activeTab;
     lastDeps = data.deps;
     lastArrs = data.arrs;

     // Update Headers
     depTitleEl.textContent = `${t("dep_title")} (${lastDeps.length})`;
     arrTitleEl.textContent = `${t("arr_title")} (${lastArrs.length})`;

     await depBoard.render(lastDeps);
     await arrBoard.render(lastArrs);
  }

  function setFeedStatus({ok, msg, ageSec}){
    feedDot.className = "dot " + (ok ? "good" : "bad");
    feedText.textContent = msg;
    feedAge.textContent = ageSec != null ? `${Math.max(0, Math.round(ageSec))}s` : "—";
  }

  async function fetchFeed(){
    const res = await fetch(VATSIM_DATA_URL, { cache:"no-store" });
    if(!res.ok) throw new Error(`Feed HTTP ${res.status}`);
    return res.json();
  }

  function buildFlightObjectFromPilot(p){
    const fp = p.flight_plan;
    const dep = normalizeCode(fp?.departure || "");
    const arr = normalizeCode(fp?.arrival || "");
    const stdTs = plannedStdTs(fp?.deptime || "", Date.now());
    const etaPlannedTs = plannedEtaTs(stdTs, fp?.enroute_time || "");
    return {
      id: p.cid,
      cid: p.cid,
      callsign: normalizeCode(p.callsign || ""),
      name: p.name || "",
      dep, arr,
      aircraft: normalizeCode(fp?.aircraft_short || fp?.aircraft_faa || fp?.aircraft || "—"),
      route: fp?.route || "",
      fp,
      pilot: p,
      stdTs,
      stdText: stdTs != null ? fmtHHMMPlusText(stdTs) : "—",
          etdTs: null,
      etdText: "—",
      etaPlannedTs,
      etaTs: etaPlannedTs,
      etaText: etaPlannedTs != null ? fmtHHMMPlusText(etaPlannedTs) : "—",
      destEtaTs: etaPlannedTs,
      destEtaText: etaPlannedTs != null ? fmtHHMMPlusText(etaPlannedTs) : "—",
          dFromFocusNm: null,
      dToFocusNm: null,
      dToPlanNm: null,
      dFromPlanNm: null,
      status: { phase:"UNK", rank:99, text:"—", cls:"info", finished:false },
      details:null, stats:null, exp:null
    };
  }

  function buildFlightObjectFromPrefile(pf){
    const fp = pf.flight_plan;
    const dep = normalizeCode(fp?.departure || "");
    const arr = normalizeCode(fp?.arrival || "");
    const stdTs = plannedStdTs(fp?.deptime || "", Date.now());
    const etaPlannedTs = plannedEtaTs(stdTs, fp?.enroute_time || "");
    const pilotStub = { altitude:0, groundspeed:0, latitude:0, longitude:0, last_updated: pf.last_updated };
    return {
      id: "P" + pf.cid + "_" + normalizeCode(pf.callsign || ""),
      cid: pf.cid,
      callsign: normalizeCode(pf.callsign || ""),
      name: pf.name || "",
      dep, arr,
      aircraft: normalizeCode(fp?.aircraft_short || fp?.aircraft_faa || fp?.aircraft || "—"),
      route: fp?.route || "",
      fp,
      pilot: pilotStub,
      stdTs,
      stdText: stdTs != null ? fmtHHMMPlusText(stdTs) : "—",
          etdTs: null,
      etdText: "—",
      etaPlannedTs,
      etaTs: etaPlannedTs,
      etaText: etaPlannedTs != null ? fmtHHMMPlusText(etaPlannedTs) : "—",
      destEtaTs: etaPlannedTs,
      destEtaText: etaPlannedTs != null ? fmtHHMMPlusText(etaPlannedTs) : "—",
          dFromFocusNm: null,
      dToFocusNm: null,
      dToPlanNm: null,
      dFromPlanNm: null,
      status: { phase:"PREFILE", rank:0, text: t("status_prefile"), cls:"info", finished:false },
      details:null, stats:null, exp:null,
      __prefile:true
    };
  }

  function applyCachedXpIfAvailable(f){
    const entry = getCacheEntry(f.cid);

    if(isCoolingDown(entry)) {
      f.details = null; f.stats = null;
      f.exp = computeExperience(null, null);
      return;
    }

    // When age bonus is OFF: do not use / fetch member details at all (avoid rate limits)
    if(xpUsesAgeBonus()){
      if(entry?.details && isFresh(entry.detailsTs, settings.memberTtlDetailsMs)) f.details = entry.details;
    }else{
      f.details = null;
    }
    if(entry?.stats && isFresh(entry.statsTs, settings.memberTtlStatsMs)) f.stats = entry.stats;
    if(f.stats && (!xpUsesAgeBonus() || f.details)) f.exp = computeExperience(f.details, f.stats);
  }

  async function ensureXpForCid(cid){
    cid = String(cid);
    if(inflightXp.has(cid)) return inflightXp.get(cid);

    const p = (async () => {
      const entry = getCacheEntry(cid);
      if(isCoolingDown(entry)) return { details:null, stats:null, exp: computeExperience(null, null) };

      const needDetails = xpUsesAgeBonus();
      let details = needDetails && (entry?.details && isFresh(entry.detailsTs, settings.memberTtlDetailsMs)) ? entry.details : null;
      let stats   = (entry?.stats   && isFresh(entry.statsTs, settings.memberTtlStatsMs))   ? entry.stats   : null;

      if(needDetails && !details) details = await getMemberDetails(cid);
      if(!stats)   stats   = await getMemberStats(cid);

      const exp = computeExperience(details, stats);
      return { details: needDetails ? details : null, stats, exp };
    })();

    inflightXp.set(cid, p);
    try{ return await p; } finally{ inflightXp.delete(cid); }
  }

  function scheduleResort(which){
    const isXpSort = (which === "dep") ? (settings.depSort.by === "xp") : (settings.arrSort.by === "xp");
    if(!isXpSort) return;
    if(resortTimers[which]) clearTimeout(resortTimers[which]);
    resortTimers[which] = setTimeout(async () => {
      resortTimers[which] = null;
      if(which === "dep"){
        lastDeps = sortFlights(lastDeps, settings.depSort, "dep");
        await depBoard.render(lastDeps);
      }else{
        lastArrs = sortFlights(lastArrs, settings.arrSort, "arr");
        await arrBoard.render(lastArrs);
      }
      scheduleAirportXpIndexUpdate();
    }, 650);
  }

  // Fair scheduling (interleaving)
  function requestXpForVisibleFlights(){
    const max = 45; // Hardcoded limit per cycle to protect API

    // Collect candidates from ALL airports (background processing)
    const allCandidates = [];
    for(const store of Object.values(flightStore)){
       if(store.deps) allCandidates.push(...store.deps);
       if(store.arrs) allCandidates.push(...store.arrs);
    }

    // Slice to max limit per cycle
    const targets = allCandidates.slice(0, max);

    for(const f of targets){
      applyCachedXpIfAvailable(f);
      depBoard.updateXpById(f.id);
      arrBoard.updateXpById(f.id);
    }
    scheduleAirportXpIndexUpdate();

    const uniqueCids = new Set(targets.map(f => String(f.cid)));
    for(const cid of uniqueCids){
      const entry = getCacheEntry(cid);
      if(isCoolingDown(entry)) continue;

      const needDetails = xpUsesAgeBonus();
      const haveDetails = !needDetails || (entry?.details && isFresh(entry.detailsTs, settings.memberTtlDetailsMs));
      const haveStats = entry?.stats && isFresh(entry.statsTs, settings.memberTtlStatsMs);
      if(haveDetails && haveStats) continue; // only fetch what's required

      ensureXpForCid(cid).then(({details, stats, exp}) => {
        const refs = flightsByCid.get(String(cid)) || [];
        for(const f of refs){
          f.details = details;
          f.stats = stats;
          f.exp = exp;
          depBoard.updateXpById(f.id);
          arrBoard.updateXpById(f.id);
        }
        scheduleResort("dep");
        scheduleResort("arr");
        scheduleAirportXpIndexUpdate();
      }).catch(() => {});
    }
  }

  async function refresh(){
    try{
      const data = await fetchFeed();
      renderEpoch++;

      lastFeedTs = data?.general?.update_timestamp ? new Date(data.general.update_timestamp) : null;

      const pilots = Array.isArray(data?.pilots) ? data.pilots : [];
      const prefiles = (settings.showPrefiles && Array.isArray(data?.prefiles)) ? data.prefiles : [];

      // Prepare new store
      const newStore = {};
      flightsByCid = new Map();

      const nextPrev = new Map(prevPilotStates);

      // Pre-process positions for next loop
      for(const p of pilots){
         nextPrev.set(String(p.cid), { alt:Number(p.altitude||0), lat:Number(p.latitude), lon:Number(p.longitude), t: Date.now() });
       }

      // LOOP THROUGH ALL CONFIGURED AIRPORTS
      for(const airportIcao of settings.airports){
          const focus = airportIcao;
          const focusAp = getAirport(focus);

          // Update global state for helper functions (they rely on currentAirportIcao)
          currentAirportIcao = focus;

          updateSurfaceTrafficModel(pilots, focus, focusAp);

          const deps = [];
          const arrs = [];

          for(const p of pilots){
            const fp = p.flight_plan;
            if(!fp?.departure || !fp?.arrival) continue;

            const dep = normalizeCode(fp.departure);
            const arr = normalizeCode(fp.arrival);

            if(dep === focus){
              const f = buildFlightObjectFromPilot(p);
              f.status = classifyFlight(p, "dep");
              if(f.status.cls === "hidden") continue;

              if(focusAp && isFinite(p.latitude) && isFinite(p.longitude)) f.dFromFocusNm = haversineNm(Number(p.latitude), Number(p.longitude), focusAp.latitude, focusAp.longitude);
              const arrAp = getAirport(arr);
              if(arrAp) f.dToPlanNm = haversineNm(Number(p.latitude), Number(p.longitude), arrAp.latitude, arrAp.longitude);
              applyEtdForDepFlight(f);
              applyDestEtaForDepFlight(f);
              applyCachedXpIfAvailable(f);
              if(!(settings.hideDeparturesFinished && f.status.finished)){
                deps.push(f);
                if(!flightsByCid.has(String(f.cid))) flightsByCid.set(String(f.cid), []);
                flightsByCid.get(String(f.cid)).push(f);
              }
            }

            if(arr === focus){
              const f = buildFlightObjectFromPilot(p);
              f.status = classifyFlight(p, "arr");
              if(focusAp && isFinite(p.latitude) && isFinite(p.longitude)) f.dToFocusNm = haversineNm(Number(p.latitude), Number(p.longitude), focusAp.latitude, focusAp.longitude);
              const depAp = getAirport(dep);
              if(depAp) f.dFromPlanNm = haversineNm(Number(p.latitude), Number(p.longitude), depAp.latitude, depAp.longitude);
              applyEtaForFlight(f, focusAp, "arr");
              applyCachedXpIfAvailable(f);
              if(!(settings.hideArrivalsLanded && f.status.finished)){
                arrs.push(f);
                if(!flightsByCid.has(String(f.cid))) flightsByCid.set(String(f.cid), []);
                flightsByCid.get(String(f.cid)).push(f);
              }
            }
          }

          if(settings.showPrefiles){
             for(const pf of prefiles){
               const fp = pf.flight_plan;
               if(!fp?.departure || !fp?.arrival) continue;
               const dep = normalizeCode(fp.departure);
               const arr = normalizeCode(fp.arrival);
               if(dep === focus){
                 const f = buildFlightObjectFromPrefile(pf);
                 f.status = classifyFlight({ ...f.pilot, cid: f.cid, flight_plan: f.fp }, "dep");
                 applyEtdForDepFlight(f);
                 applyDestEtaForDepFlight(f);
                 applyCachedXpIfAvailable(f);
                 deps.push(f);
                 if(!flightsByCid.has(String(f.cid))) flightsByCid.set(String(f.cid), []);
                 flightsByCid.get(String(f.cid)).push(f);
               }
               if(arr === focus){
                 const f = buildFlightObjectFromPrefile(pf);
                 f.status = classifyFlight({ ...f.pilot, cid: f.cid, flight_plan: f.fp }, "arr");
                 applyCachedXpIfAvailable(f);
                 arrs.push(f);
                 if(!flightsByCid.has(String(f.cid))) flightsByCid.set(String(f.cid), []);
                 flightsByCid.get(String(f.cid)).push(f);
               }
             }
          }

          // Sort individually for this airport context
          // NOTE: sorting uses global 'lastDeps' internally in sort functions if we were reusing them incorrectly,
          // but sortFlights takes list as arg. However, sortFlights uses 'depDisplayTimeTs' which uses global state? No.
          // Wait, sortFlights is pure func.
          flightStore[focus] = {
             deps: sortFlights(deps, settings.depSort, "dep"),
             arrs: sortFlights(arrs, settings.arrSort, "arr")

          };

          // Calc XP stats for this airport immediately
          updateTabsXpMetadata();

          // Prefetch OSM data for next cycle or usage
          prefetchGateIndexesForArrOrigins(arrs);
      }

      prevPilotStates = nextPrev;
      pruneStatusMemory();
          pruneGateMem();
          pruneEtdMemory();
          pruneTaxiMem();

      // Finally render the active one
      await renderBoardsFromStore();

      requestXpForVisibleFlights();

      const ageSec = lastFeedTs ? (Date.now() - lastFeedTs.getTime())/1000 : null;
      setFeedStatus({ ok:true, msg:"Feed: OK", ageSec });
    }catch(err){
      console.warn("Feed refresh failed:", err);
      setFeedStatus({ ok:false, msg:"Feed: ERROR", ageSec:null });
      scheduleAirportXpIndexUpdate();
    }
  }

  function startLoop(){
    if(feedTimer) clearInterval(feedTimer);
    feedTimer = setInterval(refresh, settings.feedIntervalMs);
  }

  function updateUtcClock(){
    utcClockEl.textContent = new Date().toISOString().slice(11,19);
    if(lastFeedTs){
      const ageSec = (Date.now() - lastFeedTs.getTime())/1000;
      feedAge.textContent = `${Math.max(0, Math.round(ageSec))}s`;
    }
  }
  setInterval(updateUtcClock, 250);


  /********************
   * Events
   ********************/

  let fsStage = 0; // 0: normal, 1: app-stretch, 2: browser-fs
  fullscreenBtn.addEventListener("click", async () => {
    fsStage++;
    if (fsStage > 2) fsStage = 0;

    if (fsStage === 1) {
      // Stage 1: Stretch App
      document.body.classList.add("app-full");
      fullscreenBtn.textContent = "⛶";
      fullscreenBtn.title = "Browser Vollbild";
      fullscreenBtn.style.color = "var(--primary)";
    }
    else if (fsStage === 2) {
      // Stage 2: Browser Fullscreen
      try {
        if (document.documentElement.requestFullscreen) {
          await document.documentElement.requestFullscreen();
        }
      } catch (e) { console.warn("FS denied", e); }
      fullscreenBtn.textContent = "✕";
      fullscreenBtn.title = "Vollbild beenden";
      fullscreenBtn.style.color = "var(--bad)";
    }
    else {
      // Stage 0: Back to normal
      document.body.classList.remove("app-full");
      if (document.fullscreenElement) {
        document.exitFullscreen().catch(()=>{});
      }
      fullscreenBtn.textContent = "⛶";
      fullscreenBtn.title = "Anwendung strecken";
      fullscreenBtn.style.color = "";
    }
  });

  // Handle Escape key or manual exit of browser fullscreen
  document.addEventListener("fullscreenchange", () => {
    if (!document.fullscreenElement && fsStage === 2) {
      fullscreenBtn.click(); // Reset to normal
    }
  });

  refreshBtn.addEventListener("click", refresh);

  depSortEl.addEventListener("change", () => { settings.depSort.by = depSortEl.value; saveSettings(); refresh(); });
  depDirBtn.addEventListener("click", () => { settings.depSort.dir *= -1; depDirBtn.textContent = settings.depSort.dir === 1 ? "▲" : "▼"; saveSettings(); refresh(); });

  arrSortEl.addEventListener("change", () => { settings.arrSort.by = arrSortEl.value; saveSettings(); refresh(); });
  arrDirBtn.addEventListener("click", () => { settings.arrSort.dir *= -1; arrDirBtn.textContent = settings.arrSort.dir === 1 ? "▲" : "▼"; saveSettings(); refresh(); });

  /********************
   * Boot
   ********************/
  async function boot(){
    depDirBtn.textContent = settings.depSort.dir === 1 ? "▲" : "▼";
    arrDirBtn.textContent = settings.arrSort.dir === 1 ? "▲" : "▼";

    memberCache = await loadMemberCache();
    gateFlightCache = await loadGateFlightCache();
    await TaxiTimeManager.load();

    await ensureAirportIndex();

    await loadEtdCache();
    loadFlightStateCache();
    applyLanguage();      // sets UI + sort options + headers + legend
    setFeedStatus({ ok:true, msg:"Feed: …", ageSec:null });

        await initTabs();
    await refresh();
    startLoop();
  }
  boot();
})();
</script>
</body>
</html>