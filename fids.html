<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VATSIM FIDS (V3.3 Elevation Aware)</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-root: #0f1115;
      --bg-gradient: radial-gradient(circle at 50% 0%, #1e293b 0%, #0f1115 60%);
      --glass-surface: rgba(30, 41, 59, 0.65);
      --glass-border: rgba(255, 255, 255, 0.08);
      --glass-highlight: rgba(255, 255, 255, 0.03);
      --primary: #3b82f6; --primary-dim: rgba(59, 130, 246, 0.15);
      --text-main: #f1f5f9; --text-muted: #94a3b8;
      --good: #10b981; --good-bg: rgba(16, 185, 129, 0.15);
      --warn: #f59e0b; --warn-bg: rgba(245, 158, 11, 0.15);
      --bad: #ef4444;  --bad-bg: rgba(239, 68, 68, 0.15);
      --info: #0ea5e9; --info-bg: rgba(14, 165, 233, 0.15);
      --font-ui: 'Inter', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
    }

    * { box-sizing: border-box; }
    body { margin: 0; background-color: var(--bg-root); background-image: var(--bg-gradient); background-attachment: fixed; color: var(--text-main); font-family: var(--font-ui); padding-bottom: 60px; min-height: 100vh; -webkit-font-smoothing: antialiased; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.25); }

    header { position: sticky; top: 0; z-index: 50; background: rgba(15, 17, 21, 0.85); border-bottom: 1px solid var(--glass-border); backdrop-filter: blur(16px); box-shadow: 0 4px 20px rgba(0,0,0,0.2); }
    .wrap { max-width: 1600px; margin: 0 auto; padding: 12px 20px; }
    .topbar { display: flex; gap: 20px; align-items: center; justify-content: space-between; flex-wrap: wrap; }
    .brand { display: flex; flex-direction: column; }
    .brand h1 { margin: 0; font-size: 20px; font-weight: 700; letter-spacing: -0.02em; background: linear-gradient(90deg, #fff, #94a3b8); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    .brand .sub { font-size: 11px; color: var(--text-muted); font-family: var(--font-mono); text-transform: uppercase; letter-spacing: 0.05em; margin-top: 2px; }

    .xpIndexBar { display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; }
    .xpIndexBar .pill { padding: 6px 10px; }
    .xpIndexBar .idxLbl { font-family: var(--font-mono); font-size: 11px; font-weight: 700; letter-spacing: 0.05em; text-transform: uppercase; }
    .xpIndexBar .idxVal { font-family: var(--font-mono); font-size: 12px; font-weight: 800; color: #fff; }
    .xpIndexBar .idxCnt { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); }

    .controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; justify-content: flex-end; }

    label { font-size: 11px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; }
    input, select, button { background: rgba(0,0,0,0.3); color: var(--text-main); border: 1px solid var(--glass-border); border-radius: 8px; padding: 8px 12px; font-size: 13px; outline: none; font-family: var(--font-ui); transition: all 0.2s ease; }
    input:focus, select:focus { border-color: var(--primary); box-shadow: 0 0 0 2px var(--primary-dim); background: rgba(0,0,0,0.5); }
    input { font-family: var(--font-mono); text-transform: uppercase; font-weight: 600; letter-spacing: 0.05em; width: 80px; text-align: center; }
    button { cursor: pointer; font-weight: 600; background: rgba(255,255,255,0.03); }
    button:hover { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.2); }
    button:active { transform: translateY(1px); }

    .pill { font-family: var(--font-mono); font-size: 11px; padding: 6px 12px; border-radius: 6px; border: 1px solid var(--glass-border); background: rgba(0,0,0,0.2); color: var(--text-muted); display: inline-flex; gap: 8px; align-items: center; white-space: nowrap; }
    .pill.clockPill { background: rgba(14, 165, 233, 0.08); border-color: rgba(14, 165, 233, 0.2); color: #bae6fd; }
    #utcClock { font-weight: 700; color: #fff; letter-spacing: 0.05em; }
    .dot { width: 6px; height: 6px; border-radius: 50%; background: var(--text-muted); box-shadow: 0 0 5px rgba(255,255,255,0.1); }
    .dot.good { background: var(--good); box-shadow: 0 0 6px var(--good); }
    .dot.warn { background: var(--warn); box-shadow: 0 0 6px var(--warn); }
    .dot.bad { background: var(--bad); box-shadow: 0 0 6px var(--bad); }
    .dot.info { background: var(--info); box-shadow: 0 0 6px var(--info); }

    main .wrap { padding-top: 24px; padding-bottom: 40px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
    @media (max-width: 1100px) { .grid { grid-template-columns: 1fr; } }

    .board { background: var(--glass-surface); backdrop-filter: blur(12px); border: 1px solid var(--glass-border); border-radius: 16px; overflow: hidden; box-shadow: 0 20px 40px rgba(0,0,0,0.3); display: flex; flex-direction: column; min-height: 500px; }
    .boardHeader { display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--glass-border); background: rgba(255,255,255,0.02); }
    .boardHeader h2 { margin: 0; font-size: 14px; letter-spacing: 0.1em; text-transform: uppercase; font-weight: 700; color: var(--text-main); display: flex; align-items: center; gap: 8px; }
    .boardHeader h2::before { content:''; display:block; width:4px; height:16px; background:var(--primary); border-radius:2px; }
    .boardHeader .mini { display: flex; gap: 8px; align-items: center; }
    .hint { font-size: 11px; color: var(--text-muted); font-weight: 500; }

    table { width: 100%; border-collapse: collapse; font-family: var(--font-mono); font-size: 12px; table-layout: fixed; }

    thead th {
      text-align: left; color: var(--text-muted); font-weight: 600; font-size: 11px; text-transform: uppercase; letter-spacing: 0.05em;
      padding: 12px 16px; border-bottom: 1px solid var(--glass-border); background: rgba(15, 17, 21, 0.95); position: sticky; top: 0; z-index: 10; backdrop-filter: blur(10px);
    }

    tbody tr { transition: background 0.15s, transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1); will-change: transform, opacity; border-bottom: 1px solid rgba(255,255,255,0.03); }
    tbody tr:last-child { border-bottom: none; }
    tbody tr:hover { background: var(--glass-highlight); }

    tbody td {
      padding: 10px 16px; vertical-align: middle; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-main);
    }

    .cell-route { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: help; }
    .cell-route .muted { opacity: 0.6; font-size: 11px; }

    tbody tr.removing { opacity: 0; transform: scale(0.98) translateY(-10px); pointer-events: none; }
    tbody tr.adding { opacity: 0; transform: translateY(10px); }
    tbody tr.finishedRow { opacity: 0.5; filter: grayscale(0.6); }
    tbody tr.finishedRow:hover { opacity: 0.8; }

    .right { text-align: right; }
    .center { text-align: center; }
    .muted { color: var(--text-muted); }

    .badge { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 99px; font-size: 11px; font-weight: 600; letter-spacing: 0.02em; border: 1px solid transparent; transition: all 0.3s ease; }
    .badge .sDot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; opacity: 0.8; }
    .badge.good { background: var(--good-bg); color: var(--good); border-color: rgba(16, 185, 129, 0.2); }
    .badge.warn { background: var(--warn-bg); color: var(--warn); border-color: rgba(245, 158, 11, 0.2); }
    .badge.bad  { background: var(--bad-bg); color: var(--bad); border-color: rgba(239, 68, 68, 0.2); }
    .badge.info { background: var(--info-bg); color: var(--info); border-color: rgba(14, 165, 233, 0.2); }
    .badge.blink { animation: pulseGlow 1.5s infinite; }
    @keyframes pulseGlow { 0% { box-shadow: 0 0 0 0 rgba(255,255,255,0.1); } 70% { box-shadow: 0 0 0 6px rgba(255,255,255,0); } 100% { box-shadow: 0 0 0 0 rgba(255,255,255,0); } }

    .xpPill { display: inline-flex; align-items: center; gap: 6px; padding: 3px 8px; border-radius: 6px; font-size: 11px; font-weight: 600; border: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.2); cursor: help; user-select: none; transition: 0.2s; }
    .xpPill:hover { background: rgba(255,255,255,0.05); border-color: rgba(255,255,255,0.2); }
    .xpPill .xDot { width: 6px; height: 6px; border-radius: 50%; }
    .xpPill.good .xDot { background: var(--good); box-shadow: 0 0 5px var(--good); }
    .xpPill.warn .xDot { background: var(--warn); box-shadow: 0 0 5px var(--warn); }
    .xpPill.bad  .xDot { background: var(--bad);  box-shadow: 0 0 5px var(--bad); }
    .xpPill.info .xDot { background: var(--info); box-shadow: 0 0 5px var(--info); }
    .xpPill.missing { opacity: 0.5; background: rgba(255,255,255,0.02); border-color: transparent; cursor: default; }
    .xpPill.missing .xDot { background: var(--text-muted); }
    .xpPill.loading { opacity: 0.6; cursor: wait; }
    .xpPill .spinner { width: 10px; height: 10px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.1); border-top-color: #fff; animation: spin 0.8s linear infinite; }
    @keyframes spin { to{ transform: rotate(360deg); } }

    .dayPlus { margin-left: 4px; font-size: 10px; color: var(--text-muted); font-family: var(--font-mono); }

    .tooltip { position: fixed; z-index: 100; pointer-events: none; background: rgba(15, 23, 42, 0.95); border: 1px solid rgba(255,255,255,0.1); padding: 12px; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); font-family: var(--font-mono); font-size: 12px; line-height: 1.5; color: #e2e8f0; opacity: 0; transform: translate(-50%, -115%) scale(0.95); transition: opacity 0.15s, transform 0.15s; white-space: pre; backdrop-filter: blur(8px); }
    .tooltip.show { opacity: 1; transform: translate(-50%, -115%) scale(1); }

    .modalOverlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); backdrop-filter: blur(5px); display: none; align-items: center; justify-content: center; z-index: 200; padding: 20px; animation: fadeIn 0.2s ease-out; }
    @keyframes fadeIn { from{opacity:0;} to{opacity:1;} }
    .modalOverlay.show { display: flex; }
    .modal { width: min(800px, 100%); background: #1e293b; border: 1px solid rgba(255,255,255,0.1); border-radius: 16px; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5); overflow: hidden; display: flex; flex-direction: column; }
    .modalHead { padding: 16px 24px; background: rgba(0,0,0,0.2); border-bottom: 1px solid rgba(255,255,255,0.05); display: flex; justify-content: space-between; align-items: center; }
    .modalHead h3 { margin: 0; font-size: 16px; color: #fff; letter-spacing: 0.05em; text-transform: uppercase; }
    .modalHead .close { background: transparent; border: none; font-size: 20px; padding: 4px; color: var(--text-muted); }
    .modalHead .close:hover { color: #fff; background: rgba(255,255,255,0.1); }
    .modalBody { padding: 24px; display: grid; grid-template-columns: 1.2fr 0.8fr; gap: 24px; overflow-y: auto; max-height: 80vh; }
    @media (max-width: 800px) { .modalBody { grid-template-columns: 1fr; } }
    .card { background: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.05); border-radius: 12px; padding: 16px; }
    .card h4 { margin: 0 0 16px 0; font-size: 11px; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 8px; }
    .kv { display: grid; grid-template-columns: 140px 1fr; gap: 8px; font-family: var(--font-mono); font-size: 13px; }
    .kv .k { color: var(--text-muted); }
    .kv .v { color: #fff; overflow-wrap: anywhere; }
    .list { margin: 0; padding-left: 20px; font-family: var(--font-mono); font-size: 12px; color: var(--text-muted); line-height: 1.6; }
    .list li { margin-bottom: 6px; }
    .linkRow { margin-top: 16px; display: flex; gap: 10px; }
    .aBtn { display: inline-flex; align-items: center; padding: 8px 16px; border-radius: 6px; background: var(--primary-dim); color: var(--primary); text-decoration: none; font-size: 12px; font-weight: 600; border: 1px solid rgba(59, 130, 246, 0.2); transition: 0.2s; }
    .aBtn:hover { background: var(--primary); color: #fff; }

    .formGrid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .field { display: flex; flex-direction: column; gap: 6px; }
    .field input[type="text"], .field input[type="number"], .field select { width: 100%; text-align: left; }
    .fieldRow { display: flex; flex-wrap: wrap; gap: 12px; font-size: 13px; color: var(--text-muted); align-items: center; }
    .btnRow { display: flex; justify-content: flex-end; gap: 10px; margin-top: 24px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.05); }
    .btnGhost { background: transparent; border: 1px solid transparent; color: var(--text-muted); }
    .btnGhost:hover { color: #fff; background: rgba(255,255,255,0.05); }
    .btnPrimary { background: var(--primary); color: #fff; border-color: transparent; }
    .btnPrimary:hover { background: #2563eb; }
    .btnDanger { color: var(--bad); background: rgba(239, 68, 68, 0.1); border-color: transparent; }
    .btnDanger:hover { background: var(--bad); color: #fff; }

    /* Config Tabs + Column Layout UI */
    .tabs { display:flex; gap:8px; padding: 0 2px 14px; margin-bottom: 14px; border-bottom: 1px solid rgba(255,255,255,0.07); flex-wrap:wrap; }
    .tabBtn { padding: 8px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03); color: var(--text-muted); font-weight: 700; font-size: 12px; cursor: pointer; }
    .tabBtn:hover { color: #fff; border-color: rgba(255,255,255,0.18); background: rgba(255,255,255,0.06); }
    .tabBtn.active { color: #fff; background: rgba(59,130,246,0.18); border-color: rgba(59,130,246,0.35); }
    .tabPanel { display:none; }
    .tabPanel.active { display:block; }

    .colHelp { font-size: 12px; color: var(--text-muted); margin-bottom: 10px; }
    .colList { display:flex; flex-direction:column; gap:8px; }
    .colItem { display:flex; align-items:center; gap:10px; padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.08); background: rgba(0,0,0,0.16); }
    .colItem .name { flex:1; font-family: var(--font-mono); font-size: 12px; color:#e2e8f0; }
    .colItem .miniBtns { display:flex; gap:6px; }
    .colItem .miniBtns button { padding: 6px 10px; border-radius: 10px; font-family: var(--font-mono); }

    footer.legendBar { position: fixed; bottom: 0; left: 0; right: 0; z-index: 60; background: rgba(15, 17, 21, 0.9); backdrop-filter: blur(12px); border-top: 1px solid var(--glass-border); font-family: var(--font-mono); font-size: 11px; }
    .legendInner { max-width: 1600px; margin: 0 auto; padding: 10px 20px; display: flex; flex-wrap: wrap; gap: 16px; align-items: center; color: var(--text-muted); }
    .legendTitle { font-weight: 700; color: #fff; text-transform: uppercase; letter-spacing: 0.05em; }
    .legendNote { margin-left: auto; opacity: 0.7; }
  </style>
</head>
<body>

<header>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <h1 id="brandTitle">VATSIM FIDS</h1>
        <div class="sub" id="brandSub">Local Board · V3.3 Elevation Aware</div>
      </div>

      <!-- Airport Pilot XP Index (DEP/ARR) -->
      <div class="xpIndexBar" id="xpIndexBar" aria-label="Pilot XP Index">
        <span class="pill" id="depXpIndexPill" title="">
          <span class="dot info" id="depXpIndexDot"></span>
          <span class="idxLbl" id="depXpIndexLbl">DEP XP</span>
          <span class="idxVal" id="depXpIndexVal">—</span>
          <span class="idxCnt" id="depXpIndexCnt">0/0</span>
        </span>
        <span class="pill" id="arrXpIndexPill" title="">
          <span class="dot info" id="arrXpIndexDot"></span>
          <span class="idxLbl" id="arrXpIndexLbl">ARR XP</span>
          <span class="idxVal" id="arrXpIndexVal">—</span>
          <span class="idxCnt" id="arrXpIndexCnt">0/0</span>
        </span>
      </div>

      <div class="controls">
        <div style="display:flex; flex-direction:column; gap:2px;">
          <label for="airportInput" id="airportInputLabel">Airport (ICAO)</label>
          <div style="display:flex; gap:0;">
            <input id="airportInput" value="EDDB" maxlength="4" spellcheck="false" style="border-radius:6px 0 0 6px; border-right:none;" />
            <button id="applyAirportBtn" title="Airport sofort anwenden" style="border-radius:0 6px 6px 0;">Go</button>
          </div>
        </div>

        <span class="pill clockPill" id="utcPill" title="Uhrzeit in UTC">
          <span class="dot info"></span>
          <span>UTC</span>
          <span id="utcClock">--:--:--</span>
        </span>

        <span class="pill" id="feedPill" title="Status vom VATSIM-Datafeed">
          <span class="dot" id="feedDot"></span>
          <span id="feedText">Feed: —</span>
          <span class="muted" id="feedAge">—</span>
        </span>

        <span class="pill" id="apiPill" title="Core API Queue / Rate Limit">
          <span class="dot" id="apiDot"></span>
          <span id="apiText">API Q: —</span>
          <span class="muted" id="apiExtra">—</span>
        </span>

        <div style="height:24px; border-left:1px solid var(--glass-border); margin:0 8px;"></div>

        <button id="configBtn" title="Einstellungen">⚙</button>
        <button id="refreshBtn" title="Sofort neu laden">↻</button>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="wrap">
    <div class="grid">
      <section class="board">
        <div class="boardHeader">
          <h2 id="depTitle">Departures</h2>
          <div class="mini">
            <span class="hint" id="depSortHint">Sort:</span>
            <select id="depSort"></select>
            <button id="depDir" title="Sortierreihenfolge umkehren">▲</button>
          </div>
        </div>
        <table id="depTable">
          <thead><tr id="depHeadRow"></tr></thead>
          <tbody id="depBody"></tbody>
        </table>
      </section>

      <section class="board">
        <div class="boardHeader">
          <h2 id="arrTitle">Arrivals</h2>
          <div class="mini">
            <span class="hint" id="arrSortHint">Sort:</span>
            <select id="arrSort"></select>
            <button id="arrDir" title="Sortierreihenfolge umkehren">▲</button>
          </div>
        </div>
        <table id="arrTable">
          <thead><tr id="arrHeadRow"></tr></thead>
          <tbody id="arrBody"></tbody>
        </table>
      </section>
    </div>
  </div>
</main>

<div id="tooltip" class="tooltip" aria-hidden="true"></div>

<div id="pilotModalOverlay" class="modalOverlay" role="dialog" aria-modal="true">
  <div class="modal">
    <div class="modalHead">
      <div>
        <h3 id="pilotModalTitle">Pilot Analyse</h3>
        <div class="tiny" id="pilotModalSubtitle" style="color:var(--text-muted); font-size:12px; margin-top:4px;">—</div>
      </div>
      <button class="close" id="pilotModalClose">✕</button>
    </div>

    <div class="modalBody">
      <div style="display:flex; flex-direction:column; gap:20px;">
        <div class="card">
          <h4 id="pilotCardFlightData">Flight Data</h4>
          <div class="kv" id="flightKv"></div>
        </div>
        <div class="card">
          <h4 id="pilotCardStats">Pilot Stats & Heuristic</h4>
          <div class="kv" id="xpKv"></div>
          <div style="margin-top:16px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.1);">
            <h4 id="pilotCardBreakdown" style="margin-bottom:8px; border:none;">XP Breakdown</h4>
            <ul class="list" id="xpList"></ul>
          </div>
          <div class="linkRow" id="xpLinks"></div>
        </div>
      </div>

      <div class="card" style="height:fit-content;">
        <h4 id="pilotCardHistory">History (On Demand)</h4>
        <div class="tiny" id="historyNote" style="color:var(--text-muted); font-size:11px; margin-bottom:12px;">
          Daten werden live von der VATSIM API geladen um das Ratenlimit zu schonen.
        </div>
        <div class="kv" id="historyKv"></div>
      </div>
    </div>
  </div>
</div>

<div id="configModalOverlay" class="modalOverlay" role="dialog" aria-modal="true">
  <div class="modal" style="width: 700px;">
    <div class="modalHead">
      <h3 id="cfgModalTitle">Einstellungen</h3>
      <button class="close" id="configClose">✕</button>
    </div>

    <div class="modalBody" style="display:block;">
      <div class="tabs" role="tablist" aria-label="Config Tabs">
        <button class="tabBtn active" type="button" data-tab="general" id="cfgTabGeneral">Allgemein</button>
        <button class="tabBtn" type="button" data-tab="display" id="cfgTabDisplay">Anzeige</button>
        <button class="tabBtn" type="button" data-tab="xp" id="cfgTabXp">XP Score Thresholds</button>
      </div>

      <div class="tabPanel active" data-tab="general">
        <div class="card">
          <h4 id="cfgGeneralTitle">Allgemeine Konfiguration</h4>
          <div class="formGrid">
            <div class="field">
              <label for="cfgAirport" id="cfgAirportLabel">Airport (ICAO)</label>
              <input id="cfgAirport" type="text" maxlength="4" />
            </div>

            <div class="field">
              <label for="cfgInterval" id="cfgIntervalLabel">Refresh Rate (Sek.)</label>
              <input id="cfgInterval" type="number" min="5" max="120" step="1" />
            </div>

            <div class="field">
              <label for="cfgLanguage" id="cfgLanguageLabel">Sprache</label>
              <select id="cfgLanguage">
                <option value="de">Deutsch</option>
                <option value="en">English</option>
              </select>
            </div>

            <div class="field">
              <label for="cfgXpHydrate" id="cfgXpHydrateLabel">Max XP Hydrate / Cycle</label>
              <input id="cfgXpHydrate" type="number" min="10" max="120" step="5" />
            </div>

            <div class="field" style="grid-column:1/-1">
              <label id="cfgFilterLabel">Filter & Darstellung</label>
              <div class="fieldRow" style="padding:8px 0;">
                <label style="display:flex; gap:8px; cursor:pointer;"><input id="cfgPrefiles" type="checkbox" /> <span id="cfgPrefilesText">Prefiles anzeigen</span></label>
                <label style="display:flex; gap:8px; cursor:pointer;"><input id="cfgHideArrLanded" type="checkbox" /> <span id="cfgHideArrText">Arr: Gelandete ausblenden</span></label>
                <label style="display:flex; gap:8px; cursor:pointer;"><input id="cfgHideDepFinished" type="checkbox" /> <span id="cfgHideDepText">Dep: Beendete ausblenden</span></label>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="tabPanel" data-tab="display">
        <div class="card">
          <h4 id="cfgDisplayTitle">Anzeige</h4>
          <div class="colHelp" id="cfgDisplayHelp">Spalten ein-/ausblenden und Reihenfolge anpassen (wirkt nach „Speichern“).</div>

          <div style="display:grid; grid-template-columns: 1fr 1fr; gap:16px;">
            <div>
              <div class="colHelp" style="margin:0 0 8px 0; font-weight:700; letter-spacing:.08em; text-transform:uppercase;" id="cfgDisplayDepTitle">Departures Board</div>
              <div class="colList" id="cfgDepCols"></div>
            </div>
            <div>
              <div class="colHelp" style="margin:0 0 8px 0; font-weight:700; letter-spacing:.08em; text-transform:uppercase;" id="cfgDisplayArrTitle">Arrivals Board</div>
              <div class="colList" id="cfgArrCols"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="tabPanel" data-tab="xp">
        <div class="card">
          <h4 id="cfgXpTitle">XP Score Thresholds (0-100)</h4>
          <div class="formGrid" style="grid-template-columns: 1fr 1fr 1fr 1fr;">
            <div class="field"><label id="cfgT1Label">T1 (Neu)</label><input id="cfgT1" type="number" /></div>
            <div class="field"><label id="cfgT2Label">T2 (Start)</label><input id="cfgT2" type="number" /></div>
            <div class="field"><label id="cfgT3Label">T3 (Fortg.)</label><input id="cfgT3" type="number" /></div>
            <div class="field"><label id="cfgT4Label">T4 (Erf.)</label><input id="cfgT4" type="number" /></div>
          </div>
        </div>
      </div>

      <div class="btnRow">
        <button id="cfgResetCache" class="btnDanger" type="button">Cache Reset</button>
        <button id="cfgDefaults" class="btnGhost" type="button">Standard</button>
        <button id="cfgCancel" class="btnGhost" type="button">Abbrechen</button>
        <button id="cfgSave" class="btnPrimary" type="button">Speichern</button>
      </div>
    </div>
  </div>
</div>

<footer class="legendBar" aria-hidden="true">
  <div class="legendInner" id="legendInner"></div>
</footer>

<script>
(() => {
  /********************
   * Endpoints / Daten
   ********************/
  const VATSIM_DATA_URL = "https://data.vatsim.net/v3/vatsim-data.json";
  const CORE_API_BASE = "https://api.vatsim.net/v2";
  const CORS_PROXY = "https://corsproxy.io/?url=";
  const AIRPORTS_URL = "https://cdn.jsdelivr.net/npm/airport-data@1.0.1/airports.json";

  /********************
   * i18n
   ********************/
  const I18N = {
    de: {
      brand_sub: "Local Board · V3.3 Elevation Aware",
      airport_label: "Airport (ICAO)",
      apply_airport_title: "Airport sofort anwenden",
      cfg_title: "Einstellungen",
      refresh_title: "Sofort neu laden",
      config_title: "Einstellungen",
      dep_title: "Abflüge",
      arr_title: "Ankünfte",
      sort_hint: "Sort:",
      sort_status: "Status (Smart)",
      sort_time_std: "STD (Time)",
      sort_time_eta: "ETA (Heur.)",
      sort_callsign: "Callsign",
      sort_dest: "Destination",
      sort_orig: "Origin",
      sort_xp: "Pilot XP",
      th_time_std: "STD",
      th_time_eta: "ETA",
      th_to: "Nach",
      th_from: "Von",
      th_callsign: "Callsign",
      th_type_route: "Typ / Route",
      th_alt_gs: "Alt/GS",
      th_status: "Status",
      th_xp: "XP",
      utc_title: "Uhrzeit in UTC",
      feed_title: "Status vom VATSIM-Datafeed",
      api_title: "Core API Queue / Rate Limit",
      dep_dir_title: "Sortierreihenfolge umkehren",
      arr_dir_title: "Sortierreihenfolge umkehren",
      btn_cache_reset: "Cache Reset",
      btn_defaults: "Standard",
      btn_cancel: "Abbrechen",
      btn_save: "Speichern",
      cfg_tab_general: "Allgemein",
      cfg_tab_display: "Anzeige",
      cfg_tab_xp: "XP Score Thresholds",
      cfg_general_title: "Allgemeine Konfiguration",
      cfg_airport: "Airport (ICAO)",
      cfg_interval: "Refresh Rate (Sek.)",
      cfg_language: "Sprache",
      cfg_xp_hydrate: "Max XP Hydrate / Cycle",
      cfg_filter: "Filter & Darstellung",
      cfg_prefiles: "Prefiles anzeigen",
      cfg_hide_arr: "Arr: Gelandete ausblenden",
      cfg_hide_dep: "Dep: Beendete ausblenden",
      cfg_display_title: "Anzeige",
      cfg_display_help: "Spalten ein-/ausblenden und Reihenfolge anpassen (wirkt nach „Speichern“).",
      cfg_display_dep: "Departures Board",
      cfg_display_arr: "Arrivals Board",
      cfg_xp_title: "XP Score Thresholds (0-100)",
      cfg_t1: "T1 (Neu)",
      cfg_t2: "T2 (Start)",
      cfg_t3: "T3 (Fortg.)",
      cfg_t4: "T4 (Erf.)",
      pilot_modal_title: "Pilot Analyse",
      pilot_card_flight: "Flight Data",
      pilot_card_stats: "Pilot Stats & Heuristic",
      pilot_card_breakdown: "XP Breakdown",
      pilot_card_history: "History (On Demand)",
      history_note: "Daten werden live von der VATSIM API geladen um das Ratenlimit zu schonen.",
      kv_callsign: "Callsign",
      kv_cid: "CID",
      kv_name: "Name",
      kv_route: "Route",
      kv_type: "Type",
      kv_std: "STD (deptime)",
      kv_eet: "EET",
      kv_eta: "ETA (heur.)",
      kv_status: "Status",
      kv_last_updated: "Last Updated",
      kv_experience: "Experience",
      kv_registered: "Registriert",
      kv_pilot_hours: "Pilot hours",
      kv_atc_hours: "ATC hours",
      kv_atc_weighted: "ATC weighted",
      kv_region_div: "Region/Division",
      kv_sessions_ret: "Sessions (returned)",
      kv_sessions_count: "Sessions (count)",
      kv_last_end: "Letzte beendete Session",
      kv_note: "Hinweis",
      history_unavailable: "Nicht verfügbar (404/Hidden).",
      history_error: "Konnte nicht geladen werden (Rate Limit / API Fehler).",
      history_note_kv: "History zeigt vergangene Sessions; aktuelle Session steht im Live-Feed.",
      xp_na: "N/A",
      xp_loading: "Pilot-Experience lädt…",
      xp_missing_tip: "Daten nicht verfügbar (404/Hidden).",
      xp_missing_reasons_1: "Daten nicht verfügbar (API 404/Hidden).",
      xp_missing_reasons_2: "Erneuter Versuch in einigen Minuten.",
      xp_reason_pilot: "Pilot-Zeit: {h} (Faktor {f}).",
      xp_reason_atc: "ATC-Zeit: {h} (Bonusfaktor {f}).",
      xp_reason_reg: "Registriert seit: {d}.",
      xp_reason_reg_missing: "Registrierungsdatum nicht verfügbar.",
      tooltip_header: "CID: {cid} · Score: {score} · {label}",
      tooltip_reg: "Reg: {d}",
      tooltip_hours: "Pilot: {p} · ATC: {a}",
      legend_title: "Pilot XP",
      legend_note: "Heuristik: Reg.-Datum + Pilot/ATC-Stunden (ATC & Ratings höher gewichtet).",
      confirm_cache_reset: "Lokalen Member-Cache wirklich löschen?",
      xp_index_title: "Airport Pilot XP Index ({board})\nMittelwert der geladenen XP Scores der angezeigten Flüge.\nLoaded: {loaded}/{total}",
      status_gate: "AM GATE / TAXI",
      status_departing: "ABFLUG",
      status_climb: "STEIGFLUG",
      status_cruise: "REISEFLUG",
      status_descent: "SINKFLUG",
      status_approach: "ANFLUG",
      status_final: "FINAL",
      status_goaround: "DURCHSTART",
      status_deparea: "ABFLUGBEREICH",
      status_prefile: "PREFILE",
      status_landed: "GELANDET",
      status_landed_dest: "GELANDET (ZIEL)",
      status_diverted_at: "AUSGEWICHEN @ {icao}",
      status_on_ground_at: "AM BODEN @ {icao}",
      status_on_ground_unknown: "AM BODEN (UNBEKANNT)",
	  status_gate_named: "AM GATE {gate}",
	  status_landed_gate: "GELANDET (GATE {gate})",
	  status_taxi: "TAXI",
      status_gate_plain: "AM GATE",
      status_gate_named_at: "AM GATE {gate} @{icao}",


    },
    en: {
      brand_sub: "Local Board · V3.3 Elevation Aware",
      airport_label: "Airport (ICAO)",
      apply_airport_title: "Apply airport immediately",
      cfg_title: "Settings",
      refresh_title: "Refresh now",
      config_title: "Settings",
      dep_title: "Departures",
      arr_title: "Arrivals",
      sort_hint: "Sort:",
      sort_status: "Status (Smart)",
      sort_time_std: "STD (Time)",
      sort_time_eta: "ETA (Heur.)",
      sort_callsign: "Callsign",
      sort_dest: "Destination",
      sort_orig: "Origin",
      sort_xp: "Pilot XP",
      th_time_std: "STD",
      th_time_eta: "ETA",
      th_to: "To",
      th_from: "From",
      th_callsign: "Callsign",
      th_type_route: "Type / Route",
      th_alt_gs: "Alt/GS",
      th_status: "Status",
      th_xp: "XP",
      utc_title: "Time in UTC",
      feed_title: "VATSIM datafeed status",
      api_title: "Core API Queue / Rate Limit",
      dep_dir_title: "Toggle sort direction",
      arr_dir_title: "Toggle sort direction",
      btn_cache_reset: "Cache Reset",
      btn_defaults: "Defaults",
      btn_cancel: "Cancel",
      btn_save: "Save",
      cfg_tab_general: "General",
      cfg_tab_display: "Display",
      cfg_tab_xp: "XP Score Thresholds",
      cfg_general_title: "General Configuration",
      cfg_airport: "Airport (ICAO)",
      cfg_interval: "Refresh rate (sec.)",
      cfg_language: "Language",
      cfg_xp_hydrate: "Max XP hydrate / cycle",
      cfg_filter: "Filters & View",
      cfg_prefiles: "Show prefiles",
      cfg_hide_arr: "Arr: Hide landed",
      cfg_hide_dep: "Dep: Hide finished",
      cfg_display_title: "Display",
      cfg_display_help: "Toggle columns and adjust order (applies after “Save”).",
      cfg_display_dep: "Departures Board",
      cfg_display_arr: "Arrivals Board",
      cfg_xp_title: "XP Score Thresholds (0-100)",
      cfg_t1: "T1 (New)",
      cfg_t2: "T2 (Starter)",
      cfg_t3: "T3 (Advanced)",
      cfg_t4: "T4 (Experienced)",
      pilot_modal_title: "Pilot Analysis",
      pilot_card_flight: "Flight Data",
      pilot_card_stats: "Pilot Stats & Heuristic",
      pilot_card_breakdown: "XP Breakdown",
      pilot_card_history: "History (On Demand)",
      history_note: "Data is fetched live from the VATSIM API to preserve rate limits.",
      kv_callsign: "Callsign",
      kv_cid: "CID",
      kv_name: "Name",
      kv_route: "Route",
      kv_type: "Type",
      kv_std: "STD (deptime)",
      kv_eet: "EET",
      kv_eta: "ETA (heur.)",
      kv_status: "Status",
      kv_last_updated: "Last Updated",
      kv_experience: "Experience",
      kv_registered: "Registered",
      kv_pilot_hours: "Pilot hours",
      kv_atc_hours: "ATC hours",
      kv_atc_weighted: "ATC weighted",
      kv_region_div: "Region/Division",
      kv_sessions_ret: "Sessions (returned)",
      kv_sessions_count: "Sessions (count)",
      kv_last_end: "Last finished session",
      kv_note: "Note",
      history_unavailable: "Unavailable (404/Hidden).",
      history_error: "Could not load (rate limit / API error).",
      history_note_kv: "History shows past sessions; current session is in the live feed.",
      xp_na: "N/A",
      xp_loading: "Loading pilot experience…",
      xp_missing_tip: "Data not available (404/Hidden).",
      xp_missing_reasons_1: "Data not available (API 404/Hidden).",
      xp_missing_reasons_2: "Will retry in a few minutes.",
      xp_reason_pilot: "Pilot time: {h} (factor {f}).",
      xp_reason_atc: "ATC time: {h} (bonus factor {f}).",
      xp_reason_reg: "Registered since: {d}.",
      xp_reason_reg_missing: "Registration date not available.",
      tooltip_header: "CID: {cid} · Score: {score} · {label}",
      tooltip_reg: "Reg: {d}",
      tooltip_hours: "Pilot: {p} · ATC: {a}",
      legend_title: "Pilot XP",
      legend_note: "Heuristic: reg date + pilot/ATC hours (ATC & ratings weighted higher).",
      confirm_cache_reset: "Delete local member cache?",
      xp_index_title: "Airport Pilot XP Index ({board})\nAverage of loaded XP scores of the visible flights.\nLoaded: {loaded}/{total}",
      status_gate: "AT GATE / TAXI",
      status_departing: "DEPARTING",
      status_climb: "CLIMB",
      status_cruise: "CRUISE",
      status_descent: "DESCENT",
      status_approach: "APPROACH",
      status_final: "FINAL",
      status_goaround: "GO-AROUND",
      status_deparea: "DEPARTURE AREA",
      status_prefile: "PREFILE",
      status_landed: "LANDED",
      status_landed_dest: "LANDED (DEST)",
      status_diverted_at: "DIVERTED @ {icao}",
      status_on_ground_at: "ON GROUND @ {icao}",
      status_on_ground_unknown: "ON GROUND (UNKNOWN)",
	  status_gate_named: "AT GATE {gate}",
      status_landed_gate: "LANDED (GATE {gate})",
	  status_taxi: "TAXI",
      status_gate_plain: "AT GATE",
      status_gate_named_at: "AT GATE {gate} @{icao}",
    }
  };

  function lang(){ return (settings?.language === "en") ? "en" : "de"; }
  function t(key, vars){
    const d = I18N[lang()] || I18N.de;
    let s = (d[key] ?? I18N.de[key] ?? key);
    if(vars){
      for(const [k,v] of Object.entries(vars)){
        s = s.split(`{${k}}`).join(String(v));
      }
    }
    return s;
  }

  /********************
   * Persistenz
   ********************/
  const SETTINGS_KEY = "vatsimFids_settings_v4";
  const MEMBER_CACHE_KEY = "vatsimFids_memberCache_v2";
  const API_LAST_REQ_KEY = "vatsimFids_apiLastReqMs_v1";
  const MEMBER_404_TTL_MS = 5 * 60 * 1000;
  
  const GATE_CACHE_KEY = "vatsimFids_gateCache_v1";
const GATE_CACHE_TTL_MS = 7 * 24 * 3600 * 1000; // 7 Tage

const GATE_FLIGHT_CACHE_KEY = "vatsimFids_gateFlightCache_v1";
const GATE_FLIGHT_TTL_MS = 6 * 60 * 60 * 1000; // 6h: reicht für Reload/kurze Sessions

const OVERPASS_API = "https://overpass-api.de/api/interpreter";

// OSM Query / Matching
const OSM_GATE_QUERY_RADIUS_M = 7500;      // um Airport-Referenzpunkt
const GATE_MATCH_RADIUS_M = 50;            // max Distanz Gate <-> Flugposition

// Stationary / Taxi-Erkennung
const STATIONARY_WINDOW_MS = 60 * 1000;    // Sliding window
const STATIONARY_MIN_MS = 25 * 1000;       // "steht" erst nach mind. 25s
const STATIONARY_MAX_MOVE_M = 18;          // innerhalb Window max. 18m Bewegung
const STATIONARY_MAX_GS_KTS = 4;           // und GS <= 4kts
const TAXI_HIDE_GS_KTS = 8;                // sofort als "rolling" werten

// Schnellere Bewegungserkennung (Pushback/Taxi)
const RECENT_MOVE_WINDOW_MS = 12 * 1000;
const RECENT_MOVE_MAX_M = 12;

// Smoothing / Hysterese Gate-Label
const GATE_CONFIRM_MS = 20 * 1000;         // Kandidat muss 20s stabil sein
const GATE_STICKY_MS = 2 * 60 * 1000;      // einmal erkannt bleibt 2min sticky
const GATE_LOST_GRACE_MS = 60 * 1000;      // kurzzeitig "kein Kandidat" -> Gate behalten
const GATE_JITTER_GRACE_MS = 20 * 1000;    // kurzzeitig minimal bewegt -> Gate behalten

  const BOARD_COL_KEYS = ["time","callsign","ap","typeRoute","altgs","status","xp"];

  const DEFAULTS = {
    airportInput: "EDDB",
    feedIntervalMs: 15000,
    showPrefiles: false,
    hideArrivalsLanded: false,
    hideDeparturesFinished: false,
    xpHydrateMax: 20,
    depSort: { by:"status", dir: 1 },
    arrSort: { by:"status", dir: 1 },
    memberTtlStatsMs: 7 * 24 * 3600 * 1000,
    memberTtlDetailsMs: 30 * 24 * 3600 * 1000,
    xpThresholds: { t1:20, t2:40, t3:60, t4:80 },
    language: "de",
    boardLayout: {
      dep: { order: [...BOARD_COL_KEYS], visible: { time:true, callsign:true, ap:true, typeRoute:true, altgs:true, status:true, xp:true } },
      arr: { order: [...BOARD_COL_KEYS], visible: { time:true, callsign:true, ap:true, typeRoute:true, altgs:true, status:true, xp:true } }
    }
  };

  function clampInt(x, lo, hi){
    const n = Number(x);
    if(!isFinite(n)) return lo;
    return Math.max(lo, Math.min(hi, Math.round(n)));
  }

  function normalizeLayout(input, boardType){
    const def = structuredClone(DEFAULTS.boardLayout[boardType]);
    const src = (input && typeof input === "object") ? input : {};
    const visible = { ...def.visible, ...(src.visible || {}) };

    let order = Array.isArray(src.order) ? src.order.map(String) : def.order.slice();
    const seen = new Set();
    order = order.filter(k => BOARD_COL_KEYS.includes(k) && !seen.has(k) && (seen.add(k), true));
    for(const k of def.order){ if(!seen.has(k)) order.push(k); }
    return { order, visible };
  }

  function loadSettings(){
    try{
      const raw = localStorage.getItem(SETTINGS_KEY);
      if(!raw) return structuredClone(DEFAULTS);
      const s = JSON.parse(raw);
      const merged = { ...structuredClone(DEFAULTS), ...s };
      merged.depSort = { ...DEFAULTS.depSort, ...(s.depSort||{}) };
      merged.arrSort = { ...DEFAULTS.arrSort, ...(s.arrSort||{}) };
      merged.xpThresholds = { ...DEFAULTS.xpThresholds, ...(s.xpThresholds||{}) };
      merged.language = (s.language === "en") ? "en" : "de";
      merged.boardLayout = {
        dep: normalizeLayout(s.boardLayout?.dep, "dep"),
        arr: normalizeLayout(s.boardLayout?.arr, "arr")
      };
      return merged;
    }catch{
      return structuredClone(DEFAULTS);
    }
  }
  function saveSettings(){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); }

  function loadMemberCache(){
    try{ return JSON.parse(localStorage.getItem(MEMBER_CACHE_KEY) || "{}"); }
    catch{ return {}; }
  }
  function saveMemberCache(){
    const entries = Object.entries(memberCache);
    if(entries.length > 900){
      entries.sort((a,b) => (a[1].t || 0) - (b[1].t || 0));
      for(let i=0;i<entries.length-900;i++) delete memberCache[entries[i][0]];
    }
    localStorage.setItem(MEMBER_CACHE_KEY, JSON.stringify(memberCache));
  }

  let settings = loadSettings();
  let memberCache = loadMemberCache();

  /********************
   * UI Hooks
   ********************/
  const brandSubEl = document.getElementById("brandSub");
  const airportInputLabelEl = document.getElementById("airportInputLabel");
  const utcPill = document.getElementById("utcPill");
  const feedPill = document.getElementById("feedPill");
  const apiPill = document.getElementById("apiPill");

  const airportInputEl = document.getElementById("airportInput");
  const applyAirportBtn = document.getElementById("applyAirportBtn");
  const refreshBtn = document.getElementById("refreshBtn");
  const configBtn = document.getElementById("configBtn");
  const utcClockEl = document.getElementById("utcClock");

  const feedDot = document.getElementById("feedDot");
  const feedText = document.getElementById("feedText");
  const feedAge = document.getElementById("feedAge");

  const apiDot = document.getElementById("apiDot");
  const apiText = document.getElementById("apiText");
  const apiExtra = document.getElementById("apiExtra");

  const depTitleEl = document.getElementById("depTitle");
  const arrTitleEl = document.getElementById("arrTitle");
  const depSortHintEl = document.getElementById("depSortHint");
  const arrSortHintEl = document.getElementById("arrSortHint");

  const depHeadRow = document.getElementById("depHeadRow");
  const arrHeadRow = document.getElementById("arrHeadRow");

  const depBody = document.getElementById("depBody");
  const arrBody = document.getElementById("arrBody");
  const depSortEl = document.getElementById("depSort");
  const depDirBtn = document.getElementById("depDir");
  const arrSortEl = document.getElementById("arrSort");
  const arrDirBtn = document.getElementById("arrDir");

  const tooltip = document.getElementById("tooltip");
  const legendInner = document.getElementById("legendInner");

  // Airport XP Index pills
  const depXpIndexPill = document.getElementById("depXpIndexPill");
  const depXpIndexDot = document.getElementById("depXpIndexDot");
  const depXpIndexVal = document.getElementById("depXpIndexVal");
  const depXpIndexCnt = document.getElementById("depXpIndexCnt");
  const arrXpIndexPill = document.getElementById("arrXpIndexPill");
  const arrXpIndexDot = document.getElementById("arrXpIndexDot");
  const arrXpIndexVal = document.getElementById("arrXpIndexVal");
  const arrXpIndexCnt = document.getElementById("arrXpIndexCnt");

  // Pilot Modal
  const pilotModalOverlay = document.getElementById("pilotModalOverlay");
  const pilotModalClose = document.getElementById("pilotModalClose");
  const pilotModalTitle = document.getElementById("pilotModalTitle");
  const pilotModalSubtitle = document.getElementById("pilotModalSubtitle");
  const flightKv = document.getElementById("flightKv");
  const xpKv = document.getElementById("xpKv");
  const xpList = document.getElementById("xpList");
  const xpLinks = document.getElementById("xpLinks");
  const historyKv = document.getElementById("historyKv");

  const pilotCardFlightData = document.getElementById("pilotCardFlightData");
  const pilotCardStats = document.getElementById("pilotCardStats");
  const pilotCardBreakdown = document.getElementById("pilotCardBreakdown");
  const pilotCardHistory = document.getElementById("pilotCardHistory");
  const historyNote = document.getElementById("historyNote");

  // Config Modal
  const configModalOverlay = document.getElementById("configModalOverlay");
  const configClose = document.getElementById("configClose");
  const cfgAirport = document.getElementById("cfgAirport");
  const cfgInterval = document.getElementById("cfgInterval");
  const cfgLanguage = document.getElementById("cfgLanguage");
  const cfgPrefiles = document.getElementById("cfgPrefiles");
  const cfgHideArrLanded = document.getElementById("cfgHideArrLanded");
  const cfgHideDepFinished = document.getElementById("cfgHideDepFinished");
  const cfgXpHydrate = document.getElementById("cfgXpHydrate");
  const cfgT1 = document.getElementById("cfgT1");
  const cfgT2 = document.getElementById("cfgT2");
  const cfgT3 = document.getElementById("cfgT3");
  const cfgT4 = document.getElementById("cfgT4");
  const cfgDefaults = document.getElementById("cfgDefaults");
  const cfgCancel = document.getElementById("cfgCancel");
  const cfgSave = document.getElementById("cfgSave");
  const cfgResetCache = document.getElementById("cfgResetCache");

  const cfgModalTitle = document.getElementById("cfgModalTitle");
  const cfgTabGeneral = document.getElementById("cfgTabGeneral");
  const cfgTabDisplay = document.getElementById("cfgTabDisplay");
  const cfgTabXp = document.getElementById("cfgTabXp");
  const cfgGeneralTitle = document.getElementById("cfgGeneralTitle");
  const cfgAirportLabel = document.getElementById("cfgAirportLabel");
  const cfgIntervalLabel = document.getElementById("cfgIntervalLabel");
  const cfgLanguageLabel = document.getElementById("cfgLanguageLabel");
  const cfgXpHydrateLabel = document.getElementById("cfgXpHydrateLabel");
  const cfgFilterLabel = document.getElementById("cfgFilterLabel");
  const cfgPrefilesText = document.getElementById("cfgPrefilesText");
  const cfgHideArrText = document.getElementById("cfgHideArrText");
  const cfgHideDepText = document.getElementById("cfgHideDepText");
  const cfgDisplayTitle = document.getElementById("cfgDisplayTitle");
  const cfgDisplayHelp = document.getElementById("cfgDisplayHelp");
  const cfgDisplayDepTitle = document.getElementById("cfgDisplayDepTitle");
  const cfgDisplayArrTitle = document.getElementById("cfgDisplayArrTitle");
  const cfgXpTitle = document.getElementById("cfgXpTitle");
  const cfgT1Label = document.getElementById("cfgT1Label");
  const cfgT2Label = document.getElementById("cfgT2Label");
  const cfgT3Label = document.getElementById("cfgT3Label");
  const cfgT4Label = document.getElementById("cfgT4Label");

  const cfgDepCols = document.getElementById("cfgDepCols");
  const cfgArrCols = document.getElementById("cfgArrCols");

  /********************
   * Config Modal Tabs
   ********************/
  function setActiveCfgTab(tab){
    for(const b of configModalOverlay.querySelectorAll(".tabBtn")){
      b.classList.toggle("active", b.dataset.tab === tab);
    }
    for(const p of configModalOverlay.querySelectorAll(".tabPanel")){
      p.classList.toggle("active", p.dataset.tab === tab);
    }
  }
  configModalOverlay.addEventListener("click", (e) => {
    const btn = e.target.closest(".tabBtn");
    if(btn) setActiveCfgTab(btn.dataset.tab);
  });

  /********************
   * Sort options build (i18n)
   ********************/
  function rebuildSortOptions(){
    const depVal = depSortEl.value || settings.depSort.by;
    const arrVal = arrSortEl.value || settings.arrSort.by;

    depSortEl.innerHTML = "";
    [
      ["status", t("sort_status")],
      ["time", t("sort_time_std")],
      ["callsign", t("sort_callsign")],
      ["dest", t("sort_dest")],
      ["xp", t("sort_xp")]
    ].forEach(([v,txt]) => {
      const o = document.createElement("option");
      o.value = v; o.textContent = txt;
      depSortEl.appendChild(o);
    });

    arrSortEl.innerHTML = "";
    [
      ["status", t("sort_status")],
      ["time", t("sort_time_eta")],
      ["callsign", t("sort_callsign")],
      ["orig", t("sort_orig")],
      ["xp", t("sort_xp")]
    ].forEach(([v,txt]) => {
      const o = document.createElement("option");
      o.value = v; o.textContent = txt;
      arrSortEl.appendChild(o);
    });

    depSortEl.value = depVal || "status";
    arrSortEl.value = arrVal || "status";
  }

  /********************
   * Board Columns (header + rendering)
   ********************/
  const COL_META = {
    time: { width:"90px", thClass:"center", tdClass:"center" },
    callsign: { width:"90px" },
    ap: { width:"70px" },
    typeRoute: { width:null, tdClass:"cell-route" },
    altgs: { width:"125px", thClass:"right", tdClass:"right" },
    status: { width:"170px" },
    xp: { width:"110px" }
  };

  function colHeaderLabel(key, boardType){
    if(key === "time") return (boardType === "dep") ? t("th_time_std") : t("th_time_eta");
    if(key === "ap") return (boardType === "dep") ? t("th_to") : t("th_from");
    if(key === "callsign") return t("th_callsign");
    if(key === "typeRoute") return t("th_type_route");
    if(key === "altgs") return t("th_alt_gs");
    if(key === "status") return t("th_status");
    if(key === "xp") return t("th_xp");
    return key;
  }

  function buildBoardHeaders(){
    buildHeaderFor("dep", depHeadRow);
    buildHeaderFor("arr", arrHeadRow);
  }

  function buildHeaderFor(boardType, rowEl){
    rowEl.innerHTML = "";
    const layout = settings.boardLayout[boardType];
    for(const key of layout.order){
      if(!layout.visible[key]) continue;
      const th = document.createElement("th");
      const meta = COL_META[key] || {};
      th.textContent = colHeaderLabel(key, boardType);
      if(meta.width) th.style.width = meta.width;
      if(meta.thClass) th.className = meta.thClass;
      rowEl.appendChild(th);
    }
  }

  /********************
   * Apply language to static UI
   ********************/
  function applyLanguage(){
    document.documentElement.lang = lang();
    brandSubEl.textContent = t("brand_sub");
    airportInputLabelEl.textContent = t("airport_label");
    applyAirportBtn.title = t("apply_airport_title");
    refreshBtn.title = t("refresh_title");
    configBtn.title = t("cfg_title");

    depTitleEl.textContent = t("dep_title");
    arrTitleEl.textContent = t("arr_title");
    depSortHintEl.textContent = t("sort_hint");
    arrSortHintEl.textContent = t("sort_hint");
    depDirBtn.title = t("dep_dir_title");
    arrDirBtn.title = t("arr_dir_title");

    utcPill.title = t("utc_title");
    feedPill.title = t("feed_title");
    apiPill.title = t("api_title");

    // Config texts
    cfgModalTitle.textContent = t("config_title");
    cfgTabGeneral.textContent = t("cfg_tab_general");
    cfgTabDisplay.textContent = t("cfg_tab_display");
    cfgTabXp.textContent = t("cfg_tab_xp");
    cfgGeneralTitle.textContent = t("cfg_general_title");
    cfgAirportLabel.textContent = t("cfg_airport");
    cfgIntervalLabel.textContent = t("cfg_interval");
    cfgLanguageLabel.textContent = t("cfg_language");
    cfgXpHydrateLabel.textContent = t("cfg_xp_hydrate");
    cfgFilterLabel.textContent = t("cfg_filter");
    cfgPrefilesText.textContent = t("cfg_prefiles");
    cfgHideArrText.textContent = t("cfg_hide_arr");
    cfgHideDepText.textContent = t("cfg_hide_dep");
    cfgDisplayTitle.textContent = t("cfg_display_title");
    cfgDisplayHelp.textContent = t("cfg_display_help");
    cfgDisplayDepTitle.textContent = t("cfg_display_dep");
    cfgDisplayArrTitle.textContent = t("cfg_display_arr");
    cfgXpTitle.textContent = t("cfg_xp_title");
    cfgT1Label.textContent = t("cfg_t1");
    cfgT2Label.textContent = t("cfg_t2");
    cfgT3Label.textContent = t("cfg_t3");
    cfgT4Label.textContent = t("cfg_t4");

    cfgResetCache.textContent = t("btn_cache_reset");
    cfgDefaults.textContent = t("btn_defaults");
    cfgCancel.textContent = t("btn_cancel");
    cfgSave.textContent = t("btn_save");

    // Pilot modal headers
    pilotModalTitle.textContent = t("pilot_modal_title");
    pilotCardFlightData.textContent = t("pilot_card_flight");
    pilotCardStats.textContent = t("pilot_card_stats");
    pilotCardBreakdown.textContent = t("pilot_card_breakdown");
    pilotCardHistory.textContent = t("pilot_card_history");
    historyNote.textContent = t("history_note");

    rebuildSortOptions();
    buildBoardHeaders();
    rebuildLegend();
    scheduleAirportXpIndexUpdate();

    // Recompute XP labels/tooltips for already loaded flights
    for(const f of [...lastDeps, ...lastArrs]){
      if(f.details || f.stats){
        f.exp = computeExperience(f.details ?? null, f.stats ?? null);
        depBoard.updateXpById(f.id);
        arrBoard.updateXpById(f.id);
      }
    }
  }

  /********************
   * Airport Index
   ********************/
  const airportIndex = {
    ready:false,
    byIcao: new Map(),
    byIata: new Map(),
    grid: new Map()
  };
  function gridKey(lat, lon){ return `${Math.floor(lat)},${Math.floor(lon)}`; }
  function gridAdd(ap){
    const key = gridKey(ap.latitude, ap.longitude);
    if(!airportIndex.grid.has(key)) airportIndex.grid.set(key, []);
    airportIndex.grid.get(key).push(ap);
  }
  function normalizeCode(s){ return (s||"").trim().toUpperCase(); }

  async function ensureAirportIndex(){
    if(airportIndex.ready) return true;
    try{
      const res = await fetch(AIRPORTS_URL, { cache:"force-cache" });
      if(!res.ok) throw new Error(`airports.json HTTP ${res.status}`);
      const data = await res.json();
      for(const a of data){
        if(!a || !a.icao || !a.latitude || !a.longitude) continue;
        const icao = normalizeCode(a.icao);
        const iata = normalizeCode(a.iata);
        const ap = {
          icao,
          iata: iata || "",
          latitude: Number(a.latitude),
          longitude: Number(a.longitude),
          elevation: Number(a.altitude || 0) // feet
        };
        airportIndex.byIcao.set(icao, ap);
        if(iata && !airportIndex.byIata.has(iata)) airportIndex.byIata.set(iata, icao);
        gridAdd(ap);
      }
      airportIndex.ready = true;
      return true;
    }catch(err){
      console.warn("Airport DB load failed:", err);
      const ap1 = { icao:"EDDB", iata:"BER", latitude:52.3667, longitude:13.5033, elevation:157 };
      airportIndex.byIcao.set("EDDB", ap1);
      airportIndex.byIata.set("BER", "EDDB");
      gridAdd(ap1);

      const ap2 = { icao:"LOWI", iata:"INN", latitude:47.2603, longitude:11.3440, elevation:1906 };
      airportIndex.byIcao.set("LOWI", ap2);
      airportIndex.byIata.set("INN", "LOWI");
      gridAdd(ap2);

      airportIndex.ready = true;
      return false;
    }
  }
  function resolveAirportToIcao(code){
    const c = normalizeCode(code);
    if(c.length === 3) return airportIndex.byIata.get(c) || c;
    return c;
  }
  function getAirport(icaoOrIata){
    const icao = resolveAirportToIcao(icaoOrIata);
    return airportIndex.byIcao.get(icao) || null;
  }
  function haversineNm(lat1, lon1, lat2, lon2){
    const R_km = 6371;
    const toRad = d => d * Math.PI / 180;
    const dLat = toRad(lat2-lat1);
    const dLon = toRad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return (R_km * c) * 0.5399568;
  }
  
  function haversineMeters(lat1, lon1, lat2, lon2){
  const R = 6371000;
  const toRad = d => d * Math.PI / 180;
  const dLat = toRad(lat2-lat1);
  const dLon = toRad(lon2-lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

  
  function findNearestAirport(lat, lon, maxNm=10){
    const latB = Math.floor(lat);
    const lonB = Math.floor(lon);
    let best = null, bestD = Infinity;
    const maxR = 4;
    for(let r=0;r<=maxR;r++){
      for(let dy=-r; dy<=r; dy++){
        for(let dx=-r; dx<=r; dx++){
          if(Math.abs(dx)!==r && Math.abs(dy)!==r) continue;
          const key = `${latB+dy},${lonB+dx}`;
          const bucket = airportIndex.grid.get(key);
          if(!bucket) continue;
          for(const ap of bucket){
            const d = haversineNm(lat, lon, ap.latitude, ap.longitude);
            if(d < bestD){ bestD = d; best = ap; }
          }
        }
      }
      if(best && bestD <= maxNm) break;
    }
    if(best && bestD <= maxNm) return { ap: best, nm: bestD };
    return null;
  }
  
  const gatePrefetchAttempt = new Map(); // icao -> lastAttemptMs

function prefetchGateIndexesForArrOrigins(arrList){
  const focus = currentAirportIcao;
  const now = Date.now();

  const need = [];
  const seen = new Set();

  for(const f of arrList){
    if(f.status?.phase !== "GATE") continue;     // Arrivals: GATE = am Origin am Boden
    const icao = normalizeCode(f.dep || "");
    if(!icao || icao === focus) continue;
    if(seen.has(icao)) continue;
    seen.add(icao);

    if(gateIndexByIcao.has(icao)) continue;

    need.push(icao);
    if(need.length >= 3) break; // pro Refresh max 3 neue Airports anstoßen
  }

  for(const icao of need){
    const last = gatePrefetchAttempt.get(icao) || 0;
    if(now - last < 2*60*1000) continue; // pro Airport max alle 2min
    gatePrefetchAttempt.set(icao, now);
    ensureGateIndexForIcao(icao).catch(()=>{});
  }
}

  
  /********************
 * OSM Gate/Stand Resolver (Overpass + Cache + Smoothing)
 ********************/
const gateIndexByIcao = new Map();   // icao -> { ts, gates, grid }
const gateLoadPromises = new Map();  // icao -> Promise
const gateMem = new Map();           // cid -> state

function loadGateCache(){
  try { return JSON.parse(localStorage.getItem(GATE_CACHE_KEY) || "{}"); }
  catch { return {}; }
}
function saveGateCache(obj){
  localStorage.setItem(GATE_CACHE_KEY, JSON.stringify(obj));
}

function loadGateFlightCache(){
  try { return JSON.parse(localStorage.getItem(GATE_FLIGHT_CACHE_KEY) || "{}"); }
  catch { return {}; }
}
function saveGateFlightCache(obj){
  localStorage.setItem(GATE_FLIGHT_CACHE_KEY, JSON.stringify(obj));
}

let gateFlightCache = loadGateFlightCache();

function pruneGateFlightCache(){
  const now = Date.now();
  let changed = false;
  for(const [cid, e] of Object.entries(gateFlightCache)){
    if(!e?.ts || (now - e.ts) > GATE_FLIGHT_TTL_MS){
      delete gateFlightCache[cid];
      changed = true;
    }
  }
  if(changed) saveGateFlightCache(gateFlightCache);
}

function getGateFlightCacheHit(cid, icao, lat, lon, gsKts){
  const e = gateFlightCache[String(cid)];
  if(!e) return null;
  if(normalizeCode(e.icao) !== normalizeCode(icao)) return null;
  if(!e.ts || (Date.now() - e.ts) > GATE_FLIGHT_TTL_MS) return null;

  if(!isFinite(lat) || !isFinite(lon) || !isFinite(gsKts)) return null;

  const d = haversineMeters(lat, lon, Number(e.lat), Number(e.lon));
  if(!isFinite(d) || d > 12) return null;                 // Position praktisch identisch
  if(Math.abs(gsKts - Number(e.gs || 0)) > 2.5) return null; // GS praktisch identisch

  return e;
}

function persistGateFlightCache(cid, icao, gate, lat, lon, gsKts){
  if(!gate || !icao) return;
  cid = String(cid);
  icao = normalizeCode(icao);

  const now = Date.now();
  const mem = gateMem.get(cid);
  if(mem){
    // Throttle um LocalStorage nicht zu spammen
    if(mem._persistAt && (now - mem._persistAt) < 15000) return;
    mem._persistAt = now;
  }

  gateFlightCache[cid] = {
    icao,
    gateId: gate.id || null,
    gateLabel: gate.label || null,
    lat, lon,
    gs: Math.round(gsKts * 10) / 10,
    ts: now
  };

  // Simple size cap
  const keys = Object.keys(gateFlightCache);
  if(keys.length > 900){
    keys.sort((a,b) => (gateFlightCache[a]?.ts||0) - (gateFlightCache[b]?.ts||0));
    for(let i=0;i<keys.length-900;i++) delete gateFlightCache[keys[i]];
  }

  saveGateFlightCache(gateFlightCache);
}

function seedGateMemFromFlightCache(cid, icao, lat, lon, gsKts, idx){
  cid = String(cid);
  icao = normalizeCode(icao);

  const hit = getGateFlightCacheHit(cid, icao, lat, lon, gsKts);
  if(!hit) return;

  let m = gateMem.get(cid);
  if(m?.stable) return;

  let gateObj = null;
  if(idx?.gates && hit.gateId){
    gateObj = idx.gates.find(g => g.id === hit.gateId) || null;
  }
  if(!gateObj && hit.gateLabel){
    gateObj = {
      id: hit.gateId || `cached:${icao}:${hit.gateLabel}`,
      label: hit.gateLabel,
      lat, lon,
      kind: "cached"
    };
  }
  if(!gateObj) return;

  const now = Date.now();
  if(!m){
    m = {
      samples: [],
      stable: null,
      stableSeenAt: 0,
      pending: null,
      pendingSince: 0,
      lastSeen: 0,
      wasStationaryAt: 0,
      _persistAt: 0
    };
    gateMem.set(cid, m);
  }

  // “Sofort anzeigen” beim Reload: Stationary-Fenster synthetisch füttern (nur wenn Pos/GS matchen)
  m.stable = gateObj;
  m.stableSeenAt = now;
  m.wasStationaryAt = now;
  m.samples = [
    { lat: Number(hit.lat), lon: Number(hit.lon), t: now - STATIONARY_MIN_MS - 50 },
    { lat, lon, t: now }
  ];
}


const GATE_CELL_DEG = 0.002; // ~220m (grob)
function gateCellKey(lat, lon){
  return `${Math.floor(lat / GATE_CELL_DEG)},${Math.floor(lon / GATE_CELL_DEG)}`;
}
function buildGateGrid(gates){
  const grid = new Map();
  for(const g of gates){
    const k = gateCellKey(g.lat, g.lon);
    if(!grid.has(k)) grid.set(k, []);
    grid.get(k).push(g);
  }
  return grid;
}

function normalizeGateLabel(tags){
  if(!tags) return null;
  let label =
    tags.ref ||
    tags.local_ref ||
    tags["ref:gate"] ||
    tags["gate:ref"] ||
    tags.gate ||
    tags["ref:stand"] ||
    tags.stand ||
    tags.name ||
    null;

  if(!label) return null;
  label = String(label).trim();
  if(!label) return null;

  // Optional: Terminal vorn dran (wenn label nur Zahl ist)
  const term = tags.terminal ? String(tags.terminal).trim() : "";
  if(term && /^[0-9]+[A-Z]?$/.test(label) && !label.startsWith(term)) label = `${term}${label}`;

  return label;
}

async function fetchOverpassGatesForAirport(icao){
  const ap = getAirport(icao);
  if(!ap) return [];
  const q = `
[out:json][timeout:25];
(
  node["aeroway"="parking_position"](around:${OSM_GATE_QUERY_RADIUS_M},${ap.latitude},${ap.longitude});
  node["aeroway"="gate"](around:${OSM_GATE_QUERY_RADIUS_M},${ap.latitude},${ap.longitude});
  node["aeroway"="stand"](around:${OSM_GATE_QUERY_RADIUS_M},${ap.latitude},${ap.longitude});
  way["aeroway"="parking_position"](around:${OSM_GATE_QUERY_RADIUS_M},${ap.latitude},${ap.longitude});
  way["aeroway"="gate"](around:${OSM_GATE_QUERY_RADIUS_M},${ap.latitude},${ap.longitude});
  way["aeroway"="stand"](around:${OSM_GATE_QUERY_RADIUS_M},${ap.latitude},${ap.longitude});
);
out center tags;
`.trim();

  const url = `${OVERPASS_API}?data=${encodeURIComponent(q)}`;
  const finalUrl = CORS_PROXY + encodeURIComponent(url);

  const res = await fetch(finalUrl, { cache: "no-store" });
  if(!res.ok) throw new Error(`Overpass HTTP ${res.status}`);
  const data = await res.json();

  const gates = [];
  for(const el of (data.elements || [])){
    const tags = el.tags || null;
    const label = normalizeGateLabel(tags);
    if(!label) continue;

    const lat = (typeof el.lat === "number") ? el.lat : (el.center?.lat);
    const lon = (typeof el.lon === "number") ? el.lon : (el.center?.lon);
    if(!isFinite(lat) || !isFinite(lon)) continue;

    gates.push({
      id: `${el.type}:${el.id}`,
      lat, lon,
      label,
      kind: tags?.aeroway || "unknown"
    });
  }

  // Duplikate (gleiches Label extrem nah) reduzieren
  gates.sort((a,b) => a.label.localeCompare(b.label, "en", { sensitivity:"base" }));
  const dedup = [];
  for(const g of gates){
    const prev = dedup[dedup.length-1];
    if(prev && prev.label === g.label){
      const d = haversineMeters(prev.lat, prev.lon, g.lat, g.lon);
      if(d < 8) continue;
    }
    dedup.push(g);
  }
  return dedup;
}

function ensureGateIndexForIcao(icao){
  icao = normalizeCode(icao);
  if(gateIndexByIcao.has(icao)){
    const cur = gateIndexByIcao.get(icao);
    if(cur && (Date.now() - cur.ts) < GATE_CACHE_TTL_MS) return Promise.resolve(cur);
  }
  if(gateLoadPromises.has(icao)) return gateLoadPromises.get(icao);

  const p = (async () => {
    const cache = loadGateCache();
    const cached = cache[icao];
    if(cached && cached.ts && (Date.now() - cached.ts) < GATE_CACHE_TTL_MS && Array.isArray(cached.gates)){
      const idx = { ts: cached.ts, gates: cached.gates, grid: buildGateGrid(cached.gates) };
      gateIndexByIcao.set(icao, idx);
      return idx;
    }

    const gates = await fetchOverpassGatesForAirport(icao);
    const idx = { ts: Date.now(), gates, grid: buildGateGrid(gates) };
    gateIndexByIcao.set(icao, idx);

    cache[icao] = { ts: idx.ts, gates: idx.gates };
    saveGateCache(cache);

    return idx;
  })().finally(() => {
    gateLoadPromises.delete(icao);
  });

  gateLoadPromises.set(icao, p);
  return p;
}

function findNearestGate(idx, lat, lon, maxM){
  if(!idx || !idx.grid) return null;
  const cx = Math.floor(lat / GATE_CELL_DEG);
  const cy = Math.floor(lon / GATE_CELL_DEG);

  let best = null;
  let bestD = Infinity;

  for(let dx=-1; dx<=1; dx++){
    for(let dy=-1; dy<=1; dy++){
      const k = `${cx+dx},${cy+dy}`;
      const bucket = idx.grid.get(k);
      if(!bucket) continue;
      for(const g of bucket){
        const d = haversineMeters(lat, lon, g.lat, g.lon);
        if(d < bestD){
          bestD = d;
          best = g;
        }
      }
    }
  }

  if(best && bestD <= maxM) return { gate: best, distM: bestD };
  return null;
}

function pruneGateMem(){
  const now = Date.now();
  const ttl = 30 * 60 * 1000;
  for(const [cid, m] of gateMem.entries()){
    if(!m?.lastSeen || (now - m.lastSeen) > ttl) gateMem.delete(cid);
  }
  pruneGateFlightCache();

}

function updateStationaryState(cid, lat, lon, gsKts){
  const now = Date.now();
  let m = gateMem.get(cid);
  if(!m){
    m = {
      samples: [],
      stable: null,
      stableSeenAt: 0,
      pending: null,
      pendingSince: 0,
      lastSeen: 0,
      wasStationaryAt: 0
    };
    gateMem.set(cid, m);
  }

  m.lastSeen = now;

  // Default flags
  let taxiSure = false;
  let uncertain = false;

  if(!isFinite(lat) || !isFinite(lon)){
    m.samples = [];
    uncertain = true;
    return { mem: m, isStationary: false, moveM: null, taxiSure, uncertain };
  }

  // sofort "rolling" wenn GS hoch
  if(gsKts > TAXI_HIDE_GS_KTS){
    taxiSure = true;
    m.samples = [{ lat, lon, t: now }];
    return { mem: m, isStationary: false, moveM: null, taxiSure, uncertain:false };
  }

  m.samples.push({ lat, lon, t: now });
  while(m.samples.length && (now - m.samples[0].t) > STATIONARY_WINDOW_MS) m.samples.shift();

  const first = m.samples[0];
  const last  = m.samples[m.samples.length - 1];
  const dt    = last.t - first.t;

  // Recent-move check (Pushback/Taxi schneller erkennen)
  let recentMoveM = null;
  for(let i=m.samples.length-1; i>=0; i--){
    if(now - m.samples[i].t >= RECENT_MOVE_WINDOW_MS){
      recentMoveM = haversineMeters(m.samples[i].lat, m.samples[i].lon, last.lat, last.lon);
      break;
    }
  }
  if(recentMoveM != null && recentMoveM > RECENT_MOVE_MAX_M){
    taxiSure = true;
    return { mem: m, isStationary: false, moveM: recentMoveM, taxiSure, uncertain:false };
  }

  if(dt < STATIONARY_MIN_MS){
    uncertain = true; // noch nicht genug Daten für "Gate sicher"
    return { mem: m, isStationary: false, moveM: null, taxiSure:false, uncertain };
  }

  const moveM = haversineMeters(first.lat, first.lon, last.lat, last.lon);
  const isStationary = (moveM <= STATIONARY_MAX_MOVE_M) && (gsKts <= STATIONARY_MAX_GS_KTS);

  if(isStationary){
    m.wasStationaryAt = now;
    return { mem: m, isStationary: true, moveM, taxiSure:false, uncertain:false };
  }

  // Nicht stationär, aber auch nicht "Taxi sicher" => unklar -> Fallback
  uncertain = true;
  return { mem: m, isStationary: false, moveM, taxiSure:false, uncertain };
}


function resolveGateForCid(cid, lat, lon, gsKts, idx, cacheIcao){
  cid = String(cid);
  const now = Date.now();

  // WICHTIG: Cache-Seed auch ohne idx (damit Arrivals@Origin sofort Gate zeigen können)
  if(cacheIcao && isFinite(lat) && isFinite(lon) && isFinite(gsKts)){
    seedGateMemFromFlightCache(cid, cacheIcao, lat, lon, gsKts, idx || null);
  }

  const { mem, isStationary, taxiSure, uncertain } = updateStationaryState(cid, lat, lon, gsKts);

  let out = null;

  // Bei "Taxi sicher" KEIN Gate ausgeben (Status soll "Taxi" werden)
  if(taxiSure){
    out = null;
  }
  else if(!isStationary){
    // Jitter-Grace: wenn gerade erst “stationary”, Gate kurz halten
    if(mem.stable && (now - mem.wasStationaryAt) < GATE_JITTER_GRACE_MS && gsKts <= (STATIONARY_MAX_GS_KTS + 2)){
      out = mem.stable;
    }else{
      out = null;
    }
  }else{
    // Stationär
    if(!idx){
      // FIX: Wenn kein idx geladen ist, aber wir bereits ein stabiles Gate haben (z.B. aus Cache), zeige es trotzdem.
      if(mem.stable){
        mem.stableSeenAt = now;
        out = mem.stable;
      }else{
        out = null;
      }
    }else{
      const hit = findNearestGate(idx, lat, lon, GATE_MATCH_RADIUS_M);
      const cand = hit ? hit.gate : null;

      if(!cand){
        if(mem.stable && (now - mem.stableSeenAt) < GATE_LOST_GRACE_MS) out = mem.stable;
        else out = null;
      }else if(mem.stable && mem.stable.id === cand.id){
        mem.stableSeenAt = now;
        mem.pending = null;
        mem.pendingSince = 0;
        out = mem.stable;
      }else{
        if(mem.pending && mem.pending.id === cand.id){
          if((now - mem.pendingSince) >= GATE_CONFIRM_MS){
            mem.stable = cand;
            mem.stableSeenAt = now;
            mem.pending = null;
            mem.pendingSince = 0;
            out = mem.stable;
          }
        }else{
          mem.pending = cand;
          mem.pendingSince = now;
        }

        if(!out){
          if(mem.stable && (now - mem.stableSeenAt) < GATE_STICKY_MS) out = mem.stable;
          else out = null;
        }
      }
    }
  }

  // Persist nur wenn wirklich stationär
  if(out && cacheIcao && isStationary && isFinite(lat) && isFinite(lon) && isFinite(gsKts) && gsKts <= (STATIONARY_MAX_GS_KTS + 2)){
    persistGateFlightCache(cid, cacheIcao, out, lat, lon, gsKts);
  }

  return { gate: out, ground: { isStationary, taxiSure, uncertain } };
}




  /********************
   * Core API Rate Limiter
   ********************/
  class RateLimiter {
    constructor({minIntervalMs=8000}={}){
      this.minIntervalMs = minIntervalMs;
      this.queue = [];
      this.running = false;
      const last = Number(localStorage.getItem(API_LAST_REQ_KEY) || "0");
      this.lastRequestAt = isFinite(last) ? last : 0;
      this.backoffUntil = 0;
      this.inFlight = 0;
    }
    enqueue(fn){
      return new Promise((resolve, reject) => {
        this.queue.push({ fn, resolve, reject });
        this.pump();
      });
    }
    clear(){
      this.queue = [];
    }
    async pump(){
      if(this.running) return;
      this.running = true;
      while(this.queue.length){
        const now = Date.now();
        const waitForBackoff = Math.max(0, this.backoffUntil - now);
        const waitForInterval = Math.max(0, (this.lastRequestAt + this.minIntervalMs) - now);
        const waitMs = Math.max(waitForBackoff, waitForInterval);
        if(waitMs > 0) await new Promise(r => setTimeout(r, waitMs));

        if(this.queue.length === 0) break;

        const item = this.queue.shift();
        this.inFlight = 1;
        try{
          const res = await item.fn();
          this.lastRequestAt = Date.now();
          localStorage.setItem(API_LAST_REQ_KEY, String(this.lastRequestAt));
          item.resolve(res);
        }catch(e){
          if(e && e.__rateLimited) this.backoffUntil = Date.now() + 60000;
          item.reject(e);
        }finally{
          this.inFlight = 0;
        }
      }
      this.running = false;
    }
  }
  const limiter = new RateLimiter({ minIntervalMs: 7000 });

  async function fetchJsonPossiblyEmpty(url, { useProxy=false, retryEmpty=3, retryDelayMs=800 } = {}){
    const finalUrl = useProxy ? (CORS_PROXY + encodeURIComponent(url)) : url;

    const runOnce = async () => {
      const res = await fetch(finalUrl, { cache:"no-store" });
      if(res.status === 429){
        const err = new Error("Rate limited (429)");
        err.__rateLimited = true;
        throw err;
      }

      if(!res.ok){
        const err = new Error(`HTTP ${res.status}`);
        err.status = res.status;
        throw err;
      }

      const text = await res.text();
      if(!text || !text.trim()) return { __empty:true, __status: res.status };
      return JSON.parse(text);
    };

    for(let attempt=1; attempt<=retryEmpty; attempt++){
      const out = useProxy ? await limiter.enqueue(runOnce) : await runOnce();
      if(out && out.__empty){
        await new Promise(r => setTimeout(r, retryDelayMs * attempt));
        continue;
      }
      return out;
    }
    throw new Error("API returned empty body repeatedly.");
  }

  function updateApiQueuePill(){
    const q = limiter.queue.length;
    const now = Date.now();
    const backoff = limiter.backoffUntil && limiter.backoffUntil > now;
    const inflight = limiter.inFlight || 0;

    apiDot.className = "dot " + (backoff ? "bad" : (q>0 || inflight) ? "warn" : "good");
    apiText.textContent = `API Q: ${q}`;

    if(backoff){
      apiExtra.textContent = `${Math.ceil((limiter.backoffUntil-now)/1000)}s`;
    }else if(inflight){
      apiExtra.textContent = "RUN";
    }else{
      apiExtra.textContent = "OK";
    }
  }
  setInterval(updateApiQueuePill, 250);

  /********************
   * Member Cache + API with 404 Guard
   ********************/
  function getCacheEntry(cid){ return memberCache[String(cid)] || null; }
  function upsertCacheEntry(cid, patch){
    const key = String(cid);
    const cur = memberCache[key] || {};
    memberCache[key] = { ...cur, ...patch, t: Date.now() };
    saveMemberCache();
  }
  function isFresh(ts, ttlMs){ return ts && (Date.now() - ts) < ttlMs; }
  function isCoolingDown(entry) { return entry && entry.status404Ts && isFresh(entry.status404Ts, MEMBER_404_TTL_MS); }

  async function getMemberDetails(cid){
    const entry = getCacheEntry(cid);
    if(isCoolingDown(entry)) return null;
    if(entry?.details && isFresh(entry.detailsTs, settings.memberTtlDetailsMs)) return entry.details;
    const url = `${CORE_API_BASE}/members/${cid}`;
    try {
      const details = await fetchJsonPossiblyEmpty(url, { useProxy:true, retryEmpty:4 });
      upsertCacheEntry(cid, { details, detailsTs: Date.now(), status404Ts: null });
      return details;
    } catch(err) {
      if(err.status === 404) {
        upsertCacheEntry(cid, { details: null, status404Ts: Date.now() });
        return null;
      }
      throw err;
    }
  }

  async function getMemberStats(cid){
    const entry = getCacheEntry(cid);
    if(isCoolingDown(entry)) return null;
    if(entry?.stats && isFresh(entry.statsTs, settings.memberTtlStatsMs)) return entry.stats;
    const url = `${CORE_API_BASE}/members/${cid}/stats`;
    try {
      const stats = await fetchJsonPossiblyEmpty(url, { useProxy:true, retryEmpty:5 });
      upsertCacheEntry(cid, { stats, statsTs: Date.now(), status404Ts: null });
      return stats;
    } catch(err) {
      if(err.status === 404) {
        upsertCacheEntry(cid, { stats: null, status404Ts: Date.now() });
        return null;
      }
      throw err;
    }
  }

  async function getMemberHistory(cid, {limit=20} = {}){
    const entry = getCacheEntry(cid);
    if(isCoolingDown(entry)) return null;
    const ttl = 24 * 3600 * 1000;
    if(entry?.history && isFresh(entry.historyTs, ttl)) return entry.history;
    const url = `${CORE_API_BASE}/members/${cid}/history?limit=${encodeURIComponent(limit)}&offset=0`;
    try {
      const history = await fetchJsonPossiblyEmpty(url, { useProxy:true, retryEmpty:4 });
      upsertCacheEntry(cid, { history, historyTs: Date.now() });
      return history;
    } catch(err) {
      if(err.status === 404) return null;
      throw err;
    }
  }

  /********************
   * Time Helpers (+1 / +n on next UTC day)
   ********************/
  const DAY_MS = 24 * 3600 * 1000;

  function utcDayStartMs(refMs=Date.now()){
    const d = new Date(refMs);
    return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
  }
  function fmtHHMMFromTs(ts){
    if(ts == null || !isFinite(ts)) return "—";
    return new Date(ts).toISOString().slice(11,16);
  }
  function dayOffsetFromNowUtc(ts, refMs=Date.now()){
    if(ts == null || !isFinite(ts)) return 0;
    const base = utcDayStartMs(refMs);
    const off = Math.floor((ts - base) / DAY_MS);
    return Math.max(0, off);
  }
  function fmtHHMMPlusText(ts, refMs=Date.now()){
    const base = fmtHHMMFromTs(ts);
    if(base === "—") return base;
    const off = dayOffsetFromNowUtc(ts, refMs);
    return off > 0 ? `${base} +${off}` : base;
  }
  function fmtHHMMPlusHtml(ts, refMs=Date.now()){
    const base = fmtHHMMFromTs(ts);
    if(base === "—") return base;
    const off = dayOffsetFromNowUtc(ts, refMs);
    return off > 0 ? `${base}<span class="dayPlus">+${off}</span>` : base;
  }

  /********************
   * XP Logic (localized labels)
   ********************/
  const atcWeights = { s1:1.00, s2:1.05, s3:1.10, c1:1.15, c2:1.20, c3:1.25, i1:1.30, i2:1.35, i3:1.40, sup:1.45, adm:1.50 };
  const XP_HOURS_CAP = 20000;
  const PILOT_HOURS_FACTOR = 0.85;
  const AGE_BONUS_MAX = 120;
  const AGE_BONUS_CAP_YEARS = 10;
  const AGE_BONUS_MIN_HOURS = 30;
  const AGE_BONUS_FULL_HOURS = 200;
  const AGE_BONUS_MIN_HPY = 6;
  const AGE_BONUS_FULL_HPY = 30;
  const AGE_BONUS_DOMINANCE = 0.35;
  const AGE_BONUS_EXTRA_CAP = 15;

  const XP_LEVELS = {
    new:        { de:"Neu",            en:"New",         sde:"Neu",  sen:"New" },
    starter:    { de:"Einsteiger",     en:"Beginner",    sde:"Einst.", sen:"Beg." },
    advanced:   { de:"Fortgeschritten",en:"Advanced",    sde:"Fortg.", sen:"Adv." },
    experienced:{ de:"Erfahren",       en:"Experienced", sde:"Erf.", sen:"Exp." },
    veteran:    { de:"Veteran",        en:"Veteran",     sde:"Vet.",  sen:"Vet." }
  };

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function smoothstep(edge0, edge1, x){
    if(edge1 <= edge0) return x >= edge1 ? 1 : 0;
    const t0 = clamp01((x - edge0) / (edge1 - edge0));
    return t0 * t0 * (3 - 2 * t0);
  }
  function fmtHours(h){
    if(h == null || !isFinite(h)) return "—";
    if(h < 10) return `${h.toFixed(2)}h`;
    if(h < 100) return `${h.toFixed(1)}h`;
    return `${Math.round(h)}h`;
  }
  function fmtDateUtc(iso){
    try{
      const d = new Date(iso);
      if(!isFinite(d)) return "—";
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth()+1).padStart(2,"0");
      const da = String(d.getUTCDate()).padStart(2,"0");
      return `${y}-${m}-${da}`;
    }catch{ return "—"; }
  }
  function levelLabel(key){
    const L = XP_LEVELS[key] || XP_LEVELS.new;
    return (lang() === "en") ? L.en : L.de;
  }
  function levelShort(key){
    const L = XP_LEVELS[key] || XP_LEVELS.new;
    return (lang() === "en") ? L.sen : L.sde;
  }

  function normalizedThresholds(th){
    let t1 = clampInt(th?.t1 ?? 20, 1, 99);
    let t2 = clampInt(th?.t2 ?? 40, 2, 100);
    let t3 = clampInt(th?.t3 ?? 60, 3, 100);
    let t4 = clampInt(th?.t4 ?? 80, 4, 100);
    t2 = Math.max(t2, t1+1);
    t3 = Math.max(t3, t2+1);
    t4 = Math.max(t4, t3+1);
    t4 = Math.min(t4, 100);
    t3 = Math.min(t3, t4-1);
    t2 = Math.min(t2, t3-1);
    t1 = Math.min(t1, t2-1);
    return { t1,t2,t3,t4 };
  }

  function levelFromScore(score){
    const {t1,t2,t3,t4} = normalizedThresholds(settings.xpThresholds);
    if(score < t1) return { key:"new", cls:"bad" };
    if(score < t2) return { key:"starter", cls:"warn" };
    if(score < t3) return { key:"advanced", cls:"info" };
    if(score < t4) return { key:"experienced", cls:"good" };
    return { key:"veteran", cls:"good" };
  }

  function computeExperience(details, stats){
    if(details === null || stats === null) {
      return {
        levelKey:null, label:t("xp_na"), short:t("xp_na"), cls:"missing", score:null, atcWeighted:null,
        reasons:[t("xp_missing_reasons_1"), t("xp_missing_reasons_2")]
      };
    }

    if(!details || !stats){
      return { levelKey:null, label:"—", short:"—", cls:"info", score:null, atcWeighted:null, reasons:[t("xp_loading")] };
    }

    const pilot = Number(stats.pilot || 0);
    const atc = Number(stats.atc || 0);

    let atcWeighted = 0;
    for(const [k,w] of Object.entries(atcWeights)){
      atcWeighted += Number(stats[k] || 0) * w;
    }

    const atcBonusFactor = 1.20;
    const totalWeightedHours = (pilot * PILOT_HOURS_FACTOR) + (atcWeighted * atcBonusFactor);

    let ageDays = null;
    try{
      const reg = new Date(details.reg_date);
      if(isFinite(reg)) ageDays = (Date.now() - reg.getTime()) / 86400000;
    }catch{}

    const totalOnlineHours = pilot + atc;
    const ageYears = (ageDays && ageDays > 0) ? (ageDays / 365.25) : null;
    const baseAgeBonus = (ageDays && ageDays > 0)
      ? Math.min(AGE_BONUS_MAX, (Math.log1p(ageDays) / Math.log(1 + (AGE_BONUS_CAP_YEARS * 365))) * AGE_BONUS_MAX) : 0;

    const activityFactor = smoothstep(AGE_BONUS_MIN_HOURS, AGE_BONUS_FULL_HOURS, totalOnlineHours);
    const hoursPerYear = (ageYears && isFinite(ageYears) && ageYears > 0) ? (totalOnlineHours / Math.max(0.25, ageYears)) : 0;
    const densityFactor = smoothstep(AGE_BONUS_MIN_HPY, AGE_BONUS_FULL_HPY, hoursPerYear);
    const dominanceCap = (totalWeightedHours * AGE_BONUS_DOMINANCE) + AGE_BONUS_EXTRA_CAP;
    const ageBonus = Math.max(0, Math.min(baseAgeBonus * activityFactor * densityFactor, dominanceCap));

    const raw = totalWeightedHours + ageBonus;
    const score = Math.max(0, Math.min(100, Math.round((Math.log1p(raw) / Math.log(1 + XP_HOURS_CAP)) * 100)));
    const mapped = levelFromScore(score);

    const reasons = [];
    reasons.push(t("xp_reason_pilot", { h: fmtHours(pilot), f: PILOT_HOURS_FACTOR.toFixed(2) }));
    reasons.push(t("xp_reason_atc", { h: fmtHours(atc), f: atcBonusFactor.toFixed(2) }));
    if(ageDays != null) reasons.push(t("xp_reason_reg", { d: fmtDateUtc(details.reg_date) }));
    else reasons.push(t("xp_reason_reg_missing"));

    return { levelKey:mapped.key, label: levelLabel(mapped.key), short: levelShort(mapped.key), cls:mapped.cls, score, atcWeighted, reasons };
  }

  function experienceTooltipText(details, stats, exp){
    if(exp && exp.cls === 'missing') return t("xp_missing_tip");
    const lines = [];
    lines.push(t("tooltip_header", { cid: details?.id ?? "—", score: exp?.score ?? "—", label: exp?.label ?? "" }));
    lines.push(t("tooltip_reg", { d: details?.reg_date ? fmtDateUtc(details.reg_date) : "—" }));
    if(stats){
      lines.push(t("tooltip_hours", { p: fmtHours(stats.pilot), a: fmtHours(stats.atc) }));
    }
    return lines.join("\n");
  }

  function rebuildLegend(){
    const {t1,t2,t3,t4} = normalizedThresholds(settings.xpThresholds);
    legendInner.innerHTML = `
      <span class="legendTitle">${escapeHtml(t("legend_title"))}</span>
      <span class="xpPill bad" style="cursor:default"><span class="xDot"></span><span class="lvl">${escapeHtml(levelShort("new"))}</span><span class="score">0–${t1-1}</span></span>
      <span class="xpPill warn" style="cursor:default"><span class="xDot"></span><span class="lvl">${escapeHtml(levelShort("starter"))}</span><span class="score">${t1}–${t2-1}</span></span>
      <span class="xpPill info" style="cursor:default"><span class="xDot"></span><span class="lvl">${escapeHtml(levelShort("advanced"))}</span><span class="score">${t2}–${t3-1}</span></span>
      <span class="xpPill good" style="cursor:default"><span class="xDot"></span><span class="lvl">${escapeHtml(levelShort("experienced"))}</span><span class="score">${t3}–${t4-1}</span></span>
      <span class="xpPill good" style="cursor:default"><span class="xDot"></span><span class="lvl">${escapeHtml(levelShort("veteran"))}</span><span class="score">${t4}–100</span></span>
      <span class="xpPill missing" style="cursor:default"><span class="xDot"></span><span class="lvl">${escapeHtml(t("xp_na"))}</span></span>
      <span class="legendNote">${escapeHtml(t("legend_note"))}</span>
    `;
  }

  /********************
   * FIDS Logic
   ********************/
  function parseClockHHMM(s){
    const tt = (s||"").trim();
    if(!/^\d{4}$/.test(tt)) return null;
    const hh = Number(tt.slice(0,2));
    const mm = Number(tt.slice(2,4));
    if(hh>23 || mm>59) return null;
    return hh*60 + mm;
  }
  function parseDurationHHMM(s){
    const tt = (s||"").trim();
    if(!/^\d{4}$/.test(tt)) return null;
    const hh = Number(tt.slice(0,2));
    const mm = Number(tt.slice(2,4));
    if(mm>59) return null;
    return hh*60 + mm;
  }
  function clockMinToTsNearFuture(refMinOfDay, refMs=Date.now(), maxPastMin=180){
    if(refMinOfDay == null) return null;
    const base = utcDayStartMs(refMs);
    let ts = base + refMinOfDay * 60000;
    const diff = ts - refMs;
    if(diff < -12*3600*1000) ts += DAY_MS;
    else if(diff > 12*3600*1000) ts -= DAY_MS;
    if(ts < refMs - maxPastMin*60000) ts += DAY_MS;
    return ts;
  }
  function plannedStdTs(deptimeHHMM, refMs=Date.now()){
    const m = parseClockHHMM(deptimeHHMM);
    return m == null ? null : clockMinToTsNearFuture(m, refMs, 240);
  }
  function plannedEtaTs(stdTs, enrouteHHMM){
    const durMin = parseDurationHHMM(enrouteHHMM);
    if(stdTs == null || durMin == null) return null;
    return stdTs + durMin*60000;
  }

  function altGsText(p){
    const rawAlt = (p.altitude ?? null);
    const gs = (p.groundspeed ?? null);
    const alt = rawAlt != null ? Math.round(rawAlt / 100) * 100 : null;
    const a = (alt != null) ? String(alt).padStart(5," ") : "  —  ";
    const g = (gs != null) ? String(Math.round(gs)).padStart(3," ") : "—";
    return `${a} / ${g}`;
  }

  function escapeHtml(s){
    return String(s ?? "").replace(/[&<>"']/g, (c) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
  }

  // Status Helpers
  let prevPilotStates = new Map();
  let statusMemory = new Map();
  const STATUS_BANDS = { NEAR_APT_NM: 7, APPROACH_ENTER_NM: 55, APPROACH_EXIT_NM: 82, FINAL_ENTER_NM: 10, FINAL_EXIT_NM: 18, DEPAREA_ENTER_NM: 25, DEPAREA_EXIT_NM: 40 };

  function computeVerticalRateFpm(prev, curAlt, curT){
    if(!prev || prev.alt == null || prev.t == null) return null;
    const dt = (curT - prev.t) / 1000;
    if(!isFinite(dt) || dt <= 2) return null;
    return ((Number(curAlt) - Number(prev.alt)) / dt) * 60;
  }
  function statusKey(cid, boardType){ return `${boardType}:${String(cid)}`; }

  function stabilizeStatus(key, candidate){
    const now = Date.now();
    const sig = `${candidate.phase}|${candidate.rank}|${candidate.text}|${candidate.cls}|${candidate.finished?1:0}`;
    const dwellMs = Math.max(9000, Math.min(45000, Math.round((settings.feedIntervalMs || 15000) * 0.9)));
    let mem = statusMemory.get(key);
    if(!mem){
      mem = { status: candidate, sig, lastChange: now, lastSeen: now, pendSig: null, pendCount: 0 };
      statusMemory.set(key, mem);
      return candidate;
    }
    mem.lastSeen = now;
    if(sig === mem.sig){ mem.pendSig = null; mem.pendCount = 0; return mem.status; }
    if(candidate.finished || mem.status.finished){
      mem.status = candidate; mem.sig = sig; mem.lastChange = now; mem.pendSig = null; mem.pendCount = 0;
      return candidate;
    }
    const withinDwell = (now - mem.lastChange) < dwellMs;
    const strongerChange = candidate.rank < mem.status.rank;
    if(withinDwell && !strongerChange) return mem.status;

    if(mem.pendSig === sig) mem.pendCount++;
    else { mem.pendSig = sig; mem.pendCount = 1; }

    const need = strongerChange ? 1 : 2;
    if(mem.pendCount >= need){
      mem.status = candidate; mem.sig = sig; mem.lastChange = now; mem.pendSig = null; mem.pendCount = 0;
      return candidate;
    }
    return mem.status;
  }

  function pruneStatusMemory(){
    const now = Date.now();
    const ttl = 20 * 60 * 1000;
    for(const [k,v] of statusMemory.entries()){ if(!v?.lastSeen || (now - v.lastSeen) > ttl) statusMemory.delete(k); }
  }

  function statusTxt(key, vars){ return t(`status_${key}`, vars); }

  function classifyFlight(p, boardType){
    const fp = p.flight_plan;
    const dep = normalizeCode(fp?.departure || "");
    const arr = normalizeCode(fp?.arrival || "");
    const depAp = getAirport(dep);
    const arrAp = getAirport(arr);
    const lat = Number(p.latitude);
    const lon = Number(p.longitude);
    const alt = Number(p.altitude || 0);
    const gs  = Number(p.groundspeed || 0);
    const nowT = Date.now();
    const prev = prevPilotStates.get(String(p.cid));
    const vr = computeVerticalRateFpm(prev, alt, nowT);
    const absVr = (vr == null) ? null : Math.abs(vr);
    const climbing  = (vr != null && vr > 350);
    const descending = (vr != null && vr < -350);

    const dDep = (depAp ? haversineNm(lat, lon, depAp.latitude, depAp.longitude) : null);
    const dArr = (arrAp ? haversineNm(lat, lon, arrAp.latitude, arrAp.longitude) : null);

    // SMART GROUND LOGIC (Elevation Aware)
    let groundRef = 0;
    if(depAp && dDep != null && dDep < 15) groundRef = depAp.elevation;
    else if(arrAp && dArr != null && dArr < 15) groundRef = arrAp.elevation;

    const isGroundAlt = groundRef > 0 ? (alt < (groundRef + 350)) : (alt < 1500);
    const onGround = (gs < 45 && isGroundAlt);
    const airborne = !onGround;

    const nearDep = (dDep != null && dDep < STATUS_BANDS.NEAR_APT_NM);
    const nearArr = (dArr != null && dArr < STATUS_BANDS.NEAR_APT_NM);
    const key = statusKey(p.cid, boardType);
    const prevStable = statusMemory.get(key)?.status || null;
    const prevPhase = prevStable?.phase || null;
    const approachBand = (prevPhase === "APPROACH" || prevPhase === "FINAL" || prevPhase === "GOAROUND") ? STATUS_BANDS.APPROACH_EXIT_NM : STATUS_BANDS.APPROACH_ENTER_NM;
    const finalBand = (prevPhase === "FINAL") ? STATUS_BANDS.FINAL_EXIT_NM : STATUS_BANDS.FINAL_ENTER_NM;
    const depBand = (prevPhase === "DEPARTING" || prevPhase === "CLIMB") ? STATUS_BANDS.DEPAREA_EXIT_NM : STATUS_BANDS.DEPAREA_ENTER_NM;
    const inApproachZone = (dArr != null && dArr <= approachBand);
    const inFinalZone    = (dArr != null && dArr <= finalBand);
    const inDepZone      = (dDep != null && dDep <= depBand);
    const stableCruise = airborne && alt >= 20000 && gs >= 140 && (absVr == null || absVr < 350) && !(inApproachZone);

    const finalCeiling = dArr != null ? Math.max(1800, Math.min(9500, dArr*330 + 1100)) : 5000;
    const finalOk = airborne && inFinalZone && gs >= 80 && alt <= finalCeiling && (descending || (vr != null && vr < -200) || alt <= 3500);

    const approachOk = airborne && inApproachZone && gs >= 80 && (descending || alt <= 16000 || (dArr != null && dArr < 35 && alt <= 21000));
    const goAroundOk = airborne && inApproachZone && climbing && alt <= 11000 && gs >= 90;

    function divertText(){
      const nearest = findNearestAirport(lat, lon, 10);
      if(nearest){
        if(nearest.ap.icao && nearest.ap.icao !== arr && nearest.ap.icao !== dep) return statusTxt("diverted_at", { icao: nearest.ap.icao });
        return statusTxt("on_ground_at", { icao: nearest.ap.icao });
      }
      return statusTxt("on_ground_unknown");
    }
let gateLabel = null;
let gateIcaoForThis = null;
let groundState = null; // { isStationary, taxiSure, uncertain }

try{
  const focusIcao = currentAirportIcao;

  // Welche Airport-Gates sollen wir matchen?
  if(onGround){
    if(boardType === "dep" && dep === focusIcao && nearDep){
      gateIcaoForThis = focusIcao; // Departures: Gate am Fokus-Airport
    }else if(boardType === "arr" && arr === focusIcao){
      if(nearArr){
        gateIcaoForThis = focusIcao; // Arrivals: Gate am Ziel (Fokus)
      }else if(nearDep){
        gateIcaoForThis = dep;       // Arrivals: noch am Origin → Gate am Origin
      }
    }
  }

  if(gateIcaoForThis){
    const idx = gateIndexByIcao.get(gateIcaoForThis) || null;
if(idx){
  const r = resolveGateForCid(p.cid, lat, lon, gs, idx, gateIcaoForThis);
  gateLabel = r?.gate ? r.gate.label : null;
  groundState = r?.ground || null;
}else{
  // async laden, nächster Refresh hat Gate-Daten
  ensureGateIndexForIcao(gateIcaoForThis).catch(()=>{});
  // trotzdem Samples weiter füttern (für Stationary/Hysterese + Cache-Gate)
  const r = resolveGateForCid(p.cid, lat, lon, gs, null, gateIcaoForThis);
  gateLabel = r?.gate ? r.gate.label : null;       // wichtig: Cache-Gate kann schon da sein
  groundState = r?.ground || null;
}
  }else{
    // Samples weiterführen, wenn wir “fast” am Airport sind (gegen Flattern)
    if(onGround){
      const keepIcao =
        (dep === focusIcao && dDep != null && dDep < 3) ? focusIcao :
        (arr === focusIcao && dArr != null && dArr < 3) ? focusIcao :
        null;
      if(keepIcao){
        const idx = gateIndexByIcao.get(keepIcao) || null;
        resolveGateForCid(p.cid, lat, lon, gs, idx, keepIcao);
      }
    }
  }
}catch{}


    let cand = { phase:"UNK", rank:99, text:"—", cls:"info", finished:false };

    if(boardType === "dep"){
      if(p.__prefile) cand = { phase:"PREFILE", rank:0, text: statusTxt("prefile"), cls:"info", finished:false };
else if(onGround && nearDep){
  const taxiSure = !!groundState?.taxiSure;
  const atGateSure = !!groundState?.isStationary;

  let txt;
  if(taxiSure){
    txt = statusTxt("taxi");
  }else if(atGateSure){
    txt = gateLabel ? statusTxt("gate_named", { gate: gateLabel }) : statusTxt("gate_plain");
  }else{
    txt = statusTxt("gate"); // Fallback: Am Gate / Taxi
  }

  cand = { phase:"GATE", rank:0, text: txt, cls:"info", finished:false };
}
      else if(airborne && inDepZone){
        if(alt < 7000) cand = { phase:"DEPARTING", rank:1, text: statusTxt("departing"), cls:"warn", finished:false };
        else cand = { phase:"CLIMB", rank:1, text: statusTxt("climb"), cls:"warn", finished:false };
      }
      else if(airborne){
        if(goAroundOk) cand = { phase:"GOAROUND", rank:3, text: statusTxt("goaround"), cls:"warn", finished:false };
        else if(finalOk) cand = { phase:"FINAL", rank:3, text: statusTxt("final"), cls:"warn", finished:false };
        else if(approachOk) cand = { phase:"APPROACH", rank:3, text: statusTxt("approach"), cls:"warn", finished:false };
        else if(descending && alt < 30000) cand = { phase:"DESCENT", rank:3, text: statusTxt("descent"), cls:"warn", finished:false };
        else if(stableCruise) cand = { phase:"CRUISE", rank:2, text: statusTxt("cruise"), cls:"good", finished:false };
        else {
          if(prevPhase === "APPROACH" && dArr != null && dArr < STATUS_BANDS.APPROACH_EXIT_NM) cand = { phase:"APPROACH", rank:3, text: statusTxt("approach"), cls:"warn", finished:false };
          else cand = { phase:"CRUISE", rank:2, text: statusTxt("cruise"), cls:"good", finished:false };
        }
      }
      else {
        cand = { phase:"FINISHED", rank:4, text: nearArr ? statusTxt("landed_dest") : divertText(), cls: nearArr ? "good" : "bad", finished:true };
      }
    } else {
      if(p.__prefile) cand = { phase:"PREFILE", rank:6, text: statusTxt("prefile"), cls:"info", finished:false };
      else if(airborne){
        if(goAroundOk) cand = { phase:"GOAROUND", rank:0, text: statusTxt("goaround"), cls:"warn", finished:false };
        else if(finalOk) cand = { phase:"FINAL", rank:0, text: statusTxt("final"), cls:"warn", finished:false };
        else if(approachOk) cand = { phase:"APPROACH", rank:0, text: statusTxt("approach"), cls:"warn", finished:false };
        else if(descending && alt < 30000 && dArr != null && dArr < 180) cand = { phase:"DESCENT", rank:1, text: statusTxt("descent"), cls:"info", finished:false };
        else if(stableCruise) cand = { phase:"CRUISE", rank:1, text: statusTxt("cruise"), cls:"good", finished:false };
        else if(airborne && dDep != null && dDep < depBand && (climbing || alt < 18000)) cand = { phase:"DEPAREA", rank:2, text: statusTxt("deparea"), cls:"info", finished:false };
        else cand = { phase:"CRUISE", rank:1, text: statusTxt("cruise"), cls:"good", finished:false };
      } else {
  if(nearArr){
    // gelandet am Ziel (Fokus)
    cand = {
      phase:"FINISHED",
      rank:3,
      text: gateLabel ? statusTxt("landed_gate", { gate: gateLabel }) : statusTxt("landed"),
      cls:"good",
      finished:true
    };
} else if(nearDep) {
  const taxiSure = !!groundState?.taxiSure;
  const atGateSure = !!groundState?.isStationary;

  let txt;
  if(taxiSure){
    txt = statusTxt("taxi");
  }else if(atGateSure){
    // NUR wenn Gate angezeigt wird: "@ICAO" anhängen (Requirement)
    txt = gateLabel
      ? statusTxt("gate_named_at", { gate: gateLabel, icao: dep })
      : statusTxt("gate_plain");
  }else{
    txt = statusTxt("gate"); // Fallback: Am Gate / Taxi
  }

  cand = { phase:"GATE", rank:6, text: txt, cls:"info", finished:false };
}
 else {
    // irgendwo am Boden (divert/unknown)
    cand = { phase:"FINISHED", rank:3, text: divertText(), cls:"info", finished:true };
  }
}

}
    return stabilizeStatus(key, cand);
  }

  // ETA Logic
  let etaMemory = new Map();
  function etaKey(cid, boardType){ return `eta:${boardType}:${String(cid)}`; }
  function computeTrackSpeedKts(prev, lat, lon, nowMs){
    if(!prev || prev.lat==null || prev.lon==null || !prev.t) return null;
    const dtH = (nowMs - prev.t) / 3600000;
    if(!isFinite(dtH) || dtH < 0.0025) return null;
    const kts = haversineNm(lat, lon, prev.lat, prev.lon) / dtH;
    if(!isFinite(kts) || kts < 30 || kts > 750) return null;
    return kts;
  }
  function stabilizeEta(key, candTs, phase){
  const now = Date.now();
  let mem = etaMemory.get(key);

  if(candTs == null || !isFinite(candTs)){
    if(mem && (now - mem.lastSeen) < 2*60*1000){ mem.lastSeen = now; return mem.etaTs; }
    return null;
  }

  const curPhase = phase || "UNK";

  if(!mem){
    mem = { etaTs: candTs, lastSeen: now, phase: curPhase };
    etaMemory.set(key, mem);
    return candTs;
  }

  mem.lastSeen = now;

  const prev = mem.etaTs;
  const prevPhase = mem.phase || "UNK";

  // Snap bei “Ground/PREFILE/FINISHED”-Transitions (damit Bugs sofort verschwinden)
  const snapPhase = (x) => (x==="GATE" || x==="PREFILE" || x==="FINISHED");
  if(prevPhase !== curPhase && (snapPhase(prevPhase) || snapPhase(curPhase))){
    mem.etaTs = candTs;
    mem.phase = curPhase;
    return candTs;
  }

  // Snap wenn vorheriger ETA offensichtlich “veraltet” ist
  if(isFinite(prev) && prev < (now - 5*60*1000) && candTs > (now + 10*60*1000)){
    mem.etaTs = candTs;
    mem.phase = curPhase;
    return candTs;
  }

  const isClose = (curPhase==="FINAL" || curPhase==="APPROACH" || curPhase==="GOAROUND");
  const alpha = isClose ? 0.55 : 0.30;
  const raw = prev + (candTs - prev) * alpha;

  const maxJump = isClose ? 6*60*1000 : 18*60*1000;
  const diff = raw - prev;
  const limited = prev + Math.max(-maxJump, Math.min(maxJump, diff));

  mem.etaTs = limited;
  mem.phase = curPhase;
  return limited;
}
  function computeDynamicEtaTs(p, destAp, phase){
    if(!p || !destAp) return null;
    const lat = Number(p.latitude), lon = Number(p.longitude);
    if(!isFinite(lat) || !isFinite(lon)) return null;
    const now = Date.now();
    const distNm = haversineNm(lat, lon, destAp.latitude, destAp.longitude);
    if(!isFinite(distNm)) return null;
    const prev = prevPilotStates.get(String(p.cid));
    const derived = computeTrackSpeedKts(prev, lat, lon, now);
    const gs = Number(p.groundspeed || 0);
    let speed = Math.max(gs, derived || 0);
    const minSpeed = (phase==="FINAL" || phase==="APPROACH" || phase==="GOAROUND") ? 85 : 110;
    speed = Math.max(speed, minSpeed);
    speed = Math.min(speed, 560);
    if(distNm < 1.2) return now + 60*1000;
    const factor = (phase==="FINAL") ? 1.16 : (phase==="APPROACH") ? 1.12 : (phase==="DESCENT") ? 1.08 : (phase==="DEPAREA") ? 1.10 : 1.05;
    return now + (distNm / speed) * 60 * factor * 60000;
  }
  function applyEtaForFlight(f, focusAp, boardType){
    if(boardType !== "arr") return;
    const now = Date.now();
    const phase = f.status?.phase || "UNK";
    let cand = null;
    if(f.status?.finished){
      const lu = f.pilot?.last_updated ? new Date(f.pilot.last_updated).getTime() : null;
      cand = isFinite(lu) ? lu : (f.etaPlannedTs ?? null);
    } else if(f.__prefile){
      cand = f.etaPlannedTs ?? null;
    } else if((f.dFromPlanNm != null && f.dFromPlanNm <= (STATUS_BANDS.NEAR_APT_NM + 3)) && Number(f.pilot?.altitude || 0) < 2500 && Number(f.pilot?.groundspeed || 0) < 120){
      const durMin = parseDurationHHMM(f.fp?.enroute_time || "");
      if(durMin != null){
        const baseDep = (f.stdTs != null && f.stdTs > (now - 10*60000)) ? f.stdTs : now;
        cand = baseDep + durMin*60000;
      }else{ cand = f.etaPlannedTs ?? null; }
    } else {
      cand = computeDynamicEtaTs(f.pilot, focusAp, phase);
      if(isFinite(cand) && isFinite(f.etaPlannedTs) && Math.abs(f.etaPlannedTs - cand) < 4*3600*1000) cand = cand*0.70 + f.etaPlannedTs*0.30;
      else if(!isFinite(cand)) cand = f.etaPlannedTs ?? null;
      if(isFinite(cand) && cand < (now - 2*60*1000)) cand = now + 2*60*1000;
    }
    const sm = stabilizeEta(etaKey(f.cid, boardType), cand, phase);
    f.etaTs = sm;
    f.etaText = sm != null ? fmtHHMMPlusText(sm) : "—";
  }

  // Sorting
  const ARR_PHASE_ORDER = { GOAROUND:0, FINAL:1, APPROACH:2, DESCENT:3, CRUISE:4, DEPAREA:5, PREFILE:6, GATE:7, UNK:90, FINISHED:99 };
  const DEP_PHASE_ORDER = { PREFILE:0, GATE:1, DEPARTING:2, CLIMB:3, CRUISE:4, DESCENT:5, APPROACH:6, FINAL:7, GOAROUND:6, UNK:90, FINISHED:99 };
  function statusSensibleKey(f, boardType){
    const phase = f.status?.phase || "UNK";
    const base = (boardType==="arr") ? (ARR_PHASE_ORDER[phase] ?? 90) : (DEP_PHASE_ORDER[phase] ?? 90);
    let sub = 9e12;
    if(boardType === "arr"){
      if(phase==="FINAL" || phase==="APPROACH" || phase==="DESCENT" || phase==="GOAROUND") sub = Math.floor((f.dToFocusNm ?? 9999) * 1000);
      else { const ts = (f.etaTs ?? f.etaPlannedTs ?? null); sub = ts != null ? Math.floor(ts/1000) : 9e12; }
    } else {
      if(phase==="GATE" || phase==="PREFILE") { const ts = f.stdTs ?? null; sub = ts != null ? Math.floor(ts/1000) : 9e12; }
      else if(phase==="DEPARTING" || phase==="CLIMB") sub = Math.floor((f.dFromFocusNm ?? 9999) * 1000);
      else sub = Math.floor((f.dToPlanNm ?? 9999) * 1000);
    }
    return base*1e12 + sub;
  }
  function sortFlights(list, {by, dir}, boardType){
    const d = dir || 1;
    const coll = [...list];
    const keyFn = (f) => {
      if(by === "status") return statusSensibleKey(f, boardType);
      if(by === "callsign") return f.callsign;
      if(by === "dest") return f.arr;
      if(by === "orig") return f.dep;
      if(by === "xp") return (f.exp?.score ?? -1);
      if(by === "time") return (boardType === "dep" ? (f.stdTs ?? 9e15) : (f.etaTs ?? f.etaPlannedTs ?? 9e15));
      return 0;
    };
    coll.sort((a,b) => {
      const fa = a.status?.finished ? 1 : 0;
      const fb = b.status?.finished ? 1 : 0;
      if(fa !== fb) return fa - fb;
      const ka = keyFn(a); const kb = keyFn(b);
      if(typeof ka === "number" && typeof kb === "number"){ if(ka !== kb) return d * (ka - kb); }
      else { const sa = String(ka ?? ""), sb = String(kb ?? ""); const c = sa.localeCompare(sb, "en", { sensitivity:"base" }); if(c !== 0) return d * c; }
      const ta = (boardType === "dep") ? (a.stdTs ?? 9e15) : (a.etaTs ?? a.etaPlannedTs ?? 9e15);
      const tb = (boardType === "dep") ? (b.stdTs ?? 9e15) : (b.etaTs ?? b.etaPlannedTs ?? 9e15);
      if(ta !== tb) return ta - tb;
      return a.callsign.localeCompare(b.callsign, "en", { sensitivity:"base" });
    });
    return coll;
  }

  /********************
   * Rendering (dynamic columns)
   ********************/
  let renderEpoch = 0;

  class Board {
    constructor(tbody, boardType){
      this.tbody = tbody;
      this.boardType = boardType;
      this.rows = new Map();
    }
    getLayout(){
      return settings.boardLayout[this.boardType];
    }
    getVisibleKeys(){
      const layout = this.getLayout();
      return layout.order.filter(k => layout.visible[k]);
    }
    reset(){
      this.rows.clear();
      this.tbody.innerHTML = "";
    }
    makeRow(f){
      const tr = document.createElement("tr");
      tr.dataset.id = String(f.id);
      tr.__cells = {};
      tr.__statusSig = null;
      tr.__blinkActive = false;
      tr.__blinkSetAt = -1;

      const keys = this.getVisibleKeys();
      for(const key of keys){
        const td = document.createElement("td");
        const meta = COL_META[key] || {};
        if(meta.tdClass) td.className = meta.tdClass;
        if(key === "typeRoute" && !td.classList.contains("cell-route")) td.classList.add("cell-route");
        if(key === "time") td.classList.add("center");
        tr.__cells[key] = td;
        tr.appendChild(td);
      }

      tr.addEventListener("click", () => {
        if(window.getSelection && String(window.getSelection()).length) return;
        openPilotModal(tr.__flight || f);
      });

      tr.__flight = f;
      return tr;
    }

    updateXpCell(td, f){
      if(!td) return;
      let pill = td.querySelector(".xpPill");
      if(!pill){
        td.innerHTML = `<span class="xpPill loading info" data-cid="${escapeHtml(f.cid)}" data-tip="${escapeHtml(t("xp_loading"))}"><span class="spinner" aria-hidden="true"></span><span class="lvl">XP</span><span class="score">…</span></span>`;
        pill = td.querySelector(".xpPill");
      }

      if(f.exp && f.exp.cls === 'missing') {
        pill.className = "xpPill missing";
        pill.innerHTML = `<span class="xDot" aria-hidden="true"></span><span class="lvl">${escapeHtml(t("xp_na"))}</span>`;
        pill.dataset.tip = t("xp_missing_tip");
        return;
      }

      if(f.exp && f.exp.score != null && f.details && f.stats){
        pill.classList.remove("loading");
        pill.classList.remove("good","warn","bad","info","missing");
        pill.classList.add(f.exp.cls || "info");
        pill.innerHTML = `<span class="xDot" aria-hidden="true"></span><span class="lvl">${escapeHtml(f.exp.short)}</span><span class="score">${escapeHtml(String(f.exp.score))}</span>`;
        pill.dataset.tip = experienceTooltipText(f.details, f.stats, f.exp);
      }else{
        pill.className = "xpPill loading info";
        pill.innerHTML = `<span class="spinner" aria-hidden="true"></span><span class="lvl">XP</span><span class="score">…</span>`;
        pill.dataset.tip = t("xp_loading");
      }
    }

    updateRow(tr, f){
      if(f.status?.finished) tr.classList.add("finishedRow"); else tr.classList.remove("finishedRow");
      if(tr.__blinkActive && tr.__blinkSetAt < renderEpoch) tr.__blinkActive = false;

      const newSig = `${f.status.rank}|${f.status.text}|${f.status.cls}|${f.status.finished ? 1 : 0}`;
      if(tr.__statusSig && tr.__statusSig !== newSig){ tr.__blinkActive = true; tr.__blinkSetAt = renderEpoch; }
      tr.__statusSig = newSig;

      const c = tr.__cells;

      if(c.time){
        const ts = (this.boardType === "dep") ? f.stdTs : (f.etaTs ?? f.etaPlannedTs);
        c.time.innerHTML = fmtHHMMPlusHtml(ts);
      }

      if(c.callsign){
        c.callsign.innerHTML = `<span style="font-weight:800">${escapeHtml(f.callsign)}</span>`;
        c.callsign.title = `${f.name || ""}\nCID: ${f.cid}`;
      }

      if(c.ap){
        c.ap.innerHTML = this.boardType === "dep"
          ? `<span style="font-weight:800">${escapeHtml(f.arr)}</span>`
          : `<span style="font-weight:800">${escapeHtml(f.dep)}</span>`;
      }

      if(c.typeRoute){
        const routeText = (f.route || "").trim() || `${f.dep} → ${f.arr}`;
        c.typeRoute.innerHTML = `<span style="font-weight:800">${escapeHtml(f.aircraft || "—")}</span><span class="muted"> · </span><span class="muted">${escapeHtml(routeText)}</span>`;
        c.typeRoute.title = routeText;
      }

      if(c.altgs){
        c.altgs.textContent = altGsText(f.pilot);
      }

      if(c.status){
        c.status.innerHTML = `<span class="badge ${f.status.cls}${tr.__blinkActive ? " blink" : ""}"><span class="sDot"></span><span>${escapeHtml(f.status.text)}</span></span>`;
      }

      if(c.xp){
        this.updateXpCell(c.xp, f);
      }

      tr.__flight = f;
    }

    async render(list){
      const first = new Map();
      for(const [id, tr] of this.rows) first.set(id, tr.getBoundingClientRect());
      const newIds = new Set(list.map(x => String(x.id)));

      for(const [id, tr] of [...this.rows.entries()]){
        if(!newIds.has(id)){
          tr.classList.add("removing");
          this.rows.delete(id);
          tr.addEventListener("transitionend", () => tr.remove(), { once:true });
          setTimeout(() => { if(tr.isConnected) tr.remove(); }, 400);
        }
      }

      for(const f of list){
        const id = String(f.id);
        let tr = this.rows.get(id);
        if(!tr){
          tr = this.makeRow(f);
          tr.classList.add("adding");
          this.rows.set(id, tr);
        }
        this.updateRow(tr, f);
      }

      const frag = document.createDocumentFragment();
      for(const f of list){
        const tr = this.rows.get(String(f.id));
        if(tr) frag.appendChild(tr);
      }
      this.tbody.appendChild(frag);

      requestAnimationFrame(() => {
        for(const [, tr] of this.rows){
          if(tr.classList.contains("adding")){
            tr.classList.remove("adding");
            tr.style.transition = "opacity .18s ease, transform .18s ease";
            tr.style.opacity = "1";
            tr.style.transform = "translateY(0)";
            setTimeout(() => { tr.style.transition = ""; tr.style.opacity = ""; tr.style.transform = ""; }, 250);
          }
        }
      });

      requestAnimationFrame(() => {
        for(const [id, tr] of this.rows){
          const firstRect = first.get(id);
          if(!firstRect) continue;
          const lastRect = tr.getBoundingClientRect();
          const dx = firstRect.left - lastRect.left;
          const dy = firstRect.top - lastRect.top;
          if(Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) continue;
          tr.style.transform = `translate(${dx}px, ${dy}px)`;
          tr.style.transition = "transform 0s";
          requestAnimationFrame(() => {
            tr.style.transition = "transform 420ms cubic-bezier(.2,.8,.2,1)";
            tr.style.transform = "";
          });
        }
      });
    }

    updateXpById(id){
      const tr = this.rows.get(String(id));
      if(!tr) return;
      const td = tr.__cells?.xp;
      if(td) this.updateXpCell(td, tr.__flight);
    }
  }

  const depBoard = new Board(depBody, "dep");
  const arrBoard = new Board(arrBody, "arr");

  /********************
   * Tooltip
   ********************/
  let tooltipActive = false;
  function showTooltip(text, x, y){
    tooltip.textContent = text;
    tooltip.style.left = `${x}px`;
    tooltip.style.top = `${y}px`;
    tooltip.classList.add("show");
    tooltipActive = true;
  }
  function hideTooltip(){
    tooltip.classList.remove("show");
    tooltipActive = false;
  }
  document.addEventListener("mousemove", (e) => {
    if(!tooltipActive) return;
    tooltip.style.left = `${e.clientX}px`;
    tooltip.style.top = `${e.clientY}px`;
  });
  function attachTooltipDelegation(tbody){
    tbody.addEventListener("mouseover", (e) => {
      const pill = e.target.closest(".xpPill");
      if(!pill) return;
      showTooltip(pill.dataset.tip || "—", e.clientX, e.clientY);
    });
    tbody.addEventListener("mouseout", (e) => {
      const pill = e.target.closest(".xpPill");
      if(!pill) return;
      hideTooltip();
    });
  }
  attachTooltipDelegation(depBody);
  attachTooltipDelegation(arrBody);

  /********************
   * Pilot Modal
   ********************/
  function setKv(el, pairs){
    el.innerHTML = "";
    for(const [k,v] of pairs){
      const dk = document.createElement("div");
      dk.className="k"; dk.textContent = k;
      const dv = document.createElement("div");
      dv.className="v"; dv.textContent = v;
      el.appendChild(dk); el.appendChild(dv);
    }
  }
  function setLinks(el, links){
    el.innerHTML = "";
    for(const {href, text} of links){
      const a = document.createElement("a");
      a.className = "aBtn";
      a.href = href;
      a.target = "_blank";
      a.rel = "noreferrer";
      a.textContent = text;
      el.appendChild(a);
    }
  }

  async function openPilotModal(f){
    pilotModalOverlay.classList.add("show");
    historyKv.innerHTML = "";
    xpList.innerHTML = "";
    xpLinks.innerHTML = "";

    pilotModalTitle.textContent = `${t("pilot_modal_title")} · CID ${f.cid} · ${f.callsign}`;
    pilotModalSubtitle.textContent = `${f.name || "—"} · ${f.dep} → ${f.arr}`;

    setKv(flightKv, [
      [t("kv_callsign"), f.callsign],
      [t("kv_cid"), String(f.cid)],
      [t("kv_name"), f.name || "—"],
      [t("kv_route"), `${f.dep} → ${f.arr}`],
      [t("kv_type"), f.aircraft || "—"],
      [t("kv_std"), f.stdTs != null ? fmtHHMMPlusText(f.stdTs) : "—"],
      [t("kv_eet"), (f.fp?.enroute_time ? (f.fp.enroute_time.slice(0,2)+":"+f.fp.enroute_time.slice(2,4)) : "—")],
      [t("kv_eta"), (f.etaTs != null ? fmtHHMMPlusText(f.etaTs) : (f.etaPlannedTs != null ? fmtHHMMPlusText(f.etaPlannedTs) : "—"))],
      [t("kv_status"), f.status?.text || "—"],
      [t("kv_last_updated"), f.pilot?.last_updated ? (new Date(f.pilot.last_updated).toISOString().slice(0,19) + "Z") : "—"]
    ]);

    let details = f.details, stats = f.stats, exp = f.exp;
    try{
      if(!details) details = await getMemberDetails(f.cid);
      if(!stats) stats = await getMemberStats(f.cid);
      exp = computeExperience(details, stats);
    }catch(err){
      console.warn("Modal fetch err:", err);
    }

    setKv(xpKv, [
      [t("kv_experience"), exp?.score != null ? `${exp.label} · Score ${exp.score}/100` : (exp?.cls==='missing' ? t("xp_na") : "—")],
      [t("kv_registered"), details?.reg_date ? fmtDateUtc(details.reg_date) : "—"],
      [t("kv_pilot_hours"), stats ? fmtHours(stats.pilot) : "—"],
      [t("kv_atc_hours"), stats ? fmtHours(stats.atc) : "—"],
      [t("kv_atc_weighted"), (stats && exp) ? fmtHours(exp.atcWeighted) : "—"],
      [t("kv_region_div"), (details?.region_id && details?.division_id) ? `${details.region_id} / ${details.division_id}` : "—"]
    ]);

    for(const r of (exp?.reasons || [])){
      const li = document.createElement("li");
      li.textContent = r;
      xpList.appendChild(li);
    }

    setLinks(xpLinks, [
      { href: `https://stats.vatsim.net/stats/${encodeURIComponent(f.cid)}`, text: "VATSIM Stats Center" }
    ]);

    try{
      const hist = await getMemberHistory(f.cid, { limit: 50 });
      if(hist){
        const items = Array.isArray(hist?.items) ? hist.items : [];
        const count = Number(hist?.count ?? items.length ?? 0);
        let lastEnd = null;
        for(const it of items){
          if(it?.end){
            const d = new Date(it.end);
            if(isFinite(d) && (!lastEnd || d > lastEnd)) lastEnd = d;
          }
        }
        setKv(historyKv, [
          [t("kv_sessions_ret"), String(items.length)],
          [t("kv_sessions_count"), String(count)],
          [t("kv_last_end"), lastEnd ? (lastEnd.toISOString().slice(0,19) + "Z") : "—"],
          [t("kv_note"), t("history_note_kv")]
        ]);
      } else {
        setKv(historyKv, [[t("pilot_card_history"), t("history_unavailable")]]);
      }
    }catch(err){
      setKv(historyKv, [[t("pilot_card_history"), t("history_error")]]);
    }
  }
  function closePilotModal(){ pilotModalOverlay.classList.remove("show"); }
  pilotModalClose.addEventListener("click", closePilotModal);
  pilotModalOverlay.addEventListener("click", (e) => { if(e.target === pilotModalOverlay) closePilotModal(); });

  /********************
   * Airport Pilot XP Index (header)
   ********************/
  let xpIndexRaf = 0;
  function scheduleAirportXpIndexUpdate(){
    if(xpIndexRaf) return;
    xpIndexRaf = requestAnimationFrame(() => {
      xpIndexRaf = 0;
      updateAirportXpIndex();
    });
  }
  function computeBoardXpIndex(list){
    const total = list.length;
    let sum = 0, loaded = 0;
    for(const f of list){
      const s = f?.exp?.score;
      if(s != null && isFinite(s)){
        sum += Number(s);
        loaded++;
      }
    }
    if(total === 0) return { total, loaded, avg:null, cls:"info" };
    if(loaded === 0) return { total, loaded, avg:null, cls:"info" };
    const avg = Math.round(sum / loaded);
    const mapped = levelFromScore(avg);
    return { total, loaded, avg, cls: mapped.cls || "info" };
  }
  function setIndexPill(pill, dot, valEl, cntEl, boardNameKey, idx){
    dot.className = "dot " + (idx.cls || "info");
    valEl.textContent = (idx.avg == null) ? (idx.total ? "…" : "—") : String(idx.avg);
    cntEl.textContent = `${idx.loaded}/${idx.total}`;
    pill.title = t("xp_index_title", { board: t(boardNameKey), loaded: idx.loaded, total: idx.total });
  }
  function updateAirportXpIndex(){
    const depIdx = computeBoardXpIndex(lastDeps);
    const arrIdx = computeBoardXpIndex(lastArrs);
    setIndexPill(depXpIndexPill, depXpIndexDot, depXpIndexVal, depXpIndexCnt, "dep_title", depIdx);
    setIndexPill(arrXpIndexPill, arrXpIndexDot, arrXpIndexVal, arrXpIndexCnt, "arr_title", arrIdx);
  }

  /********************
   * Config (tabs + board layout editor)
   ********************/
  let cfgDraftLayout = structuredClone(settings.boardLayout);

  function colNameForConfig(key, boardType){
    if(key === "time") return (boardType === "dep") ? t("th_time_std") : t("th_time_eta");
    if(key === "ap") return (boardType === "dep") ? t("th_to") : t("th_from");
    if(key === "callsign") return t("th_callsign");
    if(key === "typeRoute") return t("th_type_route");
    if(key === "altgs") return t("th_alt_gs");
    if(key === "status") return t("th_status");
    if(key === "xp") return t("th_xp");
    return key;
  }

  function renderColEditor(boardType, container){
    container.innerHTML = "";
    const lay = cfgDraftLayout[boardType];
    const keys = lay.order.slice();

    for(let i=0;i<keys.length;i++){
      const key = keys[i];
      const item = document.createElement("div");
      item.className = "colItem";
      item.dataset.key = key;

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = !!lay.visible[key];
      cb.title = "toggle";

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = colNameForConfig(key, boardType);

      const btns = document.createElement("div");
      btns.className = "miniBtns";

      const up = document.createElement("button");
      up.type = "button";
      up.className = "btnGhost";
      up.textContent = "▲";
      up.title = "Up";

      const dn = document.createElement("button");
      dn.type = "button";
      dn.className = "btnGhost";
      dn.textContent = "▼";
      dn.title = "Down";

      up.disabled = (i === 0);
      dn.disabled = (i === keys.length - 1);

      cb.addEventListener("change", () => { lay.visible[key] = !!cb.checked; });

      up.addEventListener("click", () => {
        const idx = lay.order.indexOf(key);
        if(idx > 0){
          const tmp = lay.order[idx-1];
          lay.order[idx-1] = lay.order[idx];
          lay.order[idx] = tmp;
          renderDisplayEditors();
        }
      });
      dn.addEventListener("click", () => {
        const idx = lay.order.indexOf(key);
        if(idx >= 0 && idx < lay.order.length-1){
          const tmp = lay.order[idx+1];
          lay.order[idx+1] = lay.order[idx];
          lay.order[idx] = tmp;
          renderDisplayEditors();
        }
      });

      btns.append(up, dn);
      item.append(cb, name, btns);
      container.appendChild(item);
    }
  }

  function renderDisplayEditors(){
    renderColEditor("dep", cfgDepCols);
    renderColEditor("arr", cfgArrCols);
  }

  function openConfigModal(){
    cfgAirport.value = settings.airportInput || "EDDB";
    cfgInterval.value = Math.round((settings.feedIntervalMs || 15000) / 1000);
    cfgLanguage.value = settings.language || "de";
    cfgPrefiles.checked = !!settings.showPrefiles;
    cfgHideArrLanded.checked = !!settings.hideArrivalsLanded;
    cfgHideDepFinished.checked = !!settings.hideDeparturesFinished;
    cfgXpHydrate.value = settings.xpHydrateMax ?? 40;

    const th = normalizedThresholds(settings.xpThresholds);
    cfgT1.value = th.t1; cfgT2.value = th.t2; cfgT3.value = th.t3; cfgT4.value = th.t4;

    cfgDraftLayout = structuredClone(settings.boardLayout);
    renderDisplayEditors();

    setActiveCfgTab("general");
    configModalOverlay.classList.add("show");
  }
  function closeConfigModal(){ configModalOverlay.classList.remove("show"); }
  configBtn.addEventListener("click", openConfigModal);
  configClose.addEventListener("click", closeConfigModal);
  cfgCancel.addEventListener("click", closeConfigModal);
  configModalOverlay.addEventListener("click", (e) => { if(e.target === configModalOverlay) closeConfigModal(); });

  cfgDefaults.addEventListener("click", () => {
    cfgAirport.value = DEFAULTS.airportInput;
    cfgInterval.value = Math.round(DEFAULTS.feedIntervalMs/1000);
    cfgLanguage.value = DEFAULTS.language;
    cfgPrefiles.checked = DEFAULTS.showPrefiles;
    cfgHideArrLanded.checked = DEFAULTS.hideArrivalsLanded;
    cfgHideDepFinished.checked = DEFAULTS.hideDeparturesFinished;
    cfgXpHydrate.value = DEFAULTS.xpHydrateMax;
    cfgT1.value = DEFAULTS.xpThresholds.t1;
    cfgT2.value = DEFAULTS.xpThresholds.t2;
    cfgT3.value = DEFAULTS.xpThresholds.t3;
    cfgT4.value = DEFAULTS.xpThresholds.t4;

    cfgDraftLayout = structuredClone(DEFAULTS.boardLayout);
    renderDisplayEditors();
  });

  function resetCache(){
    localStorage.removeItem(MEMBER_CACHE_KEY);
    localStorage.removeItem(API_LAST_REQ_KEY);
	localStorage.removeItem(GATE_CACHE_KEY);
	localStorage.removeItem(GATE_FLIGHT_CACHE_KEY);
	gateFlightCache = {};
    gateIndexByIcao.clear();
	gateLoadPromises.clear();
	gateMem.clear();
    memberCache = {};
    limiter.clear();
    inflightXp.clear();
    for(const f of [...lastDeps, ...lastArrs]){
      f.details = null; f.stats = null; f.exp = null;
      depBoard.updateXpById(f.id);
      arrBoard.updateXpById(f.id);
    }
    requestXpForVisibleFlights();
    scheduleAirportXpIndexUpdate();
  }
  cfgResetCache.addEventListener("click", () => { if(confirm(t("confirm_cache_reset"))) resetCache(); });

  cfgSave.addEventListener("click", async () => {
    const airport = normalizeCode(cfgAirport.value || "EDDB");
    const intervalS = clampInt(cfgInterval.value, 5, 120);
    const hydrateMax = clampInt(cfgXpHydrate.value, 10, 120);
    const th = normalizedThresholds({ t1: cfgT1.value, t2: cfgT2.value, t3: cfgT3.value, t4: cfgT4.value });

    settings.airportInput = airport;
    settings.feedIntervalMs = intervalS * 1000;
    settings.language = (cfgLanguage.value === "en") ? "en" : "de";

    settings.showPrefiles = !!cfgPrefiles.checked;
    settings.hideArrivalsLanded = !!cfgHideArrLanded.checked;
    settings.hideDeparturesFinished = !!cfgHideDepFinished.checked;

    settings.xpHydrateMax = hydrateMax;
    settings.xpThresholds = th;

    // Commit layout
    settings.boardLayout = {
      dep: normalizeLayout(cfgDraftLayout.dep, "dep"),
      arr: normalizeLayout(cfgDraftLayout.arr, "arr")
    };

    saveSettings();
    airportInputEl.value = settings.airportInput;

    // Apply UI updates
    applyLanguage();
    depBoard.reset();
    arrBoard.reset();

    await applyAirport(settings.airportInput, true);
    startLoop();
    closeConfigModal();
  });

  /********************
   * Loop / Feed
   ********************/
  let currentAirportIcao = "EDDB";
  let lastFeedTs = null;
  let feedTimer = null;

  let lastDeps = [];
  let lastArrs = [];
  let flightsByCid = new Map();
  let inflightXp = new Map();
  let resortTimers = { dep:null, arr:null };

  function setFeedStatus({ok, msg, ageSec}){
    feedDot.className = "dot " + (ok ? "good" : "bad");
    feedText.textContent = msg;
    feedAge.textContent = ageSec != null ? `${Math.max(0, Math.round(ageSec))}s` : "—";
  }

  async function fetchFeed(){
    const res = await fetch(VATSIM_DATA_URL, { cache:"no-store" });
    if(!res.ok) throw new Error(`Feed HTTP ${res.status}`);
    return res.json();
  }

  function buildFlightObjectFromPilot(p){
    const fp = p.flight_plan;
    const dep = normalizeCode(fp?.departure || "");
    const arr = normalizeCode(fp?.arrival || "");
    const stdTs = plannedStdTs(fp?.deptime || "", Date.now());
    const etaPlannedTs = plannedEtaTs(stdTs, fp?.enroute_time || "");
    return {
      id: p.cid,
      cid: p.cid,
      callsign: normalizeCode(p.callsign || ""),
      name: p.name || "",
      dep, arr,
      aircraft: normalizeCode(fp?.aircraft_short || fp?.aircraft_faa || fp?.aircraft || "—"),
      route: fp?.route || "",
      fp,
      pilot: p,
      stdTs,
      stdText: stdTs != null ? fmtHHMMPlusText(stdTs) : "—",
      etaPlannedTs,
      etaTs: etaPlannedTs,
      etaText: etaPlannedTs != null ? fmtHHMMPlusText(etaPlannedTs) : "—",
      dFromFocusNm: null,
      dToFocusNm: null,
      dToPlanNm: null,
      dFromPlanNm: null,
      status: { phase:"UNK", rank:99, text:"—", cls:"info", finished:false },
      details:null, stats:null, exp:null
    };
  }

  function buildFlightObjectFromPrefile(pf){
    const fp = pf.flight_plan;
    const dep = normalizeCode(fp?.departure || "");
    const arr = normalizeCode(fp?.arrival || "");
    const stdTs = plannedStdTs(fp?.deptime || "", Date.now());
    const etaPlannedTs = plannedEtaTs(stdTs, fp?.enroute_time || "");
    const pilotStub = { altitude:0, groundspeed:0, latitude:0, longitude:0, last_updated: pf.last_updated };
    return {
      id: "P" + pf.cid + "_" + normalizeCode(pf.callsign || ""),
      cid: pf.cid,
      callsign: normalizeCode(pf.callsign || ""),
      name: pf.name || "",
      dep, arr,
      aircraft: normalizeCode(fp?.aircraft_short || fp?.aircraft_faa || fp?.aircraft || "—"),
      route: fp?.route || "",
      fp,
      pilot: pilotStub,
      stdTs,
      stdText: stdTs != null ? fmtHHMMPlusText(stdTs) : "—",
      etaPlannedTs,
      etaTs: etaPlannedTs,
      etaText: etaPlannedTs != null ? fmtHHMMPlusText(etaPlannedTs) : "—",
      dFromFocusNm: null,
      dToFocusNm: null,
      dToPlanNm: null,
      dFromPlanNm: null,
      status: { phase:"PREFILE", rank:0, text: t("status_prefile"), cls:"info", finished:false },
      details:null, stats:null, exp:null,
      __prefile:true
    };
  }

  function applyCachedXpIfAvailable(f){
    const entry = getCacheEntry(f.cid);

    if(isCoolingDown(entry)) {
      f.details = null; f.stats = null;
      f.exp = computeExperience(null, null);
      return;
    }

    if(entry?.details && isFresh(entry.detailsTs, settings.memberTtlDetailsMs)) f.details = entry.details;
    if(entry?.stats && isFresh(entry.statsTs, settings.memberTtlStatsMs)) f.stats = entry.stats;
    if(f.details && f.stats) f.exp = computeExperience(f.details, f.stats);
  }

  async function ensureXpForCid(cid){
    cid = String(cid);
    if(inflightXp.has(cid)) return inflightXp.get(cid);

    const p = (async () => {
      const entry = getCacheEntry(cid);
      if(isCoolingDown(entry)) return { details:null, stats:null, exp: computeExperience(null, null) };

      let details = (entry?.details && isFresh(entry.detailsTs, settings.memberTtlDetailsMs)) ? entry.details : null;
      let stats   = (entry?.stats   && isFresh(entry.statsTs, settings.memberTtlStatsMs))   ? entry.stats   : null;

      if(!details) details = await getMemberDetails(cid);
      if(!stats)   stats   = await getMemberStats(cid);

      const exp = computeExperience(details, stats);
      return { details, stats, exp };
    })();

    inflightXp.set(cid, p);
    try{ return await p; } finally{ inflightXp.delete(cid); }
  }

  function scheduleResort(which){
    const isXpSort = (which === "dep") ? (settings.depSort.by === "xp") : (settings.arrSort.by === "xp");
    if(!isXpSort) return;
    if(resortTimers[which]) clearTimeout(resortTimers[which]);
    resortTimers[which] = setTimeout(async () => {
      resortTimers[which] = null;
      if(which === "dep"){
        lastDeps = sortFlights(lastDeps, settings.depSort, "dep");
        await depBoard.render(lastDeps);
      }else{
        lastArrs = sortFlights(lastArrs, settings.arrSort, "arr");
        await arrBoard.render(lastArrs);
      }
      scheduleAirportXpIndexUpdate();
    }, 650);
  }

  // Fair scheduling (interleaving)
  function requestXpForVisibleFlights(){
    const max = settings.xpHydrateMax ?? 40;

    const deps = lastDeps.slice(0, max);
    const arrs = lastArrs.slice(0, max);
    const targets = [];
    const len = Math.max(deps.length, arrs.length);
    for(let i=0; i<len; i++){
      if(i < deps.length) targets.push(deps[i]);
      if(i < arrs.length) targets.push(arrs[i]);
    }

    for(const f of targets){
      applyCachedXpIfAvailable(f);
      depBoard.updateXpById(f.id);
      arrBoard.updateXpById(f.id);
    }
    scheduleAirportXpIndexUpdate();

    const uniqueCids = new Set(targets.map(f => String(f.cid)));
    for(const cid of uniqueCids){
      const entry = getCacheEntry(cid);
      if(isCoolingDown(entry)) continue;

      const haveDetails = entry?.details && isFresh(entry.detailsTs, settings.memberTtlDetailsMs);
      const haveStats = entry?.stats && isFresh(entry.statsTs, settings.memberTtlStatsMs);
      if(haveDetails && haveStats) continue;

      ensureXpForCid(cid).then(({details, stats, exp}) => {
        const refs = flightsByCid.get(String(cid)) || [];
        for(const f of refs){
          f.details = details;
          f.stats = stats;
          f.exp = exp;
          depBoard.updateXpById(f.id);
          arrBoard.updateXpById(f.id);
        }
        scheduleResort("dep");
        scheduleResort("arr");
        scheduleAirportXpIndexUpdate();
      }).catch(() => {});
    }
  }

  async function refresh(){
    try{
      const data = await fetchFeed();
      renderEpoch++;

      lastFeedTs = data?.general?.update_timestamp ? new Date(data.general.update_timestamp) : null;
      const focus = currentAirportIcao;
      const focusAp = getAirport(focus);

      const pilots = Array.isArray(data?.pilots) ? data.pilots : [];
      const prefiles = (settings.showPrefiles && Array.isArray(data?.prefiles)) ? data.prefiles : [];

      let deps = [];
      let arrs = [];
      flightsByCid = new Map();

      const nextPrev = new Map(prevPilotStates);

      for(const p of pilots){
        nextPrev.set(String(p.cid), { alt:Number(p.altitude||0), lat:Number(p.latitude), lon:Number(p.longitude), t: Date.now() });

        const fp = p.flight_plan;
        if(!fp?.departure || !fp?.arrival) continue;

        const dep = normalizeCode(fp.departure);
        const arr = normalizeCode(fp.arrival);

        if(dep === focus){
          const f = buildFlightObjectFromPilot(p);
          f.status = classifyFlight(p, "dep");
          if(focusAp && isFinite(p.latitude) && isFinite(p.longitude)) f.dFromFocusNm = haversineNm(Number(p.latitude), Number(p.longitude), focusAp.latitude, focusAp.longitude);
          const arrAp = getAirport(arr);
          if(arrAp) f.dToPlanNm = haversineNm(Number(p.latitude), Number(p.longitude), arrAp.latitude, arrAp.longitude);
          applyCachedXpIfAvailable(f);
          if(!(settings.hideDeparturesFinished && f.status.finished)){
            deps.push(f);
            if(!flightsByCid.has(String(f.cid))) flightsByCid.set(String(f.cid), []);
            flightsByCid.get(String(f.cid)).push(f);
          }
        }

        if(arr === focus){
          const f = buildFlightObjectFromPilot(p);
          f.status = classifyFlight(p, "arr");
          if(focusAp && isFinite(p.latitude) && isFinite(p.longitude)) f.dToFocusNm = haversineNm(Number(p.latitude), Number(p.longitude), focusAp.latitude, focusAp.longitude);
          const depAp = getAirport(dep);
          if(depAp) f.dFromPlanNm = haversineNm(Number(p.latitude), Number(p.longitude), depAp.latitude, depAp.longitude);
          applyEtaForFlight(f, focusAp, "arr");
          applyCachedXpIfAvailable(f);
          if(!(settings.hideArrivalsLanded && f.status.finished)){
            arrs.push(f);
            if(!flightsByCid.has(String(f.cid))) flightsByCid.set(String(f.cid), []);
            flightsByCid.get(String(f.cid)).push(f);
          }
        }
      }

      prevPilotStates = nextPrev;
      pruneStatusMemory();
	  pruneGateMem();

      if(settings.showPrefiles){
        for(const pf of prefiles){
          const fp = pf.flight_plan;
          if(!fp?.departure || !fp?.arrival) continue;
          const dep = normalizeCode(fp.departure);
          const arr = normalizeCode(fp.arrival);

          if(dep === focus){
            const f = buildFlightObjectFromPrefile(pf);
            // classify based on prefile stub
            f.status = classifyFlight({ ...f.pilot, cid: f.cid, flight_plan: f.fp }, "dep");
            applyCachedXpIfAvailable(f);
            deps.push(f);
            if(!flightsByCid.has(String(f.cid))) flightsByCid.set(String(f.cid), []);
            flightsByCid.get(String(f.cid)).push(f);
          }

          if(arr === focus){
            const f = buildFlightObjectFromPrefile(pf);
            f.status = classifyFlight({ ...f.pilot, cid: f.cid, flight_plan: f.fp }, "arr");
            applyCachedXpIfAvailable(f);
            arrs.push(f);
            if(!flightsByCid.has(String(f.cid))) flightsByCid.set(String(f.cid), []);
            flightsByCid.get(String(f.cid)).push(f);
          }
        }
      }

      deps = sortFlights(deps, settings.depSort, "dep");
      arrs = sortFlights(arrs, settings.arrSort, "arr");

      lastDeps = deps;
      lastArrs = arrs;
	  
	  prefetchGateIndexesForArrOrigins(arrs);


      await depBoard.render(deps);
      await arrBoard.render(arrs);

      requestXpForVisibleFlights();
      scheduleAirportXpIndexUpdate();

      const ageSec = lastFeedTs ? (Date.now() - lastFeedTs.getTime())/1000 : null;
      setFeedStatus({ ok:true, msg:"Feed: OK", ageSec });
    }catch(err){
      console.warn("Feed refresh failed:", err);
      setFeedStatus({ ok:false, msg:"Feed: ERROR", ageSec:null });
      scheduleAirportXpIndexUpdate();
    }
  }

  function startLoop(){
    if(feedTimer) clearInterval(feedTimer);
    feedTimer = setInterval(refresh, settings.feedIntervalMs);
  }

  function updateUtcClock(){
    utcClockEl.textContent = new Date().toISOString().slice(11,19);
    if(lastFeedTs){
      const ageSec = (Date.now() - lastFeedTs.getTime())/1000;
      feedAge.textContent = `${Math.max(0, Math.round(ageSec))}s`;
    }
  }
  setInterval(updateUtcClock, 250);

  async function applyAirport(code, fromConfig=false){
    settings.airportInput = normalizeCode(code || "EDDB");
    saveSettings();
    currentAirportIcao = resolveAirportToIcao(settings.airportInput);
ensureGateIndexForIcao(currentAirportIcao)
  .then(() => refresh())
  .catch(() => {});
    limiter.clear();
    inflightXp.clear();

    if(!fromConfig) rebuildLegend();
    await refresh();
  }

  /********************
   * Events
   ********************/
  applyAirportBtn.addEventListener("click", () => applyAirport(airportInputEl.value));
  airportInputEl.addEventListener("keydown", (e) => { if(e.key === "Enter") applyAirport(airportInputEl.value); });
  refreshBtn.addEventListener("click", refresh);

  depSortEl.addEventListener("change", () => { settings.depSort.by = depSortEl.value; saveSettings(); refresh(); });
  depDirBtn.addEventListener("click", () => { settings.depSort.dir *= -1; depDirBtn.textContent = settings.depSort.dir === 1 ? "▲" : "▼"; saveSettings(); refresh(); });

  arrSortEl.addEventListener("change", () => { settings.arrSort.by = arrSortEl.value; saveSettings(); refresh(); });
  arrDirBtn.addEventListener("click", () => { settings.arrSort.dir *= -1; arrDirBtn.textContent = settings.arrSort.dir === 1 ? "▲" : "▼"; saveSettings(); refresh(); });

  /********************
   * Boot
   ********************/
  async function boot(){
    airportInputEl.value = settings.airportInput || "EDDB";
    depDirBtn.textContent = settings.depSort.dir === 1 ? "▲" : "▼";
    arrDirBtn.textContent = settings.arrSort.dir === 1 ? "▲" : "▼";

    await ensureAirportIndex();
    currentAirportIcao = resolveAirportToIcao(settings.airportInput);
ensureGateIndexForIcao(currentAirportIcao).then(() => refresh()).catch(() => {});

    applyLanguage();      // sets UI + sort options + headers + legend
    setFeedStatus({ ok:true, msg:"Feed: …", ageSec:null });

    await refresh();
    startLoop();
  }
  boot();
})();
</script>
</body>
</html>
